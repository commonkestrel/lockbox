{\rtf\ansi\deff0\widowctrl \f0\fs20 
{\colortbl;\red0\green0\blue0;\red255\green0\blue0;\red0\green255\blue0;\red0\green0\blue255;}
{\fonttbl{\f0\froman\fcharset0\fprq2 Times New Roman;}
{\f1\fmodern\fcharset0\fprq1 Courier New;}
{\f2\froman\fcharset2\fprq2 Symbol;}}
{\stylesheet {\widctlpar \f0\fs20 \snext0 Normal;}
{\s1\widctlpar \f1\fs18 \sbasedon0\snext1 Quotation;}
{\s2\widctlpar \f0\fs48\sa600\pagebb\keepn\ul \sbasedon0\snext2 Heading 1;}
{\s3\widctlpar \f0\fs24\sb200\keepn\sa200\b \sbasedon0\snext3 Heading 2;}
{\s4\widctlpar \f0\fs20\tqc\tx4153\tqr\tx8306 \sbasedon0\snext4 Header;}
{\s5\widctlpar \f0\fs24\tqr\tldot\tx8640 \sbasedon0\snext0 TOC 1;}
{\s6\widctlpar \f0\fs20\tqr\tldot\tx8640 \sbasedon0\snext0 Index 1;}}
{\header \pard\plain \s4 \f0\fs20\tqc\tx4153\tqr\tx8306 \pvpara\phmrg\posxr\posy0 page {\field{\*\fldinst PAGE}{\fldrslt 2}}
\par \pard \s4\ri360 \f0\fs20\tqc\tx4153\tqr\tx8306 {\i Allegro - a game programming library} \pard}
\par {\s1 \f1\fs18 
\par      ______   ___    ___
\par     /\\  _  \\ /\\_ \\  /\\_ \\
\par     \\ \\ \\L\\ \\\\//\\ \\ \\//\\ \\      __     __   _ __   ___ 
\par      \\ \\  __ \\ \\ \\ \\  \\ \\ \\   /'__`\\ /'_ `\\/\\`'__\\/ __`\\
\par       \\ \\ \\/\\ \\ \\_\\ \\_ \\_\\ \\_/\\  __//\\ \\L\\ \\ \\ \\//\\ \\L\\ \\
\par        \\ \\_\\ \\_\\/\\____\\/\\____\\ \\____\\ \\____ \\ \\_\\\\ \\____/
\par         \\/_/\\/_/\\/____/\\/____/\\/____/\\/___L\\ \\/_/ \\/___/
\par                                        /\\____/
\par                                        \\_/__/     Version 4.2.3
\par 
\par 
\par                 A game programming library.
\par 
\par              By Shawn Hargreaves, Oct 29, 2009.
\par 
\par                 See the AUTHORS file for a
\par                complete list of contributors.
\par }\par \par \par \par \par \par #include <std_disclaimer.h>
{\i \par \par "I do not accept responsibility for any effects, adverse or otherwise, 
that this code may have on you, your computer, your sanity, your dog, 
and anything else that you can think of. Use it at your own risk." 
\par}\par \par {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Contents}Contents\par }
\par 
{\field{\*\fldinst TOC \\t "Heading 1" }{\fldrslt {\b\i\ul\fs24\cf2 Update this field to generate the table of contents.}}}
\par \par \par \par \par {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Using Allegro}Using Allegro\par }
See readme.txt for a general introduction, copyright details, and 
information about how to install Allegro and link your program with it. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v install_allegro}install_allegro(int system_id, int *errno_ptr, int (*atexit_ptr)());\par }
{\li400 Initialises the Allegro library. You must call either this or 
allegro_init() before doing anything other than using the Unicode 
routines. If you want to use a text mode other than UTF-8, you can set 
it with set_uformat() before you call this. The other functions that can 
be called before this one will be marked explicitly in the documentation, 
like set_config_file(). 
\par \par The available system ID codes will vary from one platform to another, but 
you will almost always want to pass SYSTEM_AUTODETECT. Alternatively, 
SYSTEM_NONE installs a stripped down version of Allegro that won't even 
try to touch your hardware or do anything platform specific: this can be 
useful for situations where you only want to manipulate memory bitmaps, 
such as the text mode datafile tools or the Windows GDI interfacing 
functions. 
\par \par The `errno_ptr' and `atexit_ptr' parameters should point to the errno 
variable and atexit function from your libc: these are required because 
when Allegro is linked as a DLL, it doesn't have direct access to your 
local libc data. `atexit_ptr' may be NULL, in which case it is your 
responsibility to call allegro_exit() manually. Example: 
\par {\s1 \f1\fs18 
\par       install_allegro(SYSTEM_AUTODETECT, &errno, atexit);\par}
\par This function returns zero on success and non-zero on failure (e.g. no 
system driver could be used). Note: in previous versions of Allegro this 
function would abort on error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v allegro_init}allegro_init();\par }
{\li400 Macro which initialises the Allegro library. This is the same thing as 
calling install_allegro(SYSTEM_AUTODETECT, &errno, atexit). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v allegro_exit}allegro_exit();\par }
{\li400 Closes down the Allegro system. This includes returning the system to 
text mode and removing whatever mouse, keyboard, and timer routines have 
been installed. You don't normally need to bother making an explicit call 
to this function, because allegro_init() installs it as an atexit() 
routine so it will be called automatically when your program exits. 
\par \par Note that after you call this function, other functions like 
destroy_bitmap() will most likely crash. This is a problem for C++ global 
destructors, which usually get called after atexit(), so don't put Allegro 
calls in them. You can write the destructor code in another method which 
you can manually call before your program exits, avoiding this problem. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Macro {\xe\v END_OF_MAIN}END_OF_MAIN()\par }
{\li400 In order to maintain cross-platform compatibility, you have to put this 
macro at the very end of your main function. This macro uses some `magic' 
to mangle your main procedure on platforms that need it like Windows, 
some flavours of UNIX or MacOS X. On the other platforms this macro 
compiles to nothing, so you don't have to #ifdef around it. Example: 
\par {\s1 \f1\fs18 
\par       int main(void)
\par       \{
\par          allegro_init();
\par          /* more stuff goes here */
\par          ...
\par          return 0;
\par       \}
\par       END_OF_MAIN()\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b extern char {\xe\v allegro_id}allegro_id[];\par }
{\li400 Text string containing a date and version number for the library, in case 
you want to display these somewhere. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern char {\xe\v allegro_error}allegro_error[ALLEGRO_ERROR_SIZE];\par }
{\li400 Text string used by set_gfx_mode(), install_sound() and other functions to 
report error messages. If they fail and you want to tell the user why, this 
is the place to look for a description of the problem. Example: 
\par {\s1 \f1\fs18 
\par       void abort_on_error(const char *message)
\par       \{
\par          if (screen != NULL)
\par             set_gfx_mode(GFX_TEXT, 0, 0, 0, 0);
\par 
\par          allegro_message("%s.\\nLast Allegro error `%s'\\n",
\par                          message, allegro_error);
\par          exit(-1);
\par       \}
\par       ...
\par          if (some_allegro_function() == ERROR_CODE)
\par             abort_on_error("Error calling some function!");\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b \par \par #define {\xe\v ALLEGRO_VERSION}ALLEGRO_VERSION\par }
{\li400 Defined to the major version of Allegro. From a version number like 
4.1.16, this would be defined to the integer 4. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b #define {\xe\v ALLEGRO_SUB_VERSION}ALLEGRO_SUB_VERSION\par }
{\li400 Defined to the middle version of Allegro. From a version number like 
4.1.16, this would be defined to the integer 1. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b #define {\xe\v ALLEGRO_WIP_VERSION}ALLEGRO_WIP_VERSION\par }
{\li400 Defined to the minor version of Allegro. From a version number like 
4.1.16, this would be defined to the integer 16. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b #define {\xe\v ALLEGRO_VERSION_STR}ALLEGRO_VERSION_STR\par }
{\li400 Defined to a text string containing all version numbers and maybe some 
additional text. This could be `4.2.1 (SVN)' for an Allegro version 
obtained straight from the SVN repository. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b #define {\xe\v ALLEGRO_DATE_STR}ALLEGRO_DATE_STR\par }
{\li400 Defined to a text string containing the year this version of Allegro was 
released, like `2004'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b #define {\xe\v ALLEGRO_DATE}ALLEGRO_DATE\par }
{\li400 Defined to an integer containing the release date of Allegro in the packed 
format `yyyymmdd'. Example: 
\par {\s1 \f1\fs18 
\par       const int year = ALLEGRO_DATE / 10000;
\par       const int month = (ALLEGRO_DATE / 100) % 100;
\par       const int day = ALLEGRO_DATE % 100;
\par 
\par       allegro_message("Year %d, month %d, day %d\\n",
\par          year, month, day);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b Macro {\xe\v AL_ID}AL_ID(a,b,c,d)\par }
{\li400 This macro can be used to create a packed 32 bit integer from 8 bit 
characters, on both 32 and 64 bit machines. These can be used for various 
things, like custom datafile objects or system IDs. Example: 
\par {\s1 \f1\fs18 
\par       #define OSTYPE_LINUX       AL_ID('T','U','X',' ')\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b Macro {\xe\v MAKE_VERSION}MAKE_VERSION(a, b, c)\par }
{\li400 This macro can be used to check if some Allegro version is (binary) 
compatible with the current version. It is safe to use > and < to 
check if one version is more recent than another. 
The third number is ignored if the second number is even, so 
MAKE_VERSION(4, 2, 0) is equivalent to MAKE_VERSION(4, 2, 1). 
This is because of our version numbering policy since 4.0.0: 
the second number is even for stable releases, which must be 
ABI-compatible with earlier versions of the same series. 
This macro is mainly useful for addon packages and libraries. See the 
`ABI compatibility information' section of the manual for more detailed 
information. Example: 
\par {\s1 \f1\fs18 
\par       /* Check if the current version is compatible with Allegro 4.2.0 */
\par       #if (MAKE_VERSION(4, 2, 0) <= MAKE_VERSION(ALLEGRO_VERSION, \\
\par                          ALLEGRO_SUB_VERSION, ALLEGRO_WIP_VERSION))
\par          /* Allegro 4.2.0 compatibility */
\par       #else
\par          /* Work-around */
\par       #endif\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v os_type}os_type;\par }
{\li400 Set by allegro_init() to one of the values: 
\par {\s1 \f1\fs18 
\par       OSTYPE_UNKNOWN    - unknown, or regular MSDOS
\par       OSTYPE_WIN3       - Windows 3.1 or earlier
\par       OSTYPE_WIN95      - Windows 95
\par       OSTYPE_WIN98      - Windows 98
\par       OSTYPE_WINME      - Windows ME
\par       OSTYPE_WINNT      - Windows NT
\par       OSTYPE_WIN2000    - Windows 2000
\par       OSTYPE_WINXP      - Windows XP
\par       OSTYPE_WIN2003    - Windows 2003
\par       OSTYPE_WINVISTA   - Windows Vista
\par       OSTYPE_OS2        - OS/2
\par       OSTYPE_WARP       - OS/2 Warp 3
\par       OSTYPE_DOSEMU     - Linux DOSEMU
\par       OSTYPE_OPENDOS    - Caldera OpenDOS
\par       OSTYPE_LINUX      - Linux
\par       OSTYPE_SUNOS      - SunOS/Solaris
\par       OSTYPE_FREEBSD    - FreeBSD
\par       OSTYPE_NETBSD     - NetBSD
\par       OSTYPE_IRIX       - IRIX
\par       OSTYPE_DARWIN     - Darwin
\par       OSTYPE_QNX        - QNX
\par       OSTYPE_UNIX       - Unknown Unix variant
\par       OSTYPE_BEOS       - BeOS
\par       OSTYPE_MACOS      - MacOS
\par       OSTYPE_MACOSX     - MacOS X\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 extern int {\xe\v os_version}os_version;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 extern int {\xe\v os_revision}os_revision;\par }
{\li400 The major and minor version of the Operating System currently running. 
Set by allegro_init(). If Allegro for some reason was not able to 
retrieve the version of the Operating System, os_version and 
os_revision will be set to -1. For example: Under Win98 SE (v4.10.2222) 
os_version will be set to 4 and os_revision to 10. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v os_multitasking}os_multitasking;\par }
{\li400 Set by allegro_init() to either TRUE or FALSE depending on whether your 
Operating System is multitasking or not. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v allegro_message}allegro_message(const char *text_format, ...);\par }
{\li400 Outputs a message, using a printf() format string. Usually you want to 
use this to report messages to the user in an OS independent way when some 
Allegro subsystem cannot be initialised. But you must not use this function 
if you are in a graphic mode, only before calling set_gfx_mode(), or after 
a set_gfx_mode(GFX_TEXT). Also, this function depends on a system driver 
being installed, which means that it won't display the message at all on 
some platforms if Allegro has not been initialised correctly. 
\par \par On platforms featuring a windowing system, it will bring up a blocking GUI 
message box. If there is no windowing system, it will try to print the 
string to a text console, attempting to work around codepage differences 
by reducing any accented characters to 7-bit ASCII approximations. 
Example: 
\par {\s1 \f1\fs18 
\par       if (allegro_init() != 0)
\par          exit(1);
\par 
\par       if (init_my_data() != 0) \{
\par          allegro_message("Sorry, missing game data!\\n");
\par          exit(2);
\par       \}\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_window_title}set_window_title(const char *name);\par }
{\li400 On platforms that are capable of it, this routine alters the window title 
for your Allegro program. Note that Allegro cannot set the window title 
when running in a DOS box under Windows. Example: 
\par {\s1 \f1\fs18 
\par       set_window_title("Allegro rules!");\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v set_close_button_callback}set_close_button_callback(void (*proc)(void));\par }
{\li400 On platforms that have a close button, this routine installs a callback 
function to handle the close event. In other words, when the user clicks 
the close button on your program's window or any equivalent device, the 
function you specify here will be called. 
\par \par This function should not generally attempt to exit the program or save 
any data itself. The function could be called at any time, and there is 
usually a risk of conflict with the main thread of the program. Instead, 
you should set a flag during this function, and test it on a regular 
basis in the main loop of the program. 
\par \par Pass NULL as the `proc' argument to this function to disable the close 
button functionality, which is the default state. 
\par \par Note that Allegro cannot intercept the close button of a DOS box in 
Windows. 
\par \par Also note that the supplied callback is also called under MacOS X when 
the user hits Command-Q or selects "Quit" from the application menu. 
Example: 
\par {\s1 \f1\fs18 
\par       volatile int close_button_pressed = FALSE;
\par 
\par       void close_button_handler(void)
\par       \{
\par          close_button_pressed = TRUE;
\par       \}
\par       END_OF_FUNCTION(close_button_handler)
\par       ...
\par       
\par       allegro_init();
\par       LOCK_FUNCTION(close_button_handler);
\par       set_close_button_callback(close_button_handler);
\par       ...
\par          
\par       while (!close_button_pressed)
\par          do_stuff();\par}
\par Returns zero on success and non-zero on failure (e.g. the feature is not 
supported by the platform). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v desktop_color_depth}desktop_color_depth();\par }
{\li400 Finds out the currently selected desktop color depth. You can use this 
information to make your program use the same color depth as the desktop, 
which will likely make it run faster because the graphic driver won't be 
doing unnecessary color conversions behind your back. 
\par \par Under some OSes, switching to a full screen graphics mode may automatically 
change the desktop color depth. You have, therefore, to call this function 
before setting any graphics mode in order to retrieve the real desktop 
color depth. Example: 
\par {\s1 \f1\fs18 
\par       allegro_init();
\par       ...
\par       if ((depth = desktop_color_depth()) != 0) \{
\par          set_color_depth(depth);
\par       \}\par}
\par Returns the color depth or zero on platforms where this information is not 
available or does not apply. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_desktop_resolution}get_desktop_resolution(int *width, int *height);\par }
{\li400 Finds out the currently selected desktop resolution. You can use this 
information to avoid creating windows bigger than the current resolution. 
This is especially important for some windowed drivers which are unable 
to create windows bigger than the desktop. Each parameter is a pointer 
to an integer where one dimension of the screen will be stored. 
\par \par Under some OSes, switching to a full screen graphics mode may automatically 
change the desktop resolution. You have, therefore, to call this function 
before setting any graphics mode in order to retrieve the real desktop 
resolution. Example: 
\par {\s1 \f1\fs18 
\par       int width, height;
\par       
\par       allegro_init();
\par       ...
\par       if (get_desktop_resolution(&width, &height) == 0) \{
\par          /* Got the resolution correctly */
\par       \}\par}
\par Returns zero on success, or a negative number if this information is not 
available or does not apply, in which case the values stored in the 
variables you provided for `width' and `height' are undefined. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v check_cpu}check_cpu();\par }
{\li400 Detects the CPU type, setting the following global variables. You don't 
normally need to call this, because allegro_init() will do it for you. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern char {\xe\v cpu_vendor}cpu_vendor[];\par }
{\li400 On Intel PCs, contains the CPU vendor name if known. On Mac OSX systems 
this contains the PPC subtype name. On other platforms, this may be an empty 
string. You can read this variable after you have called check_cpu() 
(which is automatically called by allegro_init()). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v cpu_family}cpu_family;\par }
{\li400 Contains the Intel type, where applicable. Allegro defines the following 
CPU family types: 
\par {\s1 \f1\fs18 
\par       CPU_FAMILY_UNKNOWN  - The type of processor is unknown
\par       CPU_FAMILY_I386     - The processor is an Intel-compatible 386
\par       CPU_FAMILY_I486     - The processor is an Intel-compatible 486
\par       CPU_FAMILY_I586     - The processor is a Pentium or equivalent
\par       CPU_FAMILY_I686     - The processor is a Pentium Pro, II, III
\par                             or equivalent
\par       CPU_FAMILY_ITANIUM  - The processor is an Itanium processor
\par       CPU_FAMILY_POWERPC  - The processor is a PowerPC processor
\par       CPU_FAMILY_EXTENDED - The processor type needs to be read
\par                             from the cpu_model
\par }\par You can read this variable after you have called check_cpu() 
(which is automatically called by allegro_init()). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v cpu_model}cpu_model;\par }
{\li400 Contains the CPU submodel, where applicable. Allegro defines at least the 
following CPU family types (see include/allegro/system.h for a more 
complete list): 
\par {\s1 \f1\fs18 
\par       CPU_FAMILY_I586:
\par          CPU_MODEL_PENTIUM, CPU_MODEL_K5, CPU_MODEL_K6
\par 
\par       CPU_FAMILY_I686:
\par          CPU_MODEL_PENTIUMPRO, CPU_MODEL_PENTIUMII,
\par          CPU_MODEL_PENTIUMIIIKATMAI, CPU_MODEL_PENTIUMIIICOPPERMINE,
\par          CPU_MODEL_ATHLON, CPU_MODEL_DURON
\par 
\par       CPU_FAMILY_EXTENDED:
\par          CPU_MODEL_PENTIUMIV, CPU_MODEL_XEON,
\par          CPU_MODEL_ATHLON64, CPU_MODEL_OPTERON
\par 
\par       CPU_FAMILY_POWERPC:
\par          CPU_MODEL_POWERPC_x, for x=601-604, 620, 750, 7400, 7450
\par }\par You can read this variable after you have called check_cpu() (which is 
automatically called by allegro_init()). Make sure you check the cpu_family 
and cpu_vendor so you know which models make sense to check. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v cpu_capabilities}cpu_capabilities;\par }
{\li400 Contains CPU flags indicating what features are available on the current 
CPU. The flags can be any combination of these: 
\par {\s1 \f1\fs18 
\par       CPU_ID       - Indicates that the "cpuid" instruction is
\par                      available. If this is set, then all Allegro CPU
\par                      variables are 100% reliable, otherwise there
\par                      may be some mistakes.
\par       CPU_FPU      - An FPU is available.
\par       CPU_IA64     - Running on Intel 64 bit CPU
\par       CPU_AMD64    - Running on AMD 64 bit CPU
\par       CPU_MMX      - Intel MMX  instruction set is available.
\par       CPU_MMXPLUS  - Intel MMX+ instruction set is available.
\par       CPU_SSE      - Intel SSE  instruction set is available.
\par       CPU_SSE2     - Intel SSE2 instruction set is available.
\par       CPU_SSE3     - Intel SSE3 instruction set is available.
\par       CPU_3DNOW    - AMD 3DNow! instruction set is available.
\par       CPU_ENH3DNOW - AMD Enhanced 3DNow! instruction set is
\par                      available.
\par       CPU_CMOV     - Pentium Pro "cmov" instruction is available.
\par }\par You can check for multiple features by OR-ing the flags together. 
For example, to check if the CPU has an FPU and MMX instructions 
available, you'd do: 
\par {\s1 \f1\fs18 
\par       if ((cpu_capabilities & (CPU_FPU | CPU_MMX)) ==
\par           (CPU_FPU | CPU_MMX)) \{
\par          printf("CPU has both an FPU and MMX instructions!\\n");
\par       \}
\par }\par You can read this variable after you have called check_cpu() (which is 
automatically called by allegro_init()). 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Structures and types defined by Allegro}Structures and types defined by Allegro\par }
There are several structures and types defined by Allegro which are used 
in many functions (like the BITMAP structure). This section of the manual 
describes their useful content from a user point of view when they don't fit 
very well any of the existing manual sections, and redirects you to the 
appropriate section when it's already described there. Note that unless stated 
otherwise, the contents shown here are just for read only purposes, there 
might be other internal flags, but you shouldn't depend on them being 
available in past/future versions of Allegro. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef long {\xe\v fixed}fixed\par }
{\li400 This is a fixed point integer which can replace float with similar results 
and is faster than float on low end machines. Read chapter "Fixed point 
math routines" for the full explanation. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v BITMAP}BITMAP\par }
{\li400 \par {\s1 \f1\fs18 
\par    int w, h;               - size of the bitmap in pixels
\par    int clip;               - non-zero if clipping is turned on
\par    int cl, cr, ct, cb;     - clip rectangle left, right, top,
\par                              and bottom
\par    unsigned char *line[];  - pointers to the start of each line
\par }\par There is some other stuff in the structure as well, but it is liable to 
change and you shouldn't use anything except the above. The `w' and `h' 
fields can be used to obtain the size of an existing bitmap: 
\par {\s1 \f1\fs18 
\par       bmp = load_bitmap("file.bmp", pal);
\par       allegro_message("Bitmap size: (%dx%d)\\n", bmp->w, bmp->h);
\par }\par The clipping rectangle is inclusive on the left and top (0 allows drawing 
to position 0) but exclusive on the right and bottom (10 allows drawing 
to position 9, but not to 10). Note this is not the same format as that of 
the clipping API, which takes inclusive coordinates for all four corners. 
All the values of this structure should be regarded as read-only, with the 
exception of the line field, whose access is described in depth in the 
"Direct access to video memory" section of the manual. If you want to 
modify the clipping region, please refrain from changing this structure. 
Use set_clip_rect() instead. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v RLE_SPRITE}RLE_SPRITE\par }
{\li400 \par {\s1 \f1\fs18 
\par    int w, h;           - width and height in pixels
\par    int color_depth;    - color depth of the image
\par }\par RLE sprites store the image in a simple run-length encoded format, where 
repeated zero pixels are replaced by a single length count, and strings of 
non-zero pixels are preceded by a counter giving the length of the solid 
run. Read chapter "RLE sprites" for a description of the restrictions and 
how to obtain/use this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v COMPILED_SPRITE}COMPILED_SPRITE\par }
{\li400 \par {\s1 \f1\fs18 
\par    short planar;        - set if it's a planar (mode-X) sprite
\par    short color_depth;   - color depth of the image
\par    short w, h;          - size of the sprite
\par }\par Compiled sprites are stored as actual machine code instructions that draw 
a specific image onto a bitmap, using mov instructions with immediate data 
values. Read chapter "Compiled sprites" for a description of the 
restrictions and how to obtain/use this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v JOYSTICK_INFO}JOYSTICK_INFO\par }
{\li400 \par {\s1 \f1\fs18 
\par    int flags;                       - status flags for this
\par                                       joystick
\par    int num_sticks;                  - how many stick inputs?
\par    int num_buttons;                 - how many buttons?
\par    JOYSTICK_STICK_INFO stick[n];    - stick state information
\par    JOYSTICK_BUTTON_INFO button[n];  - button state information
\par }\par Read chapter "Joystick routines" for a description on how to obtain/use 
this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v JOYSTICK_BUTTON_INFO}JOYSTICK_BUTTON_INFO\par }
{\li400 \par {\s1 \f1\fs18 
\par    int b;                           - boolean on/off flag
\par    char *name;                      - description of this
\par                                       button
\par }\par Read chapter "Joystick routines" for a description on how to obtain/use 
this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v JOYSTICK_STICK_INFO}JOYSTICK_STICK_INFO\par }
{\li400 \par {\s1 \f1\fs18 
\par    int flags;                       - status flags for this
\par                                       input
\par    int num_axis;                    - how many axes do we
\par                                       have? (note the misspelling)
\par    JOYSTICK_AXIS_INFO axis[n];      - axis state information
\par    char *name;                      - description of this
\par                                       input
\par }\par Read chapter "Joystick routines" for a description on how to obtain/use 
this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v JOYSTICK_AXIS_INFO}JOYSTICK_AXIS_INFO\par }
{\li400 \par {\s1 \f1\fs18 
\par    int pos;                         - analogue axis position
\par    int d1, d2;                      - digital axis position
\par    char *name;                      - description of this axis
\par }\par Read chapter "Joystick routines" for a description on how to obtain/use 
this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v GFX_MODE_LIST}GFX_MODE_LIST\par }
{\li400 \par {\s1 \f1\fs18 
\par    int num_modes;
\par    GFX_MODE *mode;
\par }\par Structure returned by get_gfx_mode_list, which contains an array of 
GFX_MODE structures. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v GFX_MODE}GFX_MODE\par }
{\li400 \par {\s1 \f1\fs18 
\par    int width, height, bpp;
\par }\par Structure contained in GFX_MODE_LIST. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b #define {\xe\v PAL_SIZE}PAL_SIZE\par }
{\li400 Preprocessor constant equal to 256. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef {\xe\v PALETTE}PALETTE RGB[PAL_SIZE]\par }
{\li400 Allegro palettes are arrays of PAL_SIZE RGB entries. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v RGB}RGB\par }
{\li400 \par {\s1 \f1\fs18 
\par    unsigned char r, g, b;
\par }\par Palette entry. It contains an additional field for the purpose of padding 
but you should not usually care about it. Read chapter "Palette routines" 
for a description on how to obtain/use this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v V3D}V3D\par }
{\li400 \par {\s1 \f1\fs18 
\par    fixed x, y, z;       - position
\par    fixed u, v;          - texture map coordinates
\par    int c;               - color
\par }\par A vertex structure used by polygon3d and other polygon rendering 
functions. Read the description of polygon3d() for a description on how 
to obtain/use this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v V3D_f}V3D_f\par }
{\li400 \par {\s1 \f1\fs18 
\par    float x, y, z;       - position
\par    float u, v;          - texture map coordinates
\par    int c;               - color
\par }\par Like V3D but using float values instead of fixed ones. Read the 
description of polygon3d_f() for a description on how to obtain/use this 
structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v COLOR_MAP}COLOR_MAP\par }
{\li400 \par {\s1 \f1\fs18 
\par    unsigned char data[PAL_SIZE][PAL_SIZE];
\par }\par Read chapter "Transparency and patterned drawing", section "256-color 
transparency" for a description on how to obtain/use this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v RGB_MAP}RGB_MAP\par }
{\li400 \par {\s1 \f1\fs18 
\par    unsigned char data[32][32][32];
\par }\par Read chapter "Converting between color formats" for a description on how 
to obtain/use this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b struct {\xe\v al_ffblk}al_ffblk\par }
{\li400 \par {\s1 \f1\fs18 
\par    int attrib;       - actual attributes of the file found
\par    time_t time;      - modification time of file
\par    char name[512];   - name of file
\par }\par Read the description of al_findfirst for a description on how to 
obtain/use this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v DATAFILE}DATAFILE\par }
{\li400 \par {\s1 \f1\fs18 
\par    void *dat;     - pointer to the actual data
\par    int type;      - type of the data
\par    long size;     - size of the data in bytes
\par    void *prop;    - list of object properties
\par }\par Read chapter "Datafile routines", section "Using datafiles" for a 
description on how to obtain/use this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v MATRIX}MATRIX\par }
{\li400 \par {\s1 \f1\fs18 
\par    fixed v[3][3];           - 3x3 scaling and rotation component
\par    fixed t[3];              - x/y/z translation component
\par }\par Fixed point matrix structure. Read chapter "3D math routines" for a 
description on how to obtain/use this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v MATRIX_f}MATRIX_f\par }
{\li400 \par {\s1 \f1\fs18 
\par    float v[3][3];           - 3x3 scaling and rotation component
\par    float t[3];              - x/y/z translation component
\par }\par Floating point matrix structure. Read chapter "3D math routines" for a 
description on how to obtain/use this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v QUAT}QUAT\par }
{\li400 \par {\s1 \f1\fs18 
\par    float w, x, y, z;
\par }\par Read chapter "Quaternion math routines" for a description on how to 
obtain/use this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v DIALOG}DIALOG\par }
{\li400 \par {\s1 \f1\fs18 
\par    int (*proc)(int, DIALOG *, int); - dialog procedure
\par                                       (message handler)
\par    int x, y, w, h;       - position and size of the object
\par    int fg, bg;           - foreground and background colors
\par    int key;              - ASCII keyboard shortcut
\par    int flags;            - flags about the status of the object
\par    int d1, d2;           - whatever you want to use them for
\par    void *dp, *dp2, *dp3; - pointers to more object-specific data
\par }\par This is the structure which contains a GUI object. Read chapter "GUI 
routines" for a description on how to obtain/use this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v MENU}MENU\par }
{\li400 \par {\s1 \f1\fs18 
\par    char *text;          - the text to display for the menu item
\par    int (*proc)(void);   - called when the menu item is clicked
\par    struct MENU *child;  - nested child menu
\par    int flags;           - disabled or checked state
\par    void *dp;            - pointer to any data you need
\par }\par Structure used to hold an entry of a menu. Read chapter "GUI routines", 
section "GUI menus" for a description on how to obtain/use this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v DIALOG_PLAYER}DIALOG_PLAYER\par }
{\li400 A structure which holds GUI data used internally by Allegro. Read the 
documentation of init_dialog() for a description on how to obtain/use this 
structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v MENU_PLAYER}MENU_PLAYER\par }
{\li400 A structure which holds GUI data used internally by Allegro. Read the 
documentation of init_menu() for a description on how to obtain/use this 
structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v FONT}FONT\par }
{\li400 A structure holding an Allegro font, usually created beforehand with the 
grabber tool or Allegro's default font. Read chapter "Fonts" for a 
description on how to load/destroy fonts, and chapter "Text output" for a 
description on how to show text. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct BITMAP {\xe\v ZBUFFER}ZBUFFER\par }
{\li400 Structure used by Allegro's 3d zbuffered rendering functions. You are not 
supposed to mix ZBUFFER with BITMAP even though it is currently possible 
to do so. This is just an internal representation, and it may change in 
the future. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v SAMPLE}SAMPLE\par }
{\li400 \par {\s1 \f1\fs18 
\par    int bits;                   - 8 or 16
\par    int stereo;                 - sample type flag
\par    int freq;                   - sample frequency
\par    int priority;               - 0-255
\par    unsigned long len;          - length (in samples)
\par    unsigned long loop_start;   - loop start position
\par    unsigned long loop_end;     - loop finish position
\par    void *data;                 - raw sample data
\par }\par A sample structure, which holds sound data, used by the digital sample 
routines. You can consider all of these fields as read only except 
priority, loop_start and loop_end, which you can change them for example 
after loading a sample from disk. 
\par \par The priority is a value from 0 to 255 (by default set to 128) and controls 
how hardware voices on the sound card are allocated if you attempt to play 
more than the driver can handle. This may be used to ensure that the less 
important sounds are cut off while the important ones are preserved. 
\par \par The variables loop_start and loop_end specify the loop position in sample 
units, and are set by default to the start and end of the sample. 
\par \par If you are creating your own samples on the fly, you might also want to 
modify the raw data of the sample pointed by the data field. The sample 
data are always in unsigned format. This means that if you are loading a 
PCM encoded sound file with signed 16-bit samples, you would have to XOR 
every two bytes (i.e. every sample value) with 0x8000 to change the 
signedness. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v MIDI}MIDI\par }
{\li400 A structure holding MIDI data. Read chapter "Music routines (MIDI)" for a 
description on how to obtain/use this structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v AUDIOSTREAM}AUDIOSTREAM\par }
{\li400 \par {\s1 \f1\fs18 
\par    int voice;  - the hardware voice used for the sample
\par }\par A structure holding an audiostream, which is a convenience wrapper around 
a SAMPLE structure to double buffer sounds too big to fit into memory, or 
do clever things like generating the sound wave real time. 
\par \par While you shouldn't modify directly the value of the voice, you can use 
all of the voice functions in chapter "Digital sample routines" to modify 
the properties of the sound, like the frequency. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v PACKFILE}PACKFILE\par }
{\li400 A packfile structure, similar to the libc FILE structure. Read chapter 
"File and compression routines" for a description on how to obtain/use 
this structure. Note that prior to version 4.1.18, some internal fields 
were accidentally documented - but PACKFILE should be treated as an 
opaque structure, just like the libc FILE type. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v PACKFILE_VTABLE}PACKFILE_VTABLE\par }
{\li400 \par {\s1 \f1\fs18 
\par    int pf_fclose(void *userdata);
\par    int pf_getc(void *userdata);
\par    int pf_ungetc(int c, void *userdata);
\par    long pf_fread(void *p, long n, void *userdata);
\par    int pf_putc(int c, void *userdata);
\par    long pf_fwrite(const void *p, long n, void *userdata);
\par    int pf_fseek(void *userdata, int offset);
\par    int pf_feof(void *userdata);
\par    int pf_ferror(void *userdata);
\par }\par This is the vtable which must be provided for custom packfiles, which then 
can read from and write to wherever you like (eg. files in memory). You 
should provide all the entries of the vtable, even if they are empty stubs 
doing nothing, to avoid Allegro (or you) calling a NULL method at some 
point. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v LZSS_PACK_DATA}LZSS_PACK_DATA\par }
{\li400 Opaque structure for handling LZSS compression. Read chapter "File and 
compression routines for a description on how to obtain/use this 
structure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b typedef struct {\xe\v LZSS_UNPACK_DATA}LZSS_UNPACK_DATA\par }
{\li400 Opaque structure for handling LZSS decompression. Read chapter "File and 
compression routines for a description on how to obtain/use this 
structure. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Unicode routines}Unicode routines\par }
Allegro can manipulate and display text using any character values from 0 
right up to 2^32-1 (although the current implementation of the grabber can 
only create fonts using characters up to 2^16-1). You can choose between a 
number of different text encoding formats, which controls how strings are 
stored and how Allegro interprets strings that you pass to it. This setting 
affects all aspects of the system: whenever you see a function that returns 
a char * type, or that takes a char * as an argument, that text will be in 
whatever format you have told Allegro to use. 
\par \par By default, Allegro uses UTF-8 encoded text (U_UTF8). This is a 
variable-width format, where characters can occupy anywhere from one to four 
bytes. The nice thing about it is that characters ranging from 0-127 are 
encoded directly as themselves, so UTF-8 is upwardly compatible with 7-bit 
ASCII ("Hello, World!" means the same thing regardless of whether you 
interpret it as ASCII or UTF-8 data). Any character values above 128, such 
as accented vowels, the UK currency symbol, and Arabic or Chinese 
characters, will be encoded as a sequence of two or more bytes, each in the 
range 128-255. This means you will never get what looks like a 7-bit ASCII 
character as part of the encoding of a different character value, which 
makes it very easy to manipulate UTF-8 strings. 
\par \par There are a few editing programs that understand UTF-8 format text files. 
Alternatively, you can write your strings in plain ASCII or 16-bit Unicode 
formats, and then use the Allegro textconv program to convert them into 
UTF-8. 
\par \par If you prefer to use some other text format, you can set Allegro to work 
with normal 8-bit ASCII (U_ASCII), or 16-bit Unicode (U_UNICODE) instead, or 
you can provide some handler functions to make it support whatever other 
text encoding you like (for example it would be easy to add support for 32 
bit UCS-4 characters, or the Chinese GB-code format). 
\par \par There is some limited support for alternative 8-bit codepages, via the 
U_ASCII_CP mode. This is very slow, so you shouldn't use it for serious 
work, but it can be handy as an easy way to convert text between different 
codepages. By default the U_ASCII_CP mode is set up to reduce text to a 
clean 7-bit ASCII format, trying to replace any accented vowels with their 
simpler equivalents (this is used by the allegro_message() function when it 
needs to print an error report onto a text mode DOS screen). If you want to 
work with other codepages, you can do this by passing a character mapping 
table to the set_ucodepage() function. 
\par \par Note that you can use the Unicode routines before you call install_allegro() 
or allegro_init(). If you want to work in a text mode other than UTF-8, it 
is best to set it with set_uformat() just before you call these. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_uformat}set_uformat(int type);\par }
{\li400 Sets the current text encoding format. This will affect all parts of 
Allegro, wherever you see a function that returns a char *, or takes a 
char * as a parameter. `type' should be one of these values: 
\par {\s1 \f1\fs18 
\par       U_ASCII     - fixed size, 8-bit ASCII characters
\par       U_ASCII_CP  - alternative 8-bit codepage (see set_ucodepage())
\par       U_UNICODE   - fixed size, 16-bit Unicode characters
\par       U_UTF8      - variable size, UTF-8 format Unicode characters
\par }\par Although you can change the text format on the fly, this is not a good 
idea. Many strings, for example the names of your hardware drivers and 
any language translations, are loaded when you call allegro_init(), so if 
you change the encoding format after this, they will be in the wrong 
format, and things will not work properly. Generally you should only call 
set_uformat() once, before allegro_init(), and then leave it on the same 
setting for the duration of your program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_uformat}get_uformat(void);\par }
{\li400 Finds out what text encoding format is currently selected. This function 
is probably useful only if you are writing an Allegro addon dealing with 
text strings and you use a different codepath for each possible format. 
Example: 
\par {\s1 \f1\fs18 
\par       switch(get_uformat()) \{
\par          case U_ASCII:
\par             do_something();
\par             break;
\par          case U_UTF8:
\par             do_something_else();
\par             break;
\par          ...
\par       \}\par}
\par Returns the currently selected text encoding format. See the documentation 
of set_uformat() for a list of encoding formats. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v register_uformat}register_uformat(int type, int (*u_getc)(const char *s), int (*u_getx)(char **s), int (*u_setc)(char *s, int c), int (*u_width)(const char *s), int (*u_cwidth)(int c), int (*u_isok)(int c));\par }
{\li400 Installs a set of custom handler functions for a new text encoding 
format. The `type' is the ID code for your new format, which should be a 
4-character string as produced by the AL_ID() macro, and which can later 
be passed to functions like set_uformat() and uconvert(). The function 
parameters are handlers that implement the character access for your new 
type: see below for details of these. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_ucodepage}set_ucodepage(const unsigned short *table, const unsigned short *extras);\par }
{\li400 When you select the U_ASCII_CP encoding mode, a set of tables are used to 
convert between 8-bit characters and their Unicode equivalents. You can 
use this function to specify a custom set of mapping tables, which allows 
you to support different 8-bit codepages. 
\par \par The `table' parameter points to an array of 256 shorts, which contain the 
Unicode value for each character in your codepage. The `extras' parameter, 
if not NULL, points to a list of mapping pairs, which will be used when 
reducing Unicode data to your codepage. Each pair consists of a Unicode 
value, followed by the way it should be represented in your codepage. 
The list is terminated by a zero Unicode value. This allows you to create 
a many->one mapping, where many different Unicode characters can be 
represented by a single codepage value (eg. for reducing accented vowels 
to 7-bit ASCII). 
\par \par Allegro will use the `table' parameter when it needs to convert an ASCII 
string to an Unicode string. But when Allegro converts an Unicode string 
to ASCII, it will use both parameters. First, it will loop through the 
`table' parameter looking for an index position pointing at the Unicode 
value it is trying to convert (ie. the `table' parameter is also used for 
reverse matching). If that fails, the `extras' list is used. If that fails 
too, Allegro will put the character `^', giving up the conversion. 
\par \par Note that Allegro comes with a default `table' and `extras' parameters 
set internally. The default `table' will convert 8-bit characters to `^'. 
The default `extras' list reduces Latin-1 and Extended-A characters to 7 
bits in a sensible way (eg. an accented vowel will be reduced to the same 
vowel without the accent). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v need_uconvert}need_uconvert(const char *s, int type, int newtype);\par }
{\li400 Given a pointer to a string (`s'), a description of the type of the string 
(`type'), and the type that you would like this string to be converted into 
(`newtype'), this function tells you whether any conversion is required. No 
conversion will be needed if `type' and `newtype' are the same, or if one 
type is ASCII, the other is UTF-8, and the string contains only character 
values less than 128. As a convenience shortcut, you can pass the value 
U_CURRENT as either of the type parameters, to represent whatever text 
encoding format is currently selected. Example: 
\par {\s1 \f1\fs18 
\par       if (need_uconvert(text, U_UTF8, U_CURRENT)) \{
\par          /* conversion is required */
\par       \}\par}
\par Returns non-zero if any conversion is required or zero otherwise. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v uconvert_size}uconvert_size(const char *s, int type, int newtype);\par }
{\li400 Finds out how many bytes are required to store the specified string `s' 
after a conversion from `type' to `newtype', including the mandatory zero 
terminator of the string. You can use U_CURRENT for either `type' or 
`newtype' as a shortcut to represent whatever text encoding format is 
currently selected. Example: 
\par {\s1 \f1\fs18 
\par       length = uconvert_size(old_string, U_CURRENT, U_UNICODE);
\par       new_string = malloc(length);
\par       ustrcpy(new_string, old_string);\par}
\par Returns the number of bytes required to store the string after conversion. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v do_uconvert}do_uconvert(const char *s, int type, char *buf, int newtype, int size);\par }
{\li400 Converts the specified string `s' from `type' to `newtype', storing at most 
`size' bytes into the output `buf'. The type parameters can use the value 
U_CURRENT as a shortcut to represent the currently selected encoding 
format. Example: 
\par {\s1 \f1\fs18 
\par       char temp_string[256];
\par       do_uconvert(input_string, U_CURRENT, temp_string, U_ASCII, 256);
\par }\par Note that, even for empty strings, your destination string must have at 
least enough bytes to store the terminating null character of the string, 
and your parameter size must reflect this. Otherwise, the debug version of 
Allegro will abort at an assertion, and the release version of Allegro 
will overrun the destination buffer. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v uconvert}uconvert(const char *s, int type, char *buf, int newtype, int size);\par }
{\li400 Higher level function running on top of do_uconvert(). This function 
converts the specified string `s' from `type' to `newtype', storing at most 
`size' bytes into the output `buf' (including the terminating null 
character), but it checks before doing the conversion, and doesn't bother 
if the string formats are already the same (either both types are equal, or 
one is ASCII, the other is UTF-8, and the string contains only 7-bit ASCII 
characters). 
\par \par As a convenience, if `buf' is NULL it will convert the string into an 
internal static buffer and the `size' parameter will be ignored. You should 
be wary of using this feature, though, because that buffer will be 
overwritten the next time this routine is called, so don't expect the data 
to persist across any other library calls. The static buffer may hold less 
than 1024 characters, so you won't be able to convert large chunks of text. 
Example: 
\par {\s1 \f1\fs18 
\par       char *p = uconvert(input_string, U_CURRENT, buffer, U_ASCII, 256);\par}
\par Returns a pointer to `buf' (or the static buffer if you used NULL) if a 
conversion was performed. Otherwise returns a copy of `s'. In any cases, 
you should use the return value rather than assuming that the string will 
always be moved to `buf'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v uconvert_ascii}uconvert_ascii(const char *s, char buf[]);\par }
{\li400 Helper macro for converting strings from ASCII into the current encoding 
format. Expands to uconvert(s, U_ASCII, buf, U_CURRENT, sizeof(buf)). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v uconvert_toascii}uconvert_toascii(const char *s, char buf[]);\par }
{\li400 Helper macro for converting strings from the current encoding format into 
ASCII. Expands to uconvert(s, U_CURRENT, buf, U_ASCII, sizeof(buf)). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern char {\xe\v empty_string}empty_string[];\par }
{\li400 You can't just rely on "" to be a valid empty string in any encoding 
format. This global buffer contains a number of consecutive zeros, so it 
will be a valid empty string no matter whether the program is running in 
ASCII, Unicode, or UTF-8 mode. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ugetc}ugetc(const char *s);\par }
{\li400 Low level helper function for reading Unicode text data. Example: 
\par {\s1 \f1\fs18 
\par       int first_unicode_letter = ugetc(text_string);\par}
\par Returns the character pointed to by `s' in the current encoding format. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 int {\xe\v ugetx}ugetx(char **s);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 int {\xe\v ugetxc}ugetxc(const char **s);\par }
{\li400 Low level helper function for reading Unicode text data. ugetxc is provided 
for working with pointer-to-pointer-to-const char data. Example: 
\par {\s1 \f1\fs18 
\par       char *p = string;
\par       int first_letter, second_letter, third_letter;
\par       first_letter = ugetx(&p);
\par       second_letter = ugetx(&p);
\par       third_letter = ugetx(&p);\par}
\par Returns the character pointed to by `s' in the current encoding format, and 
advances the pointer to the next character after the one just returned. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v usetc}usetc(char *s, int c);\par }
{\li400 Low level helper function for writing Unicode text data. Writes the 
character `c' to the address pointed to by `s'. 
\par \par Returns the number of bytes written, which is equal to the width of the 
character in the current encoding format. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v uwidth}uwidth(const char *s);\par }
{\li400 Low level helper function for testing Unicode text data. 
\par \par Returns the number of bytes occupied by the first character of the 
specified string, in the current encoding format. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ucwidth}ucwidth(int c);\par }
{\li400 Low level helper function for testing Unicode text data. 
\par \par Returns the number of bytes that would be occupied by the specified 
character value, when encoded in the current format. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v uisok}uisok(int c);\par }
{\li400 Low level helper function for testing Unicode text data. Finds out if the 
character value `c' can be encoded correctly in the current format, which 
can be useful if you are converting from Unicode to ASCII or another 
encoding format where the range of valid characters is limited. 
\par \par Returns non-zero if the value can be correctly encoded, zero otherwise. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v uoffset}uoffset(const char *s, int index);\par }
{\li400 Finds out the offset (in bytes from the start of the string) of the 
character at the specified `index' in the string `s'. A zero `index' 
parameter will return the first character of the string. If `index' is 
negative, it counts backward from the end of the string, so an `index' of 
`-1' will return an offset to the last character. Example: 
\par {\s1 \f1\fs18 
\par       int from_third_letter = uoffset(text_string, 2);\par}
\par Returns the offset in bytes to the specified character. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ugetat}ugetat(const char *s, int index);\par }
{\li400 Finds out the character value at the specified `index' in the string. A 
zero `index' parameter will return the first character of the string. If 
`index' is negative, it counts backward from the end of the string, so an 
`index' of `-1' will return the last character of the string. Example: 
\par {\s1 \f1\fs18 
\par       int third_letter = ugetat(text_string, 2);\par}
\par Returns the character value at the specified index in the string. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v usetat}usetat(char *s, int index, int c);\par }
{\li400 Replaces the character at the specified index in the string with value `c', 
handling any adjustments for variable width data (ie. if `c' encodes to a 
different width than the previous value at that location). If `index' is 
negative, it counts backward from the end of the string. Example: 
\par {\s1 \f1\fs18 
\par       usetat(text_string, 2, letter_a);\par}
\par Returns the number of bytes by which the trailing part of the string was 
moved. This is of interest only with text encoding formats where 
characters have a variable length, like UTF-8. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v uinsert}uinsert(char *s, int index, int c);\par }
{\li400 Inserts the character `c' at the specified `index' in the string, sliding 
the rest of the data along to make room. If `index' is negative, it counts 
backward from the end of the string. Example: 
\par {\s1 \f1\fs18 
\par       uinsert(text_string, 0, prefix_letter);\par}
\par Returns the number of bytes by which the trailing part of the string was 
moved. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v uremove}uremove(char *s, int index);\par }
{\li400 Removes the character at the specified `index' within the string, sliding 
the rest of the data back to fill the gap. If `index' is negative, it 
counts backward from the end of the string. Example: 
\par {\s1 \f1\fs18 
\par       int length_in_bytes = ustrsizez(text_string);
\par       ...
\par       length_in_bytes -= uremove(text_string, -1);\par}
\par Returns the number of bytes by which the trailing part of the string was 
moved. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ustrsize}ustrsize(const char *s);\par }
{\li400 Returns the size of the specified string in bytes, not including the 
trailing null character. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ustrsizez}ustrsizez(const char *s);\par }
{\li400 Returns the size of the specified string in bytes, including the trailing 
null character. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v uwidth_max}uwidth_max(int type);\par }
{\li400 Low level helper function for working with Unicode text data. Returns the 
largest number of bytes that one character can occupy in the given 
encoding format. Pass U_CURRENT to represent the current format. Example: 
\par {\s1 \f1\fs18 
\par       char *temp_buffer = malloc(256 * uwidth_max(U_UTF8));\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v utolower}utolower(int c);\par }
{\li400 This function returns `c', converting it to lower case if it is upper case. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v utoupper}utoupper(int c);\par }
{\li400 This function returns `c', converting it to upper case if it is lower case. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v uisspace}uisspace(int c);\par }
{\li400 Returns nonzero if `c' is whitespace, that is, carriage return, newline, 
form feed, tab, vertical tab, or space. Example: 
\par {\s1 \f1\fs18 
\par       for (counter = 0; counter < ustrlen(text_string); counter++) \{
\par          if (uisspace(ugetat(text_string, counter)))
\par             usetat(text_string, counter, '_');
\par       \}\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v uisdigit}uisdigit(int c);\par }
{\li400 Returns nonzero if `c' is a digit. 
\par {\s1 \f1\fs18 
\par       for (counter = 0; counter < ustrlen(text_string); counter++) \{
\par          if (uisdigit(ugetat(text_string, counter)))
\par             usetat(text_string, counter, '*');
\par       \}\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrdup}ustrdup(const char *src)\par }
{\li400 This functions copies the null-terminated string `src' into a newly 
allocated area of memory, effectively duplicating it. Example: 
\par {\s1 \f1\fs18 
\par       void manipulate_string(const char *input_string)
\par       \{
\par          char *temp_buffer = ustrdup(input_string);
\par          /* Now we can modify temp_buffer */
\par          ...\par}
\par Returns the newly allocated string. This memory must be freed by the 
caller. Returns NULL if it cannot allocate space for the duplicated string. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v _ustrdup}_ustrdup(const char *src, void* (*malloc_func)(size_t))\par }
{\li400 Does the same as ustrdup(), but allows the user to specify a custom memory 
allocator function. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrcpy}ustrcpy(char *dest, const char *src);\par }
{\li400 This function copies `src' (including the terminating null character into 
`dest'. You should try to avoid this function because it is very easy to 
overflow the destination buffer. Use ustrzcpy instead. 
\par \par Returns the value of dest. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrzcpy}ustrzcpy(char *dest, int size, const char *src);\par }
{\li400 This function copies `src' (including the terminating null character) into 
`dest', whose length in bytes is specified by `size' and which is 
guaranteed to be null-terminated even if `src' is bigger than `size'. 
\par \par Note that, even for empty strings, your destination string must have at 
least enough bytes to store the terminating null character of the string, 
and your parameter size must reflect this. Otherwise, the debug version of 
Allegro will abort at an assertion, and the release version of Allegro 
will overrun the destination buffer. 
\par \par Returns the value of `dest'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrcat}ustrcat(char *dest, const char *src);\par }
{\li400 This function concatenates `src' to the end of `dest`'. You should try to 
avoid this function because it is very easy to overflow the destination 
buffer, use ustrzcat instead. 
\par \par Returns the value of `dest'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrzcat}ustrzcat(char *dest, int size, const char *src);\par }
{\li400 This function concatenates `src' to the end of `dest', whose length in 
bytes is specified by `size' and which is guaranteed to be null-terminated 
even when `src' is bigger than `size'. 
\par \par Note that, even for empty strings, your destination string must have at 
least enough bytes to store the terminating null character of the string, 
and your parameter size must reflect this. Otherwise, the debug version of 
Allegro will abort at an assertion, and the release version of Allegro 
will overrun the destination buffer. 
\par \par Returns the value of `dest'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ustrlen}ustrlen(const char *s);\par }
{\li400 This function returns the number of characters in `s'. Note that this 
doesn't have to equal the string's size in bytes. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ustrcmp}ustrcmp(const char *s1, const char *s2);\par }
{\li400 This function compares `s1' and `s2'. 
\par \par Returns zero if the strings are equal, a positive number if `s1' comes 
after `s2' in the ASCII collating sequence, else a negative number. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrncpy}ustrncpy(char *dest, const char *src, int n);\par }
{\li400 This function is like ustrcpy() except that no more than `n' characters 
from `src' are copied into `dest'. If `src' is shorter than `n' characters, 
null characters are appended to `dest' as padding until `n' characters have 
been written. 
\par \par Note that if `src' is longer than `n' characters, `dest' will not be 
null-terminated. 
\par \par The return value is the value of `dest'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrzncpy}ustrzncpy(char *dest, int size, const char *src, int n);\par }
{\li400 This function is like ustrzcpy() except that no more than `n' characters 
from `src' are copied into `dest'. If `src' is shorter than `n' characters, 
null characters are appended to `dest' as padding until `n' characters have 
been written. In any case, `dest' is guaranteed to be null-terminated. 
\par \par Note that, even for empty strings, your destination string must have at 
least enough bytes to store the terminating null character of the string, 
and your parameter `size' must reflect this. Otherwise, the debug version 
of Allegro will abort at an assertion, and the release version of Allegro 
will overrun the destination buffer. 
\par \par The return value is the value of `dest'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrncat}ustrncat(char *dest, const char *src, int n);\par }
{\li400 This function is like ustrcat() except that no more than `n' characters 
from `src' are appended to the end of `dest'. If the terminating null 
character in `src' is reached before `n' characters have been written, the 
null character is copied, but no other characters are written. If `n' 
characters are written before a terminating null is encountered, the 
function appends its own null character to `dest', so that `n+1' characters 
are written. You should try to avoid this function because it is very 
easy to overflow the destination buffer. Use ustrzncat instead. 
\par \par The return value is the value of `dest'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrzncat}ustrzncat(char *dest, int size, const char *src, int n);\par }
{\li400 This function is like ustrzcat() except that no more than `n' characters 
from `src' are appended to the end of `dest'. If the terminating null 
character in `src' is reached before `n' characters have been written, the 
null character is copied, but no other characters are written. Note that 
`dest' is guaranteed to be null-terminated. 
\par \par The return value is the value of `dest'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ustrncmp}ustrncmp(const char *s1, const char *s2, int n);\par }
{\li400 This function compares up to `n' characters of `s1' and `s2'. Example: 
\par {\s1 \f1\fs18 
\par       if (ustrncmp(prefix, long_string, ustrlen(prefix)) == 0) \{
\par          /* long_string starts with prefix */
\par       \}\par}
\par Returns zero if the substrings are equal, a positive number if `s1' comes 
after `s2' in the ASCII collating sequence, else a negative number. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ustricmp}ustricmp(const char *s1, const char *s2);\par }
{\li400 This function compares `s1' and `s2', ignoring case. Example: 
\par {\s1 \f1\fs18 
\par       if (ustricmp(string, user_input) == 0) \{
\par          /* string and user_input are equal (ignoring case) */
\par       \}\par}
\par Returns zero if the strings are equal, a positive number if `s1' comes 
after `s2' in the ASCII collating sequence, else a negative number. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ustrnicmp}ustrnicmp(const char *s1, const char *s2, int n);\par }
{\li400 This function compares up to `n' characters of `s1' and `s2', ignoring 
case. Example: 
\par {\s1 \f1\fs18 
\par       if (ustrnicmp(prefix, long_string, ustrlen(prefix)) == 0) \{
\par          /* long_string starts with prefix (ignoring case) */
\par       \}\par}
\par Returns zero if the strings are equal, a positive number if `s1' comes 
after `s2' in the ASCII collating sequence, else a negative number. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrlwr}ustrlwr(char *s);\par }
{\li400 This function replaces all upper case letters in `s' with lower case 
letters. Example: 
\par {\s1 \f1\fs18 
\par       char buffer[] = "UPPER CASE STRING";
\par       allegro_message(ustrlwr(buffer));\par}
\par The return value is the value of `s'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrupr}ustrupr(char *s);\par }
{\li400 This function replaces all lower case letters in `s' with upper case 
letters. Example: 
\par {\s1 \f1\fs18 
\par       char buffer[] = "lower case string";
\par       allegro_message(ustrupr(buffer));\par}
\par The return value is the value of `s'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrchr}ustrchr(const char *s, int c);\par }
{\li400 Finds the first occurrence of the character `c' in the string `s'. Example: 
\par {\s1 \f1\fs18 
\par       char *p = ustrchr("one,two,three,four", ',');\par}
\par Returns a pointer to the first occurrence of `c' in `s', or NULL if no 
match was found. Note that if `c' is NULL, this will return a pointer to 
the end of the string. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrrchr}ustrrchr(const char *s, int c);\par }
{\li400 Finds the last occurrence of the character `c' in the string `s'. Example: 
\par {\s1 \f1\fs18 
\par       char *p = ustrrchr("one,two,three,four", ',');\par}
\par Returns a pointer for the last occurrence of `c' in `s', or NULL if no 
match was found. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrstr}ustrstr(const char *s1, const char *s2);\par }
{\li400 This function finds the first occurrence of string `s2' in string `s1'. 
Example: 
\par {\s1 \f1\fs18 
\par       char *p = ustrstr("hello world", "world");\par}
\par Returns a pointer within `s1', or NULL if `s2' wasn't found. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrpbrk}ustrpbrk(const char *s, const char *set);\par }
{\li400 This function finds the first character in `s' that matches any character 
in `set'. Example: 
\par {\s1 \f1\fs18 
\par       char *p = ustrpbrk("one,two-three.four", "-. ");\par}
\par Returns a pointer to the first match, or NULL if none are found. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrtok}ustrtok(char *s, const char *set);\par }
{\li400 This function retrieves tokens from `s' which are delimited by characters 
from `set'. To initiate the search, pass the string to be searched as `s'. 
For the remaining tokens, pass NULL instead. Warning: Since ustrtok alters 
the string it is parsing, you should always copy the string to a temporary 
buffer before parsing it. Also, this function is not re-entrant (ie. you 
cannot parse two strings at the same time). Example: 
\par {\s1 \f1\fs18 
\par       char *word;
\par       char string[]="some-words with dashes";
\par       char *temp = ustrdup(string);
\par       word = ustrtok(temp, " -");
\par       while (word) \{
\par          allegro_message("Found `%s'\\n", word);
\par          word = ustrtok(NULL, " -");
\par       \}
\par       free(temp);\par}
\par Returns a pointer to the token, or NULL if no more are found. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v ustrtok_r}ustrtok_r(char *s, const char *set, char **last);\par }
{\li400 Reentrant version of ustrtok. The `last' parameter is used to keep track 
of where the parsing is up to and must be a pointer to a char * variable 
allocated by the user that remains the same while parsing the same 
string. Example: 
\par {\s1 \f1\fs18 
\par       char *word, *last;
\par       char string[]="some-words with dashes";
\par       char *temp = ustrdup(string);
\par       word = ustrtok_r(string, " -", &last);
\par       while (word) \{
\par          allegro_message("Found `%s'\\n", word);
\par          word = ustrtok_r(NULL, " -", &last);
\par       \}
\par       free(temp);\par}
\par Returns a pointer to the token, or NULL if no more are found. You can free 
the memory pointed to by `last' once NULL is returned. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b double {\xe\v uatof}uatof(const char *s);\par }
{\li400 Convert as much of the string as possible to an equivalent double 
precision real number. This function is almost like `ustrtod(s, NULL)'. 
\par \par Returns the equivalent value, or zero if the string does not represent a 
number. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b long {\xe\v ustrtol}ustrtol(const char *s, char **endp, int base);\par }
{\li400 This function converts the initial part of `s' to a signed integer, setting 
`*endp' to point to the first unused character, if `endp' is not a NULL 
pointer. The `base' argument indicates what base the digits (or letters) 
should be treated as. If `base' is zero, the base is determined by looking 
for `0x', `0X', or `0' as the first part of the string, and sets the base 
used to 16, 16, or 8 if it finds one. The default base is 10 if none of 
those prefixes are found. Example: 
\par {\s1 \f1\fs18 
\par       char *endp, *string = "456.203 askdfg";
\par       int number = ustrtol(string, &endp, 10);\par}
\par Returns the string converted as a value of type `long int'. If nothing was 
converted, returns zero with `*endp' pointing to the beginning of `s'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b double {\xe\v ustrtod}ustrtod(const char *s, char **endp);\par }
{\li400 This function converts as many characters of `s' that look like a floating 
point number into one, and sets `*endp' to point to the first unused 
character, if `endp' is not a NULL pointer. Example: 
\par {\s1 \f1\fs18 
\par       char *endp, *string = "456.203 askdfg";
\par       double number = ustrtod(string, &endp);\par}
\par Returns the string converted as a value of type `double'. If nothing was 
converted, returns zero with *endp pointing to the beginning of s. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b const char *{\xe\v ustrerror}ustrerror(int err);\par }
{\li400 This function returns a string that describes the error code `err', which 
normally comes from the variable `errno'. Example: 
\par {\s1 \f1\fs18 
\par       PACKFILE *input_file = pack_fopen("badname", "r");
\par       if (input_file == NULL)
\par          allegro_message("%s\\nSorry!\\n", ustrerror(errno));\par}
\par Returns a pointer to a static string that should not be modified or 
freed. If you make subsequent calls to ustrerror(), the string will be 
overwritten. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v usprintf}usprintf(char *buf, const char *format, ...);\par }
{\li400 This function writes formatted data into the output buffer. A NULL 
character is written to mark the end of the string. You should try to avoid 
this function because it is very easy to overflow the destination buffer. 
Use uszprintf instead. 
\par \par Returns the number of characters written, not including the terminating 
null character. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v uszprintf}uszprintf(char *buf, int size, const char *format, ...);\par }
{\li400 This function writes formatted data into the output buffer, whose length 
in bytes is specified by `size' and which is guaranteed to be NULL 
terminated. Example: 
\par {\s1 \f1\fs18 
\par       char buffer[10];
\par       int player_score;
\par       ...
\par       uszprintf(buffer, sizeof(buffer), "Your score is: %d", player_score);\par}
\par Returns the number of characters that would have been written without 
eventual truncation (like with usprintf), not including the terminating 
null character. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v uvsprintf}uvsprintf(char *buf, const char *format, va_list args);\par }
{\li400 This is like usprintf(), but you pass the variable argument list directly, 
instead of the arguments themselves. You can use this function to implement 
printf like functions, also called variadic functions. You should try to 
avoid this function because it is very easy to overflow the destination 
buffer. Use uvszprintf instead. 
\par \par Returns the number of characters written, not including the terminating 
null character. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v uvszprintf}uvszprintf(char *buf, int size, const char *format, va_list args);\par }
{\li400 This is like uszprintf(), but you pass the variable argument list 
directly, instead of the arguments themselves. Example: 
\par {\s1 \f1\fs18 
\par       #include <stdarg.h>
\par 
\par       void log_message(const char *format, ...)
\par       \{
\par          char buffer[100];
\par          va_list parameters;
\par          
\par          va_start(parameters, format);
\par          uvszprintf(buffer, sizeof(buffer), format, parameters);
\par          va_end(parameters);
\par          
\par          append_buffer_to_logfile(log_name, buffer);
\par          send_buffer_to_other_networked_players(multicast_ip, buffer);
\par          and_also_print_it_on_the_screen(cool_font, buffer);
\par       \}
\par       
\par       void some_other_function(void)
\par       \{
\par          log_message("Hello %s, are you %d years old?\\n", "Dave", 25);
\par       \}\par}
\par Returns the number of characters that would have been written without 
eventual truncation (like with uvsprintf), not including the terminating 
null character. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Configuration routines}Configuration routines\par }
Various parts of Allegro, such as the sound routines and the 
load_joystick_data() function, require some configuration information. This 
data is stored in text files as a collection of `variable=value' lines, 
along with comments that begin with a `#' character and continue to the end 
of the line. The configuration file may optionally be divided into sections, 
which begin with a `[sectionname]' line. Each section has a unique 
namespace, to prevent variable name conflicts, but any variables that aren't 
in a section are considered to belong to all the sections simultaneously. 
\par \par Note that variable and section names cannot contain spaces. 
\par \par By default the configuration data is read from a file called `allegro.cfg', 
which can be located either in the same directory as the program executable, 
or the directory pointed to by the ALLEGRO environment variable. Under Unix, 
it also checks for `~/allegro.cfg', `~/.allegrorc', `/etc/allegro.cfg', and 
`/etc/allegrorc', in that order; under BeOS only the last two are also 
checked. MacOS X also checks in the Contents/Resources directory of the 
application bundle, if any, before doing the checks above. 
\par \par If you don't like this approach, you can specify any filename you like, or 
use a block of binary configuration data provided by your program (which 
could for example be loaded from a datafile). You can also extend the paths 
searched for allegro resources with set_allegro_resource_path(). 
\par \par You can store whatever custom information you like in the config file, along 
with the standard variables that are used by Allegro (see below). Allegro 
comes with a setup directory where you can find configuration programs. The 
standalone setup program is likely to be of interest to final users. It 
allows any user to create an `allegro.cfg' file without the need to touch a 
text editor and enter values by hand. It also provides a few basic tests like 
sound playing for sound card testing. You are welcome to include the setup 
program with your game, either as is or with modified graphics to fit better 
your game. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_config_file}set_config_file(const char *filename);\par }
{\li400 Sets the configuration file to be used by all subsequent config 
functions. (Allegro will not search for this file in other locations 
as it does with allegro.cfg at the time of initialization.) 
\par \par All pointers returned by previous calls to get_config_string() and 
other related functions are invalidated when you call this function! 
You can call this function before install_allegro() to change the 
configuration file, but after set_uformat() if you want to use a text 
encoding format other than the default. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_config_data}set_config_data(const char *data, int length);\par }
{\li400 Specifies a block of data to be used by all subsequent config functions, 
which you have already loaded from disk (eg. as part of some more 
complicated format of your own, or in a grabber datafile). This routine 
makes a copy of the information, so you can safely free the data after 
calling it. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v override_config_file}override_config_file(const char *filename);\par }
{\li400 Specifies a file containing config overrides. These settings will be used 
in addition to the parameters in the main config file, and where a 
variable is present in both files this version will take priority. This 
can be used by application programmers to override some of the config 
settings from their code, while still leaving the main config file free 
for the end user to customise. For example, you could specify a 
particular sample frequency and IBK instrument file, but the user could 
still use an `allegro.cfg' file to specify the port settings and irq 
numbers. 
\par \par The override config file will not only take precedence when reading, but 
will also be used for storing values. When you are done with using the 
override config file, you can call override_config_file with a NULL 
parameter, so config data will be directly read from the current config 
file again. 
\par \par Note: The override file is completely independent from the current 
configuration. You can e.g. call set_config_file, and the override file 
will still be active. Also the flush_config_file function will only affect 
the current config file (which can be changed with set_config_file), never 
the overriding one specified with this function. The modified override 
config is written back to disk whenever you call override_config_file. 
\par \par Example: 
\par {\s1 \f1\fs18 
\par       override_config_file("my.cfg");
\par       /* This will read from my.cfg, and if it doesn't find a
\par        * setting, will read from the current config file instead.
\par        */
\par       language = get_config_string("system", "language", NULL);
\par       /* This will always write to my.cfg, no matter if the
\par        * settings is already present or not.
\par        */
\par       set_config_string("system", "language", "RU");
\par       /* This forces the changed setting to be written back to
\par        * disk. Else it is written back at the next call to
\par        * override_config_file, or when Allegro shuts down.
\par        */
\par       override_config_file(NULL);\par}
\par Note that this function and override_config_data() are mutually exclusive, 
i.e. calling one will cancel the effects of the other. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v override_config_data}override_config_data(const char *data, int length);\par }
{\li400 Version of override_config_file() which uses a block of data that has 
already been read into memory. The length of the block has to be specified 
in bytes. Example: 
\par {\s1 \f1\fs18 
\par       /* Force German as system language, Spanish keyboard map. */
\par       const char *override_data = "[system]\\n"
\par          "language=DE\\n"
\par          "keyboard=ES";
\par       override_config_data(override_data, ustrsize(override_data));\par}
\par Note that this function and override_config_file() are mutually exclusive, 
i.e. calling one will cancel the effects of the other. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v push_config_state}push_config_state();\par }
{\li400 Pushes the current configuration state (filename, variable values, etc). 
onto an internal stack, allowing you to select some other config source 
and later restore the current settings by calling pop_config_state(). 
This function is mostly intended for internal use by other library 
functions, for example when you specify a config filename to the 
save_joystick_data() function, it pushes the config state before 
switching to the file you specified. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v pop_config_state}pop_config_state();\par }
{\li400 Pops a configuration state previously stored by push_config_state(), 
replacing the current config source with it. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v flush_config_file}flush_config_file();\par }
{\li400 Writes the current config file to disk if the contents have changed 
since it was loaded or since the latest call to the function. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v reload_config_texts}reload_config_texts(const char *new_language);\par }
{\li400 Reloads the translated strings returned by get_config_text(). This is 
useful to switch to another language in your program at runtime. If you 
want to modify the `[system]' language configuration variable yourself, or 
you have switched configuration files, you will want to pass NULL to 
just reload whatever language is currently selected. Or you can pass a 
string containing the two letter code of the language you desire to 
switch to, and the function will modify the language variable. After you 
call this function, the previously returned pointers of get_config_text() 
will be invalid. Example: 
\par {\s1 \f1\fs18 
\par       ...
\par       /* The user selects French from a language choice menu. */
\par       reload_config_texts("FR");\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v hook_config_section}hook_config_section(const char *section, int (*intgetter)(const char *name, int def), const char *(*stringgetter)(const char *name, const char *def), void (*stringsetter)(const char *name, const char *value));\par }
{\li400 Takes control of the specified config file section, so that your hook 
functions will be used to manipulate it instead of the normal disk file 
access. If both the getter and setter functions are NULL, a currently 
present hook will be unhooked. Hooked functions have the highest 
priority. If a section is hooked, the hook will always be called, so you 
can also hook a '#' section: even override_config_file() cannot override 
a hooked section. Example: 
\par {\s1 \f1\fs18 
\par       int decode_encrypted_int(const char *name, int def)
\par       \{
\par          ...
\par       \}
\par       
\par       const char *decode_encrypted_string(const char *name, const char *def)
\par       \{
\par          ...
\par       \}
\par       
\par       void encode_plaintext_string(const char *name, const char *value)
\par       \{
\par          ...
\par       \}
\par       
\par       int main(int argc, char *argv[])
\par       \{
\par          ...
\par          /* Make it harder for users to tinker with the high scores. */
\par          hook_config_section("high_scores", decode_encrypted_int,
\par             decode_encrypted_string, encode_plaintext_string);
\par          ...
\par       \} END_OF_MAIN()\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v config_is_hooked}config_is_hooked(const char *section);\par }
{\li400 Returns TRUE if the specified config section has been hooked. Example: 
\par {\s1 \f1\fs18 
\par       if (config_is_hooked("high_scores")) \{
\par          hook_config_section("high_scores, NULL, NULL, NULL);
\par       \}\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b const char *{\xe\v get_config_string}get_config_string(const char *section, const char *name, const char *def);\par }
{\li400 Retrieves a string variable from the current config file. The section name 
may be set to NULL to read variables from the root of the file, or used to 
control which set of parameters (eg. sound or joystick) you are interested 
in reading. Example: 
\par {\s1 \f1\fs18 
\par       const char *lang = get_config_string("system", "language", "EN");
\par }\par \par \par Returns a pointer to the constant string found in the configuration file. 
If the named variable cannot be found, or its entry in the config file is 
empty, the value of `def' is returned. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_config_int}get_config_int(const char *section, const char *name, int def);\par }
{\li400 Reads an integer variable from the current config file. See the comments 
about get_config_string(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_config_hex}get_config_hex(const char *section, const char *name, int def);\par }
{\li400 Reads an integer variable from the current config file, in hexadecimal 
format. See the comments about get_config_string(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b float {\xe\v get_config_float}get_config_float(const char *section, const char *name, float def);\par }
{\li400 Reads a floating point variable from the current config file. See the 
comments about get_config_string(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_config_id}get_config_id(const char *section, const char *name, int def);\par }
{\li400 Reads a 4-letter driver ID variable from the current config file. See the 
comments about get_config_string(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char **{\xe\v get_config_argv}get_config_argv(const char *section, const char *name, int *argc);\par }
{\li400 Reads a token list (words separated by spaces) from the current config 
file. The token list is stored in a temporary buffer that will be clobbered 
by the next call to get_config_argv(), so the data should not be expected 
to persist. 
\par \par Returns an argv style argument list and sets `argc' to the number of 
retrieved tokens. If the variable is not present, returns NULL and sets 
argc to zero. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b const char *{\xe\v get_config_text}get_config_text(const char *msg);\par }
{\li400 This function is primarily intended for use by internal library code, but 
it may perhaps be helpful to application programmers as well. It uses the 
`language.dat' or `XXtext.cfg' files (where XX is a language code) to look 
up a translated version of the parameter in the currently selected 
language. 
\par \par This is basically the same thing as calling get_config_string() with 
`[language]' as the section, `msg' as the variable name, and `msg' as the 
default value, but it contains some special code to handle Unicode format 
conversions. The `msg' parameter is always given in ASCII format, but the 
returned string will be converted into the current text encoding, with 
memory being allocated as required, so you can assume that this pointer 
will persist without having to manually allocate storage space for each 
string. 
\par \par Note that if you are planning on distributing your game on the Unix 
platform there is a special issue with how to deal with the `language.dat' 
file. Read section "Files shared by Allegro" of the chapter "Unix 
specifics" to learn more about this. 
\par \par Returns a suitable translation if one can be found or a copy of the 
parameter if nothing else is available. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_config_string}set_config_string(const char *section, const char *name, const char *val);\par }
{\li400 Writes a string variable to the current config file, replacing any 
existing value it may have, or removes the variable if `val' is NULL. The 
section name may be set to NULL to write the variable to the root of the 
file, or used to control which section the variable is inserted into. The 
altered file will be cached in memory, and not actually written to disk 
until you call allegro_exit(). Note that you can only write to files in 
this way, so the function will have no effect if the current config 
source was specified with set_config_data() rather than set_config_file(). 
\par \par As a special case, variable or section names that begin with a '#' 
character are treated specially and will not be read from or written to 
the disk. Addon packages can use this to store version info or other 
status information into the config module, from where it can be read with 
the get_config_string() function. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_config_int}set_config_int(const char *section, const char *name, int val);\par }
{\li400 Writes an integer variable to the current config file. See the comments 
about set_config_string(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_config_hex}set_config_hex(const char *section, const char *name, int val);\par }
{\li400 Writes an integer variable to the current config file, in hexadecimal 
format. See the comments about set_config_string(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_config_float}set_config_float(const char *section, const char *name, float val);\par }
{\li400 Writes a floating point variable to the current config file. See the 
comments about set_config_string(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_config_id}set_config_id(const char *section, const char *name, int val);\par }
{\li400 Writes a 4-letter driver ID variable to the current config file. See the 
comments about set_config_string(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v list_config_entries}list_config_entries(const char *section, const char ***names);\par }
{\li400 This function can be used to get a list of all entries in the given config 
section. The names parameter is a pointer to an array of strings. If it 
points to a NULL pointer, the list will be allocated, else it will be 
re-allocated. You should free the list again with free_config_entries if you 
don't need it anymore, or you can pass it again to list_config_entries and 
the memory will be re-used. See the following example for how you can use it, 
it will print out the complete contents of the current configuration: 
\par {\s1 \f1\fs18 
\par    int i, n;
\par    char const **sections = NULL;
\par    char const **entries = NULL;
\par 
\par    /* List all entries not in any section. */
\par    n = list_config_entries(NULL, &entries);
\par    for (i = 0; i 
\par       printf(" %s=\\"%s\\"\\n", entries[i], get_config_string(
\par              NULL, entries[i], "-"));
\par 
\par    /* List all sections (and entries in them). */
\par    n = list_config_sections(&sections);
\par    /* loop through all section names */
\par    for (i = 0; i 
\par    \{
\par       int j, m;
\par       printf("%s\\n", sections[i]);
\par       m = list_config_entries(sections[i], &entries);
\par       /* loop through all entries in the section */
\par       for (j = 0; j 
\par       \{
\par           printf(" %s=\\"%s\\"\\n", entries[j], get_config_string(
\par              sections[i], entries[j], "-"));
\par       \}
\par    \}
\par    /* It is enough to free the arrays once at the end. */
\par    free_config_entries(&sections);
\par    free_config_entries(&entries);\par}
\par Returns the number of valid strings in the names array. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v list_config_sections}list_config_sections(const char ***names);\par }
{\li400 The names parameter is a pointer to an array of strings. If it points to a 
NULL pointer, the list will be allocated, else it will be re-allocated. After 
the function returns, it will contain the names of all sections in the 
current configuration. Use free_config_entries to free the allocated memory 
again. See list_config_entries for more information and an example how to use 
it. 
\par \par Returns the number of valid strings in the names array. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v free_config_entries}free_config_entries(const char ***names);\par }
{\li400 \par \par Once you are done with the string arrays filled in by list_config_entries and 
list_config_sections, you can free them again with this function. The passed 
array pointer will be set to NULL, and you directly can pass the same pointer 
again to list_config_entries or list_config_sections later - but you also 
could pass them again without freeing first, since the memory is re-allocated 
when the pointer is not NULL. 
\par \par See list_config_entries for an example of how to use it. 
\par}\par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v Standard config variables}
Allegro uses these standard variables from the configuration file: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 \sa80 [system]\par \pard \li400 
Section containing general purpose variables: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 system = x\par \pard \li800 
Specifies which system driver to use. This is currently only useful on 
Linux, for choosing between the X-Windows ("XWIN") or console ("LNXC") 
modes. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 keyboard = x\par \pard \li800 
Specifies which keyboard layout to use. The parameter is the name of a 
keyboard mapping file produced by the keyconf utility, and can either be 
a fully qualified file path or a base name like `us' or `uk'. If the 
latter, Allegro will look first for a separate config file with that name 
(eg. `uk.cfg') and then for an object with that name in the `keyboard.dat' 
file (eg. `UK_CFG'). The config file or `keyboard.dat' file can be stored 
in the same directory as the program, or in the location pointed to by 
the ALLEGRO environment variable. Look in the `keyboard.dat' file to see 
what mappings are currently available. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 language = x\par \pard \li800 
Specifies which language file to use for error messages and other bits of 
system text. The parameter is the name of a translation file, and can 
either be a fully qualified file path or a base name like `en' or `es'. If 
the latter, Allegro will look first for a separate config file with a 
name in the form `entext.cfg', and then for an object with that name in 
the `language.dat' file (eg. `ENTEXT_CFG'). The config file or 
`language.dat' file can be stored in the same directory as the program, or 
in the location pointed to by the ALLEGRO environment variable. 
\par \par Look in the `language.dat' file to see which mappings are currently 
available. If there is none for your language, you can create it using the 
English one as model, and even send it to the Allegro development team to 
include it in future releases. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 disable_screensaver = x\par \pard \li800 
Specifies whether to disable the screensaver: 0 to never disable it, 1 to 
disable it in fullscreen mode only and 2 to always disable it. Default is 1. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 menu_opening_delay = x\par \pard \li800 
Sets how long the menus take to auto-open. The time is given in 
milliseconds (default is `300'). Specifying `-1' will disable the 
auto-opening feature. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 XInitThreads = x\par \pard \li800 
If this is set to 0, the X11 port will not call XInitThreads. This can have 
slight performance advantages and was required on some broken X11 servers, 
but it makes Allegro incompatible with other X11 libraries like Mesa. 
\par}\pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 \sa80 [graphics]\par \pard \li400 
Section containing graphics configuration information, using the 
variables: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 gfx_card = x\par \pard \li800 
Specifies which graphics driver to use when the program requests 
GFX_AUTODETECT. Multiple possible drivers can be suggested with extra 
lines in the form `gfx_card1 = x', `gfx_card2 = x', etc, or you can 
specify different drivers for each mode and color depth with variables in 
the form `gfx_card_24bpp = x', `gfx_card_640x480x16 = x', etc. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 gfx_cardw = x\par \pard \li800 
Specifies which graphics driver to use when the program requests 
GFX_AUTODETECT_WINDOWED. This variable functions exactly like 
gfx_card in all other respects. If it is not set, Allegro will look 
for the gfx_card variable. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 disable_vsync = x\par \pard \li800 
Specifies whether to disable synchronization with the vertical blank when 
page-flipping (yes or no). Disabling synchronization may increase the 
frame rate on slow systems, at the expense of introducing flicker on fast 
systems. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 vbeaf_driver = x\par \pard \li800 
DOS and Linux only: specifies where to look for the VBE/AF driver 
(vbeaf.drv). If this variable is not set, Allegro will look in the same 
directory as the program, and then fall back on the standard locations 
(`c:\\' for DOS, `/usr/local/lib', `/usr/lib', `/lib', and `/' for Linux, or 
the directory specified with the VBEAF_PATH environment variable). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 framebuffer = x\par \pard \li800 
Linux only: specifies what device file to use for the fbcon driver. If 
this variable is not set, Allegro checks the FRAMEBUFFER environment 
variable, and then defaults to `/dev/fb0'. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 force_centering = x\par \pard \li800 
Unix/X11 only: specifies whether to force window centering in fullscreen 
mode when the XWFS driver is used (yes or no). Enabling this setting may 
cause some artifacts to appear on KDE desktops. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 disable_direct_updating = x\par \pard \li800 
Windows only: specifies whether to disable direct updating when the 
GFX_DIRECTX_WIN driver is used in color conversion mode (yes or no). 
Direct updating can cause artifacts to be left on the desktop when the 
window is moved or minimized; disabling it results in a significant 
performance loss. 
\par}\pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 \sa80 [mouse]\par \pard \li400 
Section containing mouse configuration information, using the variables: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 mouse = x\par \pard \li800 
Mouse driver type. Available DOS drivers are: 
\par {\s1 \f1\fs18 
\par       MICK - mickey mode driver (normally the best)
\par       I33  - int 0x33 callback driver
\par       POLL - timer polling (for use under NT)
\par }\pard \li800 \par Linux console mouse drivers are: 
\par {\s1 \f1\fs18 
\par       MS   - Microsoft serial mouse
\par       IMS  - Microsoft serial mouse with Intellimouse extension
\par       LPS2 - PS2 mouse
\par       LIPS - PS2 mouse with Intellimouse extension
\par       GPMD - GPM repeater data (Mouse Systems protocol)
\par       EV   - Event interfaces (EVDEV)\par}
\pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 num_buttons = x\par \pard \li800 
Sets the number of mouse buttons viewed by Allegro. You don't normally 
need to set this variable because Allegro will autodetect it. You can only 
use it to restrict the set of actual mouse buttons to zero or positive 
values, negative values will be ignored. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 emulate_three = x\par \pard \li800 
Sets whether to emulate a third mouse button by detecting chords of the 
left and right buttons (yes or no). Defaults to no. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 mouse_device = x\par \pard \li800 
Linux only: specifies the name of the mouse device file (eg. 
`/dev/mouse'). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 ev_absolute = x\par \pard \li800 
Linux only: specifies the mode for the default EV input: 
0 - relative mode: pointer position changes if the input moves, 
1 - absolute mode: pointer position is the input position. 
If unspecified, the mode is relative. 
If the device supports several tools (such as a graphic tablet), the 
default input is the mouse. If the device has only one tool (e.g. a 
normal mouse) the default input is this tool. All additional tools 
work in absolute mode. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 ev_min_x = x\par \pard \li800 
ev_max_x = x\par 
ev_min_y = x\par 
ev_max_y = x\par 
ev_min_z = x\par 
ev_max_z = x\par 
Linux only: for absolute EV inputs, minimum and maximum value. By default 
this information is autodetected.  If you want to use only part of a 
tablet, you need to set the entries for X and Y axis by hand. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 ev_abs_to_rel_x = x\par \pard \li800 
ev_abs_to_rel_y = x\par 
ev_abs_to_rel_z = x\par 
Linux only: scaling factor for tablet mouse speed.  Defaults to 1. 
This is used only when the input sends absolute events (tablet, joystick, 
etc.) and the cursor should behave like a mouse. 
If you are using a mouse on a tablet, you need to set these entries 
for X and Y axis (try numbers between 1 and 40). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 mouse_accel_factor = x\par \pard \li800 
Windows only: specifies the mouse acceleration factor. Defaults to 1. 
Set it to 0 in order to disable mouse acceleration. 2 accelerates twice 
as much as 1. 
\par}\pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 \sa80 [sound]\par \pard \li400 
Section containing sound configuration information, using the variables: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 digi_card = x\par \pard \li800 
Sets the driver to use for playing digital samples. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 midi_card = x\par \pard \li800 
Sets the driver to use for MIDI music. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 digi_input_card = x\par \pard \li800 
Sets the driver to use for digital sample input. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 midi_input_card = x\par \pard \li800 
Sets the driver to use for MIDI data input. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 digi_voices = x\par \pard \li800 
Specifies the minimum number of voices to reserve for use by the digital 
sound driver. How many are possible depends on the driver. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 midi_voices = x\par \pard \li800 
Specifies the minimum number of voices to reserve for use by the MIDI 
sound driver. How many are possible depends on the driver. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 digi_volume = x\par \pard \li800 
Sets the volume for digital sample playback, from 0 to 255. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 midi_volume = x\par \pard \li800 
Sets the volume for midi music playback, from 0 to 255. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 quality = x\par \pard \li800 
Controls the sound quality vs. performance tradeoff for the sample mixing 
code. This can be set to any of the values:\par {\s1 \f1\fs18 
\par       0 - fast mixing of 8-bit data into 16-bit buffers
\par       1 - true 16-bit mixing (requires a 16-bit stereo sound card)
\par       2 - interpolated 16-bit mixing\par}
\pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 flip_pan = x\par \pard \li800 
Toggling this between 0 and 1 reverses the left/right panning of samples, 
which might be needed because some SB cards get the stereo image the wrong 
way round. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 sound_freq = x\par \pard \li800 
DOS, Unix and BeOS: sets the sample frequency. With the SB driver, 
possible rates are 11906 (any), 16129 (any), 22727 (SB 2.0 and above), 
and 45454 (only on SB 2.0 or SB16, not the stereo SB Pro driver). On the 
ESS Audiodrive, possible rates are 11363, 17046, 22729, or 44194. On the 
Ensoniq Soundscape, possible rates are 11025, 16000, 22050, or 48000. On 
the Windows Sound System, possible rates are 11025, 22050, 44100, or 
48000. Don't worry if you set some other number by mistake: Allegro will 
automatically round it to the closest supported frequency. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 sound_bits = x\par \pard \li800 
Unix and BeOS: sets the preferred number of bits (8 or 16). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 sound_stereo = x\par \pard \li800 
Unix and BeOS: selects mono or stereo output (0 or 1). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 sound_port = x\par \pard \li800 
DOS only: sets the sound card port address (this is usually 220). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 sound_dma = x\par \pard \li800 
DOS only: sets the sound card DMA channel (this is usually 1). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 sound_irq = x\par \pard \li800 
DOS only: sets the sound card IRQ number (this is usually 7). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 fm_port = x\par \pard \li800 
DOS only: sets the port address of the OPL synth (this is usually 388). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 mpu_port = x\par \pard \li800 
DOS only: sets the port address of the MPU-401 MIDI interface (this is 
usually 330). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 mpu_irq = x\par \pard \li800 
DOS only: sets the IRQ for the MPU-401 (this is usually the same as 
sound_irq). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 ibk_file = x\par \pard \li800 
DOS only: specifies the name of a .IBK file which will be used to replace 
the standard Adlib patch set. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 ibk_drum_file = x\par \pard \li800 
DOS only: specifies the name of a .IBK file which will be used to replace 
the standard set of Adlib percussion patches. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 oss_driver = x\par \pard \li800 
Unix only: sets the OSS device driver name. Usually `/dev/dsp' or 
`/dev/audio', but could be a particular device (e.g. `/dev/dsp2'). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 oss_numfrags = x\par \pard \li800 
oss_fragsize = x\par 
Unix only: sets number of OSS driver fragments (buffers) and size of each 
buffer in samples. Buffers are filled with data in the interrupts where 
interval between subsequent interrupts is not less than 10 ms. If 
hardware can play all information from buffers faster than 10 ms, then 
there will be clicks, when hardware have played all data and library has 
not prepared new data yet. On the other hand, if it takes too long for 
device driver to play data from all buffers, then there will be delays 
between action which triggers sound and sound itself. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 oss_midi_driver = x\par \pard \li800 
Unix only: sets the OSS MIDI device name. Usually `/dev/sequencer'. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 oss_mixer_driver = x\par \pard \li800 
Unix only: sets the OSS mixer device name. Usually `/dev/mixer'. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 esd_server = x\par \pard \li800 
Unix only: where to find the ESD (Enlightened Sound Daemon) server. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 alsa_card = x\par \pard \li800 
alsa_pcmdevice = x\par 
Unix only: card number and PCM device for the ALSA 0.5 sound driver. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 alsa_device = x\par \pard \li800 
Unix only: device name for the ALSA 0.9 sound driver. The format is 
<driver>[:<card>,<device>], for example: `hw:0,1'. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 alsa_mixer_device = x\par \pard \li800 
Unix only: mixer device name for the ALSA 0.9 sound driver. The 
default is "default". 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 alsa_mixer_elem = x\par \pard \li800 
Unix only: mixer element name for the ALSA 0.9 driver. The default 
is PCM. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 alsa_numfrags = x\par \pard \li800 
Unix only: number of ALSA driver fragments (buffers). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 alsa_fragsize = x\par \pard \li800 
Unix only: size of each ALSA fragment, in samples. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 alsa_rawmidi_card = x\par \pard \li800 
Unix only: card number and device for the ALSA 0.5 midi driver. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 alsa_rawmidi_device = x\par \pard \li800 
Unix only: device for the ALSA 0.5 midi driver or device name for 
the ALSA 0.9 midi driver (see alsa_device for the format). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 jack_client_name = x\par \pard \li800 
Sets the name with which Allegro should identify itself to the Jack 
audio server. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 jack_buffer_size = x\par \pard \li800 
Forces a buffer size for the transfer buffer from Allegro's mixer 
to Jack. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 be_midi_quality = x\par \pard \li800 
BeOS only: system MIDI synthesizer instruments quality. 0 uses low 
quality 8-bit 11 kHz samples, 1 uses 16-bit 22 kHz samples. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 be_midi_freq = x\par \pard \li800 
BeOS only: MIDI sample mixing frequency in Hz. Can be 11025, 22050 or 
44100. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 be_midi_interpolation = x\par \pard \li800 
BeOS only: specifies the MIDI samples interpolation method. 0 doesn't 
interpolate, it's fast but has the worst quality; 1 does a fast 
interpolation with better performances, but it's a bit slower than the 
previous method; 2 does a linear interpolation between samples, it is the 
slowest method but gives the best performances. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 be_midi_reverb = x\par \pard \li800 
BeOS only: reverberation intensity, from 0 to 5. 0 disables it, 5 is the 
strongest one. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 ca_midi_quality = x\par \pard \li800 
MacOS X only: CoreAudio MIDI synthesizer rendering quality, from 0 to 127. 
Higher qualities sound better but increase the CPU work load. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 ca_midi_reverb = x\par \pard \li800 
MacOS X only: CoreAudio MIDI synthesizer reverberation intensity, from 0 
to 5. 0 equals to a small room (low reverb), 5 to a plate (high reverb). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 patches = x\par \pard \li800 
Specifies where to find the sample set for the DIGMID driver. This can 
either be a Gravis style directory containing a collection of .pat files 
and a `default.cfg' index, or an Allegro datafile produced by the pat2dat 
utility. If this variable is not set, Allegro will look either for a 
`default.cfg' or `patches.dat' file in the same directory as the program, 
the directory pointed to by the ALLEGRO environment variable, and the 
standard GUS directory pointed to by the ULTRASND environment variable. 
\par}\pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 \sa80 [midimap]\par \pard \li400 
If you are using the SB MIDI output or MPU-401 drivers with an external 
synthesiser that is not General MIDI compatible, you can use the midimap 
section of the config file to specify a patch mapping table for 
converting GM patch numbers into whatever bank and program change 
messages will select the appropriate sound on your synth. This is a real 
piece of self-indulgence. I have a Yamaha TG500, which has some great 
sounds but no GM patch set, and I just had to make it work somehow... 
\par \par This section consists of a set of lines in the form: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 p<n> = bank0 bank1 prog pitch\par \pard \li800 
With this statement, n is the GM program change number (1-128), bank0 and 
bank1 are the two bank change messages to send to your synth (on 
controllers #0 and #32), prog is the program change message to send to 
your synth, and pitch is the number of semitones to shift everything that 
is played with that sound. Setting the bank change numbers to -1 will 
prevent them from being sent. 
\par \par For example, the line: 
\par {\s1 \f1\fs18 
\par       p36 = 0 34 9 12
\par }\pard \li800 \par specifies that whenever GM program 36 (which happens to be a fretless 
bass) is selected, Allegro should send a bank change message #0 with a 
parameter of 0, a bank change message #32 with a parameter of 34, a 
program change with a parameter of 9, and then should shift everything up 
by an octave. 
\par}\pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 \sa80 [joystick]\par \pard \li400 
Section containing joystick configuration information, using the 
variables: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 joytype = x\par \pard \li800 
Specifies which joystick driver to use when the program requests 
JOY_TYPE_AUTODETECT. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 joystick_device = x\par \pard \li800 
BeOS and Linux only: specifies the name of the joystick device to be used 
(as reported in the system joystick preferences under BeOS). The first 
device found is used by default. If you want to specify the device for 
each joystick, use variables of the form joystick_device_n, where n is 
the joystick number. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 \sa80 throttle_axis = x\par \pard \li800 
Linux only: sets the axis number the throttle is located at. This 
variable will be used for every detected joystick. If you want to specify 
the axis number for each joystick individually, use variables of the form 
throttle_axis_n, where n is the joystick number. 
\par}\par}\pard \li0 {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Mouse routines}Mouse routines\par }
Allegro provides functions for reading the mouse state and displaying a mouse 
cursor on-screen. You can read the absolute position of the mouse and the 
state of the mouse buttons from global variables. Additionally, you can read 
the mouse position difference as mouse mickeys, which is the number of pixels 
the cursor moved since the last time this information was read. 
\par \par Allegro offers three ways to display the mouse cursor: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Standard Allegro cursor\par \pard \li400 
Allegro is responsible for drawing the mouse cursor from a timer. Use 
set_mouse_sprite() and show_mouse() to define your own cursor and display 
it on the screen. 
You need to call scare_mouse()/unscare_mouse() to hide the mouse cursor 
whenever you draw to the screen. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Custom operating system cursor (hardware cursor)\par \pard \li400 
Allegro will let the operating system draw the mouse cursor. Use 
set_mouse_sprite() and show_mouse() (or show_os_cursor) to define your 
own cursor and display it on the screen. Not all graphics drivers are 
capable of this and some may only be able to display cursors up to a 
certain size. Allegro will fall back on its own cursor drawing if it 
cannot let the OS handle this. On some platforms, the hardware cursor 
is incompatible with get_mouse_mickeys() and it is therefor disabled by 
default. In such cases you need to call enable_hardware_cursor() to 
enable it explicitly. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Default operating system cursor\par \pard \li400 
Allegro will not draw its own cursor, but use the operating system default 
cursor. You can use the select_mouse_cursor() function to select the cursor 
shape to display. As with custom operating system cursors, you need to call 
enable_hardware_cursor() before you can use this. Or you can use the 
low level show_os_cursor() function. 
\par}\par Not all drivers will support all functionality. See the platform specific 
information for more details. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v install_mouse}install_mouse();\par }
{\li400 Installs the Allegro mouse handler. You must do this before using any 
other mouse functions. 
\par \par Returns -1 on failure, zero if the mouse handler is already installed (in 
which case this function does nothing) and the number of buttons on the 
mouse if the mouse handler has successfully been installed (ie. this is 
the first time a handler is installed or you have removed the previous 
one). 
\par \par Note that the number of mouse buttons returned by this function is more 
an indication than a physical reality. With most devices there is no way 
of telling how many buttons there are, and any user can override the 
number of mouse buttons returned by this function with a custom 
configuration file and the variable num_buttons. Even if this value is 
overridden by the user, the global mouse variables will still report 
whatever the hardware is sending. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v remove_mouse}remove_mouse();\par }
{\li400 Removes the mouse handler. You don't normally need to bother calling 
this, because allegro_exit() will do it for you. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v poll_mouse}poll_mouse();\par }
{\li400 Wherever possible, Allegro will read the mouse input asynchronously (ie. 
from inside an interrupt handler), but on some platforms that may not be 
possible, in which case you must call this routine at regular intervals 
to update the mouse state variables. To help you test your mouse polling 
code even if you are programming on a platform that doesn't require it, 
after the first time that you call this function Allegro will switch into 
polling mode, so from that point onwards you will have to call this 
routine in order to get any mouse input at all, regardless of whether the 
current driver actually needs to be polled or not. 
\par \par Returns zero on success, or a negative number on failure (ie. no mouse 
driver installed). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v mouse_needs_poll}mouse_needs_poll();\par }
{\li400 Returns TRUE if the current mouse driver is operating in polling mode. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v enable_hardware_cursor}enable_hardware_cursor(void);\par }
{\li400 After calling this function, Allegro will let the operating system draw the 
mouse cursor instead of doing it itself. This is not possible with all 
graphics drivers though: you'll need to check the gfx_capabilities flags 
after calling show_mouse() to see if this works. On some platforms, enabling 
the hardware cursor causes get_mouse_mickeys() to return only a limited 
range of values, so you should not call this function if you need mouse 
mickeys. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v disable_hardware_cursor}disable_hardware_cursor(void);\par }
{\li400 After calling this function, Allegro will be responsible for drawing the 
mouse cursor rather than the operating system. On some platforms calling 
enable_hardware_cursor() makes the return values of get_mouse_mickeys() 
unreliable. After calling this function, get_mouse_mickeys() returns 
reliable results again. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v select_mouse_cursor}select_mouse_cursor(int cursor);\par }
{\li400 This function allows you to use the operating system's native mouse 
cursors rather than some custom cursor. You will need to enable this 
functionality by calling enable_hardware_cursor() beforehand. If the 
operating system does not support this functionality, or if it has 
not been enabled, then Allegro will substitute its own cursor images. 
You can change these substitute images using set_mouse_cursor_bitmap(). 
\par \par Note that the effects of this function are not apparent until show_mouse() 
is called. 
\par \par To know whether the operating system's native cursor is being used, 
or if Allegro has made a substitution, you can check the GFX_SYSTEM_CURSOR 
flag in gfx_capabilities after calling show_mouse(). 
\par \par The cursor argument selects the type of cursor to be displayed: 
\par \par {\b MOUSE_CURSOR_NONE\par}
Selects an invisible mouse cursor. In that sense, it is similar to calling 
show_mouse(NULL); 
\par \par {\b MOUSE_CURSOR_ALLEGRO\par}
Selects the custom Allegro cursor, i.e. the one that you set with 
set_mouse_sprite(). 
\par \par {\b MOUSE_CURSOR_ARROW\par}
The operating system default arrow cursor. 
\par \par {\b MOUSE_CURSOR_BUSY\par}
The operating system default `busy' cursor (hourglass). 
\par \par {\b MOUSE_CURSOR_QUESTION\par}
The operating system default `question' cursor (arrow with question mark). 
\par \par {\b MOUSE_CURSOR_EDIT\par}
The operating system default `edit' cursor (vertical bar). 
\par \par Example: 
\par {\s1 \f1\fs18 
\par    /* initialize mouse sub-system */
\par    install_mouse();
\par    enable_hardware_cursor();
\par    
\par    /* Set busy pointer */
\par    select_mouse_cursor(MOUSE_CURSOR_BUSY);
\par    show_mouse(screen);
\par    
\par    /* Initialize stuff */
\par    ...
\par    
\par    /* Set normal arrow pointer */
\par    select_mouse_cursor(MOUSE_CURSOR_ARROW);
\par \par}}\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_mouse_cursor_bitmap}set_mouse_cursor_bitmap(int cursor, BITMAP *bmp);\par }
{\li400 This function changes the cursor image Allegro uses if 
select_mouse_cursor() is called but no native operating system cursor 
can be used, e.g. because you did not call enable_hardware_cursor(). 
\par \par The cursor argument can be one of:\par 
{\b MOUSE_CURSOR_ALLEGRO\par}
{\b MOUSE_CURSOR_ARROW\par}
{\b MOUSE_CURSOR_BUSY\par}
{\b MOUSE_CURSOR_QUESTION\par}
{\b MOUSE_CURSOR_EDIT\par}
\par \par but {\i not\par}\par  MOUSE_CURSOR_NONE. 
\par \par The bmp argument can either point to a valid bitmap or it can be NULL. 
Passing a bitmap makes Allegro use that image in place of its own 
default substitution (should the operating system's native cursor 
be unavailable). The bitmap must remain available for the duration 
in which it could be used. Passing NULL lets Allegro revert to its 
default substitutions. 
\par \par The effect of this function will not be apparent until show_mouse() is 
called. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 extern volatile int {\xe\v mouse_x}mouse_x;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 extern volatile int {\xe\v mouse_y}mouse_y;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 extern volatile int {\xe\v mouse_z}mouse_z;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 extern volatile int {\xe\v mouse_w}mouse_w;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 extern volatile int {\xe\v mouse_b}mouse_b;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 extern volatile int {\xe\v mouse_pos}mouse_pos;\par }
{\li400 Global variables containing the current mouse position and button state. 
Wherever possible these values will be updated asynchronously, but if 
mouse_needs_poll() returns TRUE, you must manually call poll_mouse() to 
update them with the current input state. The `mouse_x' and `mouse_y' 
positions are integers ranging from zero to the bottom right corner of 
the screen. The `mouse_z' and `mouse_w' variables hold the current vertical 
and horizontal wheel position, when using an input driver that supports 
wheel mice. The `mouse_b' variable is a bitfield indicating the state of 
each button: bit 0 is the left button,  bit 1 the right, and bit 2 the 
middle button. Additional non standard mouse buttons might be available 
as higher bits in this variable. Usage example: 
\par {\s1 \f1\fs18 
\par       if (mouse_b & 1)
\par          printf("Left button is pressed\\n");
\par 
\par       if (!(mouse_b & 2))
\par          printf("Right button is not pressed\\n");
\par }\par The `mouse_pos' variable has the current X coordinate in the upper 16 bits 
and  the Y in the lower 16 bits. This may be useful in tight polling loops 
where a mouse interrupt could occur between your reading of the two 
separate variables, since you can copy this value into a local variable 
with a single instruction and then split it up at your leisure. Example: 
\par {\s1 \f1\fs18 
\par    int pos, x, y;
\par    
\par    pos = mouse_pos;
\par    x = pos >> 16;
\par    y = pos & 0x0000ffff;
\par \par}}\par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 extern BITMAP *{\xe\v mouse_sprite}mouse_sprite;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 extern int {\xe\v mouse_x_focus}mouse_x_focus;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 extern int {\xe\v mouse_y_focus}mouse_y_focus;\par }
{\li400 Global variables containing the current mouse sprite and the focus 
point.  These are read-only, and only to be modified using the 
set_mouse_sprite() and set_mouse_sprite_focus() functions. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v show_mouse}show_mouse(BITMAP *bmp);\par }
{\li400 Tells Allegro to display a mouse pointer on the screen. This will only 
work if the timer module has been installed. The mouse pointer will be 
drawn onto the specified bitmap, which should normally be `screen' (see 
later for information about bitmaps). To hide the mouse pointer, call 
show_mouse(NULL). 
\par \par Warning: if you draw anything onto the screen while the pointer is 
visible, a mouse movement interrupt could occur in the middle of your 
drawing operation. If this happens the mouse buffering and graphics drawing 
code will get confused and will leave 'mouse droppings' all over the 
screen. To prevent this, you must make sure you turn off the mouse 
pointer whenever you draw onto the screen. This is not needed if you are 
using a hardware cursor. 
\par \par Note: you must not be showing a mouse pointer on a bitmap at the time that 
the bitmap is destroyed with destroy_bitmap(), e.g. call show_mouse(NULL); 
before destroying the bitmap. This does not apply to `screen' since you 
never destroy `screen' with destroy_bitmap(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v scare_mouse}scare_mouse();\par }
{\li400 Helper for hiding the mouse pointer prior to a drawing operation. This 
will temporarily get rid of the pointer, but only if that is really 
required (ie. the mouse is visible, and is displayed on the physical 
screen rather than some other memory surface, and it is not a hardware 
or OS cursor). The previous mouse state is stored for subsequent calls to 
unscare_mouse(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v scare_mouse_area}scare_mouse_area(int x, int y, int w, int h);\par }
{\li400 Like scare_mouse(), but will only hide the cursor if it is inside the 
specified rectangle. Otherwise the cursor will simply be frozen in place 
until you call unscare_mouse(), so it cannot interfere with your drawing. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v unscare_mouse}unscare_mouse();\par }
{\li400 Undoes the effect of a previous call to scare_mouse() or 
scare_mouse_area(), restoring the original pointer state. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v show_os_cursor}show_os_cursor(int cursor);\par }
{\li400 In case you do not need Allegro's mouse cursor API, which automatically 
emulates a cursor in software if no other cursor is available, you can 
use this low level function to try to display or hide the system cursor 
directly. The cursor parameter takes the same values as 
select_mouse_cursor. This function is very similar to calling 
enable_hardware_cursor, select_mouse_cursor and show_mouse, but will 
not try to do anything if no system cursor is available. 
\par \par The most common use for this function is to just call it once at the 
beginning of the program to tell it to display the system cursor inside 
the Allegro window. The return value can be used to see if this 
succeeded or not. On some systems (e.g. DirectX fullscreen) this is not 
supported and the function will always fail, and in other cases only 
some of the cursors will work, or in the case of MOUSE_CURSOR_ALLEGRO, 
only certain bitmap sizes may be supported. 
\par \par You never should use show_os_cursor together with the function 
show_mouse and other functions affecting it (select_mouse_cursor, 
enable_hardware_cursor, disable_hardware_cursor, scare_mouse, 
unscare_mouse). They implement the standard high level mouse API, and 
don't work together with this low level function. 
\par \par Returns 0 if a system cursor is being displayed after the function 
returns, or -1 otherwise. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern volatile int {\xe\v freeze_mouse_flag}freeze_mouse_flag;\par }
{\li400 If this flag is set, the mouse pointer won't be redrawn when the mouse 
moves. This can avoid the need to hide the pointer every time you draw to 
the screen, as long as you make sure your drawing doesn't overlap with 
the current pointer position. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v position_mouse}position_mouse(int x, int y);\par }
{\li400 Moves the mouse to the specified screen position. It is safe to call even 
when a mouse pointer is being displayed. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v position_mouse_z}position_mouse_z(int z);\par }
{\li400 Sets the mouse wheel position variable to the specified value. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v position_mouse_w}position_mouse_w(int w);\par }
{\li400 Sets the horizontal mouse wheel position to the specified value. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_mouse_range}set_mouse_range(int x1, int y1, int x2, int y2);\par }
{\li400 Sets the area of the screen within which the mouse can move. Pass the top 
left corner and the bottom right corner (inclusive). If you don't call 
this function the range defaults to (0, 0, SCREEN_W-1, SCREEN_H-1). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_mouse_speed}set_mouse_speed(int xspeed, int yspeed);\par }
{\li400 Sets the mouse speed. Larger values of xspeed and yspeed represent slower 
mouse movement: the default for both is 2. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_mouse_sprite}set_mouse_sprite(BITMAP *sprite);\par }
{\li400 You don't like Allegro's mouse pointer? No problem. Use this function to 
supply an alternative of your own. If you change the pointer and then want 
to get Allegro's lovely arrow back again, call set_mouse_sprite(NULL). 
\par \par As a bonus, set_mouse_sprite(NULL) uses the current palette in choosing 
colors for the arrow. So if your arrow mouse sprite looks ugly after 
changing the palette, call set_mouse_sprite(NULL). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_mouse_sprite_focus}set_mouse_sprite_focus(int x, int y);\par }
{\li400 The mouse focus is the bit of the pointer that represents the actual 
mouse position, ie. the (mouse_x, mouse_y) position. By default this is 
the top left corner of the arrow, but if you are using a different mouse 
pointer you might need to alter it. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_mouse_mickeys}get_mouse_mickeys(int *mickeyx, int *mickeyy);\par }
{\li400 Measures how far the mouse has moved since the last call to this 
function. The values of mickeyx and mickeyy will become negative if the 
mouse is moved left or up, respectively. The mouse will continue to 
generate movement mickeys even when it reaches the edge of the screen, so 
this form of input can be useful for games that require an infinite range 
of mouse movement. 
\par \par Note that the infinite movement may not work in windowed mode, since under 
some platforms the mouse would leave the window, and may not work at all 
if the hardware cursor is in use. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern void (*{\xe\v mouse_callback}mouse_callback)(int flags);\par }
{\li400 Called by the interrupt handler whenever the mouse moves or one of the 
buttons changes state. This function must be in locked memory, and must 
execute _very_ quickly! It is passed the event flags that triggered the 
call, which is a bitmask containing any of the values MOUSE_FLAG_MOVE, 
MOUSE_FLAG_LEFT_DOWN, MOUSE_FLAG_LEFT_UP, MOUSE_FLAG_RIGHT_DOWN, 
MOUSE_FLAG_RIGHT_UP, MOUSE_FLAG_MIDDLE_DOWN, MOUSE_FLAG_MIDDLE_UP, and 
MOUSE_FLAG_MOVE_Z. Note that even if the mouse has more than three buttons, 
only the first three can be trapped using a callback. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Timer routines}Timer routines\par }
Allegro can set up several virtual timer functions, all going at different 
speeds. 
\par \par Under DOS it will constantly reprogram the clock to make sure they are all 
called at the correct times. Because they alter the low level timer chip 
settings, these routines should not be used together with other DOS timer 
functions like the DJGPP uclock() routine. Moreover, the FPU state is not 
preserved across Allegro interrupts so you ought not to use floating point 
or MMX code inside timer interrupt handlers. 
\par \par Under other platforms, they are usually implemented using threads, which run 
parallel to the main thread. Therefore timer callbacks on such platforms 
will not block the main thread when called, so you may need to use 
appropriate synchronisation devices (eg. mutexes, semaphores, etc.) when 
accessing data that is shared by a callback and the main thread. (Currently 
Allegro does not provide such devices.) 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v install_timer}install_timer();\par }
{\li400 Installs the Allegro timer interrupt handler. You must do this before 
installing any user timer routines, and also before displaying a mouse 
pointer, playing FLI animations or MIDI music, and using any of the GUI 
routines. 
\par \par Returns zero on success, or a negative number on failure (but you may 
decide not to check the return value as this function is very unlikely to 
fail). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v remove_timer}remove_timer();\par }
{\li400 Removes the Allegro timer handler (and, under DOS, passes control of the 
clock back to the operating system). You don't normally need to bother 
calling this, because allegro_exit() will do it for you. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v install_int}install_int(void (*proc)(), int speed);\par }
{\li400 Installs a user timer handler, with the speed given as the number of 
milliseconds between ticks. This is the same thing as 
install_int_ex(proc, MSEC_TO_TIMER(speed)). If you call this routine 
without having first installed the timer module, install_timer() will be 
called automatically. Calling again this routine with the same timer 
handler as parameter allows you to adjust its speed. 
\par \par Returns zero on success, or a negative number if there is no room to add 
a new user timer. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v install_int_ex}install_int_ex(void (*proc)(), int speed);\par }
{\li400 Adds a function to the list of user timer handlers or, if it is already 
installed, retroactively adjusts its speed (i.e makes as though the speed 
change occurred precisely at the last tick). The speed is given in hardware 
clock ticks, of which there are 1193181 a second. You can convert from 
other time formats to hardware clock ticks with the macros: 
\par {\s1 \f1\fs18 
\par       SECS_TO_TIMER(secs)  - give the number of seconds between
\par                              each tick
\par       MSEC_TO_TIMER(msec)  - give the number of milliseconds
\par                              between ticks
\par       BPS_TO_TIMER(bps)    - give the number of ticks each second
\par       BPM_TO_TIMER(bpm)    - give the number of ticks per minute
\par }\par There can only be sixteen timers in use at a time, and some other parts of 
Allegro (the GUI code, the mouse pointer display routines, rest(), the FLI 
player, and the MIDI player) need to install handlers of their own, so you 
should avoid using too many at the same time. If you call this routine 
without having first installed the timer module, install_timer() will be 
called automatically. 
\par \par Your function will be called by the Allegro interrupt handler and not 
directly by the processor, so it can be a normal C function and does not 
need a special wrapper. You should be aware, however, that it will be 
called in an interrupt context, which imposes a lot of restrictions on 
what you can do in it. It should not use large amounts of stack, it must 
not make any calls to the operating system, use C library functions, or 
contain any floating point code, and it must execute very quickly. Don't 
try to do lots of complicated code in a timer handler: as a general rule 
you should just set some flags and respond to these later in your main 
control loop. 
\par \par In a DOS protected mode environment like DJGPP, memory is virtualised and 
can be swapped to disk. Due to the non-reentrancy of DOS, if a disk swap 
occurs inside an interrupt handler the system will die a painful death, 
so you need to make sure you lock all the memory (both code and data) 
that is touched inside timer routines. Allegro will lock everything it 
uses, but you are responsible for locking your handler functions. The 
macros LOCK_VARIABLE (variable), END_OF_FUNCTION (function_name), 
END_OF_STATIC_FUNCTION (function_name), and LOCK_FUNCTION (function_name) 
can be used to simplify this task. For example, if you want an interrupt 
handler that increments a counter variable, you should write: 
\par {\s1 \f1\fs18 
\par       volatile int counter;
\par 
\par       void my_timer_handler()
\par       \{
\par          counter++;
\par       \}
\par 
\par       END_OF_FUNCTION(my_timer_handler)
\par }\par and in your initialisation code you should lock the memory: 
\par {\s1 \f1\fs18 
\par       LOCK_VARIABLE(counter);
\par       LOCK_FUNCTION(my_timer_handler);
\par }\par Obviously this can get awkward if you use complicated data structures and 
call other functions from within your handler, so you should try to keep 
your interrupt routines as simple as possible. 
\par \par Returns zero on success, or a negative number if there is no room to add 
a new user timer. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Macro {\xe\v LOCK_VARIABLE}LOCK_VARIABLE(variable_name);\par }
{\li400 Due to interrupts, you are required to lock all the memory used by your 
timer routines. See the description of install_int_ex() for a more 
detailed explanation and usage example. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Macro {\xe\v LOCK_FUNCTION}LOCK_FUNCTION(function_name);\par }
{\li400 Due to interrupts, you are required to lock all the memory used by your 
timer routines. See the description of install_int_ex() for a more 
detailed explanation and usage example. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Macro {\xe\v END_OF_FUNCTION}END_OF_FUNCTION(function_name);\par }
{\li400 Due to interrupts, you are required to lock all the code used by your 
timer routines. See the description of install_int_ex() for a more 
detailed explanation and usage example. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v remove_int}remove_int(void (*proc)());\par }
{\li400 Removes a function from the list of user interrupt routines. At program 
termination, allegro_exit() does this automatically. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v install_param_int}install_param_int(void (*proc)(void *), void *param, int speed);\par }
{\li400 Like install_int(), but the callback routine will be passed a copy of the 
specified void pointer parameter. To disable the handler, use 
remove_param_int() instead of remove_int(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v install_param_int_ex}install_param_int_ex(void (*proc)(void *), void *param, int speed);\par }
{\li400 Like install_int_ex(), but the callback routine will be passed a copy of 
the specified void pointer parameter. To disable the handler, use 
remove_param_int() instead of remove_int(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v remove_param_int}remove_param_int(void (*proc)(void *), void *param);\par }
{\li400 Like remove_int(), but for use with timer callbacks that have parameter 
values. If there is more than one copy of the same callback active at a 
time, it identifies which one to remove by checking the parameter value 
(so you can't have more than one copy of a handler using an identical 
parameter). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern volatile int {\xe\v retrace_count}retrace_count;\par }
{\li400 If the retrace simulator is installed, this count is incremented on each 
vertical retrace; otherwise, if the refresh rate is known, the count is 
incremented at the same rate (ignoring retraces); otherwise, it is 
incremented 70 times a second. This provides a way of controlling 
the speed of your program without installing user timer functions. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v rest}rest(unsigned int time);\par }
{\li400 This function waits for the specified number of milliseconds. 
\par \par Passing 0 as parameter will not wait, but just yield. This can be useful 
in order to "play nice" with other processes. Other values will cause 
CPU time to be dropped on most platforms. This will look better to 
users, and also does things like saving battery power and making fans 
less noisy. 
\par \par Note that calling this inside your active game loop is a bad idea, as 
you never know when the OS will give you the CPU back, so you could end 
up missing the vertical retrace and skipping frames. On the other hand, 
on multitasking operating systems it is good form to give up the CPU for 
a while if you will not be using it. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v rest_callback}rest_callback(long time, void (*callback)())\par }
{\li400 Like rest(), but for non-zero values continually calls the specified 
function while it is waiting for the required time to elapse. If the 
provided `callback' parameter is NULL, this function does exactly the 
same thing as calling rest(). 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Keyboard routines}Keyboard routines\par }
The Allegro keyboard handler provides both buffered input and a set of flags 
storing the current state of each key. Note that it is not possible to 
correctly detect every combination of keys, due to the design of the PC 
keyboard. Up to two or three keys at a time will work fine, but if you press 
more than that the extras are likely to be ignored (exactly which 
combinations are possible seems to vary from one keyboard to another). 
\par \par On DOS, Allegro requires the user to specify the language of the keyboard 
mapping because it is impossible to obtain this information from the OS, 
otherwise the default US keyboard mapping will be used. Allegro comes with a 
prepackaged `keyboard.dat' file which you can put along with your binary. If 
this file is present, Allegro will be able to extract the keyboard mapping 
information stored there. However, the end user still needs to select which 
keyboard mapping to use. This can be accomplished through the keyboard variable 
of the system section in a standard `allegro.cfg' configuration file. Read 
chapter "Configuration routines" for more information about this. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v install_keyboard}install_keyboard();\par }
{\li400 Installs the Allegro keyboard interrupt handler. You must call this 
before using any of the keyboard input routines. Once you have set up the 
Allegro handler, you can no longer use operating system calls or C 
library functions to access the keyboard. 
\par \par Note that on some platforms the keyboard won't work unless you have set a 
graphics mode, even if this function returns a success value before 
calling set_gfx_mode. This can happen in environments with graphic 
windowed modes, since Allegro usually reads the keyboard through the 
graphical window (which appears after the set_gfx_mode call). Example: 
\par {\s1 \f1\fs18 
\par       allegro_init();
\par       install_timer();
\par       install_keyboard();
\par       /* We are not 100% sure we can read the keyboard yet! */
\par       if (set_gfx_mode(GFX_AUTODETECT, 640, 480, 0, 0) != 0)
\par          abort_on_error("Couldn't set graphic mode!");
\par 
\par       /* Now we are guaranteed to be able to read the keyboard. */
\par       readkey();\par}
\par Returns zero on success, or a negative number on failure (but you may 
decide not to check the return value as this function is very unlikely to 
fail). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v remove_keyboard}remove_keyboard();\par }
{\li400 Removes the keyboard handler, returning control to the operating system. 
You don't normally need to bother calling this, because allegro_exit() 
will do it for you. However, you might want to call this during runtime if 
you want to change the keyboard mapping on those platforms were keyboard 
mappings are needed. You would first modify the configuration variable 
holding the keyboard mapping and then reinstall the keyboard handler. 
Example: 
\par {\s1 \f1\fs18 
\par       remove_keyboard();
\par       /* Switch to Spanish keyboard mapping. */
\par       set_config_string("system", "keyboard", "es");
\par       install_keyboard();\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v install_keyboard_hooks}install_keyboard_hooks(int (*keypressed)(), int (*readkey)());\par }
{\li400 You should only use this function if you *aren't* using the rest of the 
keyboard handler. It should be called in the place of install_keyboard(), 
and lets you provide callback routines to detect and read keypresses, 
which will be used by the main keypressed() and readkey() functions. This 
can be useful if you want to use Allegro's GUI code with a custom 
keyboard handler, as it provides a way for the GUI to get keyboard input 
from your own code, bypassing the normal Allegro input system. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v poll_keyboard}poll_keyboard();\par }
{\li400 Wherever possible, Allegro will read the keyboard input asynchronously 
(ie. from inside an interrupt handler), but on some platforms that may 
not be possible, in which case you must call this routine at regular 
intervals to update the keyboard state variables. 
\par \par To help you test your keyboard polling code even if you are programming 
on a platform that doesn't require it, after the first time that you 
call this function Allegro will switch into polling mode, so from that 
point onwards you will have to call this routine in order to get any 
keyboard input at all, regardless of whether the current driver actually 
needs to be polled or not. 
\par \par The keypressed(), readkey(), and ureadkey() functions call poll_keyboard() 
automatically, so you only need to use this function when accessing the 
key[] array and key_shifts variable. 
\par \par Returns zero on success, or a negative number on failure (ie. no keyboard 
driver installed). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v keyboard_needs_poll}keyboard_needs_poll();\par }
{\li400 Returns TRUE if the current keyboard driver is operating in polling mode. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern volatile char {\xe\v key}key[KEY_MAX];\par }
{\li400 Array of flags indicating the state of each key, ordered by scancode. 
Wherever possible these values will be updated asynchronously, but if 
keyboard_needs_poll() returns TRUE, you must manually call 
poll_keyboard() to update them with the current input state. The 
scancodes are defined in allegro/keyboard.h as a series of KEY_* 
constants (and are also listed below). For example, you could write: 
\par {\s1 \f1\fs18 
\par       if (key[KEY_SPACE])
\par          printf("Space is pressed\\n");\par}
\par Note that the array is supposed to represent which keys are physically 
held down and which keys are not, so it is semantically read-only. 
\par \par These are the keyboard scancodes: 
\par {\s1 \f1\fs18 
\par       KEY_A ... KEY_Z,
\par       KEY_0 ... KEY_9,
\par       KEY_0_PAD ... KEY_9_PAD,
\par       KEY_F1 ... KEY_F12,
\par 
\par       KEY_ESC, KEY_TILDE, KEY_MINUS, KEY_EQUALS,
\par       KEY_BACKSPACE, KEY_TAB, KEY_OPENBRACE, KEY_CLOSEBRACE,
\par       KEY_ENTER, KEY_COLON, KEY_QUOTE, KEY_BACKSLASH,
\par       KEY_BACKSLASH2, KEY_COMMA, KEY_STOP, KEY_SLASH,
\par       KEY_SPACE,
\par 
\par       KEY_INSERT, KEY_DEL, KEY_HOME, KEY_END, KEY_PGUP,
\par       KEY_PGDN, KEY_LEFT, KEY_RIGHT, KEY_UP, KEY_DOWN,
\par 
\par       KEY_SLASH_PAD, KEY_ASTERISK, KEY_MINUS_PAD,
\par       KEY_PLUS_PAD, KEY_DEL_PAD, KEY_ENTER_PAD,
\par 
\par       KEY_PRTSCR, KEY_PAUSE,
\par 
\par       KEY_ABNT_C1, KEY_YEN, KEY_KANA, KEY_CONVERT, KEY_NOCONVERT,
\par       KEY_AT, KEY_CIRCUMFLEX, KEY_COLON2, KEY_KANJI,
\par 
\par       KEY_LSHIFT, KEY_RSHIFT,
\par       KEY_LCONTROL, KEY_RCONTROL,
\par       KEY_ALT, KEY_ALTGR,
\par       KEY_LWIN, KEY_RWIN, KEY_MENU,
\par       KEY_SCRLOCK, KEY_NUMLOCK, KEY_CAPSLOCK
\par 
\par       KEY_EQUALS_PAD, KEY_BACKQUOTE, KEY_SEMICOLON, KEY_COMMAND\par}
\par Finally, you may notice an `odd' behaviour of the KEY_PAUSE key. This key 
only generates an interrupt when it is pressed, not when it is released. 
For this reason, Allegro pretends the pause key is a `state' key, which 
is the only way to make it usable. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern volatile int {\xe\v key_shifts}key_shifts;\par }
{\li400 Bitmask containing the current state of shift/ctrl/alt, the special 
Windows keys, and the accent escape characters. Wherever possible this 
value will be updated asynchronously, but if keyboard_needs_poll() 
returns TRUE, you must manually call poll_keyboard() to update it with 
the current input state. This can contain any of the flags: 
\par {\s1 \f1\fs18 
\par       KB_SHIFT_FLAG
\par       KB_CTRL_FLAG
\par       KB_ALT_FLAG
\par       KB_LWIN_FLAG
\par       KB_RWIN_FLAG
\par       KB_MENU_FLAG
\par       KB_COMMAND_FLAG
\par       KB_SCROLOCK_FLAG
\par       KB_NUMLOCK_FLAG
\par       KB_CAPSLOCK_FLAG
\par       KB_INALTSEQ_FLAG
\par       KB_ACCENT1_FLAG
\par       KB_ACCENT2_FLAG
\par       KB_ACCENT3_FLAG
\par       KB_ACCENT4_FLAG\par}
\par Example: 
\par {\s1 \f1\fs18 
\par       if (key[KEY_W]) \{
\par          if (key_shifts & KB_SHIFT_FLAG) \{
\par             /* User is pressing shift + W. */
\par          \} else \{
\par             /* Hmmm... lower case W then. */
\par          \}
\par       \}\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v keypressed}keypressed();\par }
{\li400 Returns TRUE if there are keypresses waiting in the input buffer. You can 
use this to see if the next call to readkey() is going to block or to 
simply wait for the user to press a key while you still update the screen 
possibly drawing some animation. Example: 
\par {\s1 \f1\fs18 
\par       while (!keypressed()) \{
\par          /* Show cool animated logo. */
\par       \}
\par       /* So he skipped our title screen. */\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v readkey}readkey();\par }
{\li400 Returns the next character from the keyboard buffer, in ASCII format. If 
the buffer is empty, it waits until a key is pressed. You can see if there 
are queued keypresses with keypressed(). 
\par \par The low byte of the return value contains the ASCII code of the key, and 
the high byte the scancode. The scancode remains the same whatever the 
state of the shift, ctrl and alt keys, while the ASCII code is affected by 
shift and ctrl in the normal way (shift changes case, ctrl+letter gives 
the position of that letter in the alphabet, eg. ctrl+A = 1, ctrl+B = 2, 
etc). Pressing alt+key returns only the scancode, with a zero ASCII code 
in the low byte. For example: 
\par {\s1 \f1\fs18 
\par       int val;
\par       ...
\par       val = readkey();
\par       if ((val & 0xff) == 'd')     /* by ASCII code */
\par          allegro_message("You pressed 'd'\\n");
\par 
\par       if ((val >> 8) == KEY_SPACE) /* by scancode */
\par          allegro_message("You pressed Space\\n");
\par 
\par       if ((val & 0xff) == 3)       /* ctrl+letter */
\par          allegro_message("You pressed Control+C\\n");
\par 
\par       if (val == (KEY_X << 8))     /* alt+letter */
\par          allegro_message("You pressed Alt+X\\n");
\par }\par This function cannot return character values greater than 255. If you 
need to read Unicode input, use ureadkey() instead. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v ureadkey}ureadkey(int *scancode);\par }
{\li400 Returns the next character from the keyboard buffer, in Unicode format. 
If the buffer is empty, it waits until a key is pressed. You can see if 
there are queued keypresses with keypressed(). The return value contains 
the Unicode value of the key, and if not NULL, the pointer argument will 
be set to the scancode. Unlike readkey(), this function is able to return 
character values greater than 255. Example: 
\par {\s1 \f1\fs18 
\par       int val, scancode;
\par       ...
\par       val = ureadkey(&scancode);
\par       if (val == 0x00F1)
\par          allegro_message("You pressed n with tilde\\n");
\par 
\par       if (val == 0x00DF)
\par          allegro_message("You pressed sharp s\\n");
\par }\par You should be able to find Unicode character maps at 
http://www.unicode.org/. Remember that on DOS you must specify a custom 
keyboard map (like those found in `keyboard.dat') usually with the help of 
a configuration file specifying the language mapping (keyboard variable in 
system section of `allegro.cfg'), or you will get the default US keyboard 
mapping. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v scancode_to_ascii}scancode_to_ascii(int scancode);\par }
{\li400 Converts the given scancode to an ASCII character for that key (mangling 
Unicode values), returning the unshifted uncapslocked result of pressing 
the key, or zero if the key isn't a character-generating key or the lookup 
can't be done. The lookup cannot be done for keys like the F1-F12 keys or the 
cursor keys, and some drivers will only return approximate values. Generally, 
if you want to display the name of a key to the user, you should use the 
scancode_to_name function. 
\par \par Example: 
\par {\s1 \f1\fs18 
\par       int ascii;
\par       ...
\par       ascii = scancode_to_ascii(scancode);
\par       allegro_message("You pressed '%c'\\n", ascii);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b const char *{\xe\v scancode_to_name}scancode_to_name(int scancode);\par }
{\li400 This function returns a string pointer containing the name of they key with 
the given scancode. This is useful if you e.g. let the user choose a key for 
some action, and want to display something more meaningful than just the 
scancode. Example: 
\par {\s1 \f1\fs18 
\par       char const *keyname = scancode_to_name(scancode);
\par       allegro_message("You pressed the %s key.", keyname);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v simulate_keypress}simulate_keypress(int key);\par }
{\li400 Stuffs a key into the keyboard buffer, just as if the user had pressed 
it. The parameter is in the same format returned by readkey(). Example: 
\par {\s1 \f1\fs18 
\par       simulate_keypress(KEY_SPACE << 8);
\par       if (readkey() == (KEY_SPACE << 8))
\par          allegro_message("You simulated Alt+Space\\n");\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v simulate_ukeypress}simulate_ukeypress(int key, int scancode);\par }
{\li400 Stuffs a key into the keyboard buffer, just as if the user had pressed 
it. The parameter is in the same format returned by ureadkey(). Example: 
\par {\s1 \f1\fs18 
\par       /* We ignore the scancode simulation. */
\par       simulate_ukeypress(0x00DF, 0);
\par       if (ureadkey(&scancode) == 0x00DF)
\par          allegro_message("You simulated sharp s\\n");\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b extern int (*{\xe\v keyboard_callback}keyboard_callback)(int key);\par }
{\li400 If set, this function is called by the keyboard handler in response to 
every keypress. It is passed a copy of the value that is about to be 
added into the input buffer, and can either return this value unchanged, 
return zero to cause the key to be ignored, or return a modified value to 
change what readkey() will later return. This routine executes in an 
interrupt context, so it must be in locked memory. Example: 
\par {\s1 \f1\fs18 
\par       int enigma_scrambler(int key)
\par       \{
\par          /* Add one to both the scancode and ascii values. */
\par          return (((key >> 8) + 1) 
\par       \}
\par       END_OF_FUNCTION(enigma_scrambler)
\par       
\par       ...
\par       
\par          install_timer();
\par          LOCK_FUNCTION(enigma_scrambler);
\par          install_keyboard();
\par          keyboard_callback = enigma_scrambler;\par}
\par Note that this callback will be ignored if you also set the unicode 
keyboard callback. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int (*{\xe\v keyboard_ucallback}keyboard_ucallback)(int key, int *scancode);\par }
{\li400 Unicode-aware version of keyboard_callback(). If set, this function is 
called by the keyboard handler in response to every keypress. It is 
passed the character value and scancode that are about to be added into 
the input buffer, can modify the scancode value, and returns a new or 
modified key code. If it both sets the scancode to zero and returns zero, 
the keypress will be ignored. This routine executes in an interrupt 
context, so it must be in locked memory. Example: 
\par {\s1 \f1\fs18 
\par       int silence_g_key(int key, int *scancode)
\par       \{
\par          if (key == 'g') \{
\par             *scancode = 0;
\par             return 0;
\par          \}
\par          return key;
\par       \} END_OF_FUNCTION(silence_g_key)
\par 
\par       ...
\par       
\par          install_timer();
\par          LOCK_FUNCTION(silence_g_key);
\par          install_keyboard();
\par          keyboard_ucallback = silence_g_key;\par}
\par Note that this keyboard callback has priority over the non unicode 
callback. If you set both, only the unicode one will work. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern void (*{\xe\v keyboard_lowlevel_callback}keyboard_lowlevel_callback)(int scancode);\par }
{\li400 If set, this function is called by the keyboard handler in response to 
every keyboard event, both presses (including keyboard repeat rate) and 
releases. It will be passed a raw keyboard scancode byte (scancodes are 
7 bits long), with the top bit (8th bit) clear if the key has been 
pressed or set if it was released. This routine executes in an interrupt 
context, so it must be in locked memory. Example: 
\par {\s1 \f1\fs18 
\par       volatile int key_down, key_up;
\par       
\par       void keypress_watcher(int scancode)
\par       \{
\par          if (scancode & 0x80) \{
\par             key_up = 1;
\par          \} else \{
\par             key_down = 1;
\par          \}
\par       \} END_OF_FUNCTION(keypress_watcher)
\par 
\par       ...
\par 
\par          install_timer();
\par          LOCK_FUNCTION(silence_g_key);
\par          LOCK_VARIABLE(key_down);
\par          LOCK_VARIABLE(key_up);
\par          install_keyboard();
\par          keyboard_lowlevel_callback = keypress_watcher;
\par          /* Disable keyboard repeat to get typewriter effect. */
\par          set_keyboard_rate(0, 0);
\par 
\par       ...
\par 
\par          while (game_loop) \{
\par             if (key_down) \{
\par                key_down = 0;
\par                /* Play sample of typewriter key press. */
\par             \}
\par             if (key_up) \{
\par                key_up = 0;
\par                /* Play sample of typewriter key release. */
\par             \}
\par          \}\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_leds}set_leds(int leds);\par }
{\li400 Overrides the state of the keyboard LED indicators. The parameter is a 
bitmask containing any of the values KB_SCROLOCK_FLAG, KB_NUMLOCK_FLAG, 
and KB_CAPSLOCK_FLAG, or -1 to restore the default behavior. Example: 
\par {\s1 \f1\fs18 
\par       /* Cycle led indicators. */
\par       set_leds(KB_SCROLOCK_FLAG);
\par       rest(1000);
\par       set_leds(KB_CAPSLOCK_FLAG);
\par       rest(1000);
\par       set_leds(KB_NUMLOCK_FLAG);
\par       rest(1000);
\par       set_leds(-1);
\par }\par Note that the led behaviour cannot be guaranteed on some platforms, some 
leds might not react, or none at all. Therefore you shouldn't rely only on 
them to communicate information to the user, just in case it doesn't get 
through. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_keyboard_rate}set_keyboard_rate(int delay, int repeat);\par }
{\li400 Sets the keyboard repeat rate. Times are given in milliseconds. Passing 
zero times will disable the key repeat. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v clear_keybuf}clear_keybuf();\par }
{\li400 Empties the keyboard buffer. Usually you want to use this in your program 
before reading keys to avoid previously buffered keys to be returned by 
calls to readkey() or ureadkey(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v three_finger_flag}three_finger_flag;\par }
{\li400 The DJGPP keyboard handler provides an 'emergency exit' sequence which 
you can use to kill off your program. If you are running under DOS this 
is the three finger salute, ctrl+alt+del. Most multitasking OS's will 
trap this combination before it reaches the Allegro handler, in which 
case you can use the alternative ctrl+alt+end. If you want to disable 
this behaviour in release versions of your program, set this flag to 
FALSE. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v key_led_flag}key_led_flag;\par }
{\li400 By default, the capslock, numlock, and scroll-lock keys toggle the 
keyboard LED indicators when they are pressed. If you are using these 
keys for input in your game (eg. capslock to fire) this may not be 
desirable, so you can clear this flag to prevent the LED's being updated. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Joystick routines}Joystick routines\par }
Unlike keyboard or mouse input, which are usually read through hardware 
interrupts by Allegro, joystick input functions have to be polled because 
there are no hardware interrupts for them on most platforms. This doesn't 
mean that you have to poll the joysticks on each line of code you want to 
read their values, but you should make sure to poll them at least once per 
frame in your game loop. Otherwise you face the possibility of reading stale 
incorrect data. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v install_joystick}install_joystick(int type);\par }
{\li400 Installs Allegro's joystick handler, and calibrates the centre position 
values. The type parameter should usually be JOY_TYPE_AUTODETECT, or see 
the platform specific documentation for a list of the available drivers. 
You must call this routine before using any other joystick functions, and 
you should make sure that all joysticks are in the middle position at the 
time. Example: 
\par {\s1 \f1\fs18 
\par       textout_centre_ex(screen, font,
\par                         "Center the joystick and press a key",
\par                         SCREEN_W/2, SCREEN_H/2, red_color, -1);
\par       readkey();
\par       if (install_joystick(JOY_TYPE_AUTODETECT) != 0)
\par          abort_on_error("Error initialising joystick!");\par}
\par Returns zero on success. As soon as you have installed the joystick 
module, you will be able to read the button state and digital (on/off 
toggle) direction information, which may be enough for some games. If you 
want to get full analogue input, though, you need to use the 
calibrate_joystick() functions to measure the exact range of the inputs: 
see below. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v remove_joystick}remove_joystick();\par }
{\li400 Removes the joystick handler. You don't normally need to bother calling 
this, because allegro_exit() will do it for you. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v poll_joystick}poll_joystick();\par }
{\li400 The joystick handler is not interrupt driven, so you need to call this 
function every now and again to update the global position values. Example: 
\par {\s1 \f1\fs18 
\par    do \{
\par       /* Get joystick input */
\par       poll_joystick();
\par       
\par       /* Process input for the first joystick */
\par       if (joy[0].button[0].b)
\par          first_button_pressed();
\par 
\par       if (joy[0].button[1].b)
\par          second_button_pressed();
\par       ...
\par    \} while(!done);\par}
\par Returns zero on success or a negative number on failure (usually because 
no joystick driver was installed). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v num_joysticks}num_joysticks;\par }
{\li400 Global variable containing the number of active joystick devices. The 
current drivers support a maximum of eight controllers. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern JOYSTICK_INFO {\xe\v joy}joy[n];\par }
{\li400 Global array of joystick state information, which is updated by the 
poll_joystick() function. Only the first num_joysticks elements will 
contain meaningful information. The JOYSTICK_INFO structure is defined as: 
\par {\s1 \f1\fs18 
\par       typedef struct JOYSTICK_INFO
\par       \{
\par          int flags;                       - status flags for this
\par                                             joystick
\par          int num_sticks;                  - how many stick inputs?
\par          int num_buttons;                 - how many buttons?
\par          JOYSTICK_STICK_INFO stick[n];    - stick state information
\par          JOYSTICK_BUTTON_INFO button[n];  - button state information
\par       \} JOYSTICK_INFO;
\par }\par The button status is stored in the structure: 
\par {\s1 \f1\fs18 
\par       typedef struct JOYSTICK_BUTTON_INFO
\par       \{
\par          int b;                           - boolean on/off flag
\par          char *name;                      - description of this
\par                                             button
\par       \} JOYSTICK_BUTTON_INFO;
\par }\par You may wish to display the button names as part of an input 
configuration screen to let the user choose what game function will be 
performed by each button, but in simpler situations you can safely assume 
that the first two elements in the button array will always be the main 
trigger controls. 
\par \par Each joystick will provide one or more stick inputs, of varying types. 
These can be digital controls which snap to specific positions (eg. a 
gamepad controller, the coolie hat on a Flightstick Pro or Wingman 
Extreme, or a normal joystick which hasn't yet been calibrated), or they 
can be full analogue inputs with a smooth range of motion. Sticks may 
also have different numbers of axes, for example a normal directional 
control has two, but the Flightstick Pro throttle is only a single axis, 
and it is possible that the system could be extended in the future to 
support full 3d controllers. A stick input is described by the structure: 
\par {\s1 \f1\fs18 
\par       typedef struct JOYSTICK_STICK_INFO
\par       \{
\par          int flags;                       - status flags for this
\par                                             input
\par          int num_axis;                    - how many axes do we
\par                                             have? (note the misspelling)
\par          JOYSTICK_AXIS_INFO axis[n];      - axis state information
\par          char *name;                      - description of this
\par                                             input
\par       \} JOYSTICK_STICK_INFO;
\par }\par A single joystick may provide several different stick inputs, but you can 
safely assume that the first element in the stick array will always be 
the main directional controller. 
\par \par Information about each of the stick axis is stored in the substructure: 
\par {\s1 \f1\fs18 
\par       typedef struct JOYSTICK_AXIS_INFO
\par       \{
\par          int pos;                         - analogue axis position
\par          int d1, d2;                      - digital axis position
\par          char *name;                      - description of this axis
\par       \} JOYSTICK_AXIS_INFO;
\par }\par This provides both analogue input in the pos field (ranging from -128 to 
128 or from 0 to 255, depending on the type of the control), and digital 
values in the d1 and d2 fields. For example, when describing the X-axis 
position, the pos field will hold the horizontal position of the 
joystick, d1 will be set if it is moved left, and d2 will be set if it is 
moved right. Allegro will fill in all these values regardless of whether 
it is using a digital or analogue joystick, emulating the pos field for 
digital inputs by snapping it to the min, middle, and maximum positions, 
and emulating the d1 and d2 values for an analogue stick by comparing the 
current position with the centre point. 
\par \par The joystick flags field may contain any combination of the bit flags: 
\par \par {\b JOYFLAG_DIGITAL\par}
This control is currently providing digital input. 
\par \par {\b JOYFLAG_ANALOGUE\par}
This control is currently providing analogue input. 
\par \par {\b JOYFLAG_CALIB_DIGITAL\par}
This control will be capable of providing digital input once it has 
been calibrated, but is not doing this at the moment. 
\par \par {\b JOYFLAG_CALIB_ANALOGUE\par}
This control will be capable of providing analogue input once it has 
been calibrated, but is not doing this at the moment. 
\par \par {\b JOYFLAG_CALIBRATE\par}
Indicates that this control needs to be calibrated. Many devices 
require multiple calibration steps, so you should call the 
calibrate_joystick() function from a loop until this flag is cleared. 
\par \par {\b JOYFLAG_SIGNED\par}
Indicates that the analogue axis position is in signed format, ranging 
from -128 to 128. This is the case for all 2d directional controls. 
\par \par {\b JOYFLAG_UNSIGNED\par}
Indicates that the analogue axis position is in unsigned format, 
ranging from 0 to 255. This is the case for all 1d throttle controls. 
\par \par Note for people who spell funny: in case you don't like having to type 
"analogue", there are some #define aliases in allegro/joystick.h that 
will allow you to write "analog" instead. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b const char *{\xe\v calibrate_joystick_name}calibrate_joystick_name(int n);\par }
{\li400 Pass the number of the joystick you want to calibrate as the parameter. 
\par \par Returns a text description for the next type of calibration that will be 
done on the specified joystick, or NULL if no more calibration is 
required. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v calibrate_joystick}calibrate_joystick(int n);\par }
{\li400 Most joysticks need to be calibrated before they can provide full 
analogue input. This function performs the next operation in the 
calibration series for the specified stick, assuming that the joystick 
has been positioned in the manner described by a previous call to 
calibrate_joystick_name(), returning zero on success. For example, a 
simple routine to fully calibrate all the joysticks might look like: 
\par {\s1 \f1\fs18 
\par       int i;
\par 
\par       for (i=0; i<;num_joysticks; i++) \{
\par          while (joy[i].flags & JOYFLAG_CALIBRATE) \{
\par             char *msg = calibrate_joystick_name(i);
\par             textprintf_ex(..., "%s, and press a key\\n", msg);
\par             readkey();
\par             if (calibrate_joystick(i) != 0) \{
\par                textprintf_ex(..., "oops!\\n");
\par                readkey();
\par                exit(1);
\par             \}
\par          \}
\par       \}\par}
\par Returns zero on success, non-zero if the calibration could not be 
performed successfully. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v save_joystick_data}save_joystick_data(const char *filename);\par }
{\li400 After all the headache of calibrating the joystick, you may not want to 
make your poor users repeat the process every time they run your program. 
Call this function to save the joystick calibration data into the 
specified configuration file, from which it can later be read by 
load_joystick_data(). Pass a NULL filename to write the data to the 
currently selected configuration file. 
\par \par Returns zero on success, non-zero if the data could not be saved. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v load_joystick_data}load_joystick_data(const char *filename);\par }
{\li400 Restores calibration data previously stored by save_joystick_data() or 
the setup utility. This sets up all aspects of the joystick code: you 
don't even need to call install_joystick() if you are using this 
function. Pass a NULL filename to read the data from the currently 
selected configuration file. 
\par \par Returns zero on success: if it fails the joystick state is undefined and 
you must reinitialise it from scratch. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v initialise_joystick}initialise_joystick();\par }
{\li400 Deprecated. Use install_joystick() instead. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Graphics modes}Graphics modes\par }
Graphics modes are the common denominator for most Allegro programs. While it 
is possible to write platform specific programs using Allegro which don't set 
a graphic mode through the routines provided in this chapter, these are not 
very common. 
\par \par The first thing to note is that due to the wide range of supported platforms, 
a graphic mode is the only way to safely communicate with the user. When 
Allegro was a DOS only library (versions 3.x and previous), it was frequent 
for programmers to use functions from the C standard library to communicate 
with the user, like calling printf() before setting a graphic mode or maybe 
scanf() to read the user's input. However, what would happen for such a game 
running under Windows where there is no default console output or it may be 
hidden from the user? Even if the game compiled successfully, it would be 
unplayable, especially if there was vital information for the user in those 
text only messages. 
\par \par Allegro provides the allegro_message() function to deal with this problem, 
but this is not a very user friendly method of communicating with the user 
and its main purpose is displaying small error like messages when no graphic 
mode is available. Therefore, the first thing your Allegro program should do 
is set a graphic mode, and from there on, use Allegro's text output routines 
to display messages to the user, just like `allegro/examples/exhello.c' does. 
\par \par Setting a graphic mode involves deciding how to allocate the memory of the 
video card for your program. On some platforms this means creating a virtual 
screen bigger than the physical resolution to do hardware scrolling or page 
flipping. Virtual screens can cause a lot of confusion, but they are really 
quite simple. Warning: patronising explanation coming up, so you may wish to 
skip the rest of this paragraph. Think of video memory as a rectangular piece 
of paper which is being viewed through a small hole (your monitor) in a bit of 
cardboard. Since the paper is bigger than the hole you can only see part of it 
at any one time, but by sliding the cardboard around you can alter which 
portion of the image is visible. You could just leave the hole in one position 
and ignore the parts of video memory that aren't visible, but you can get all 
sorts of useful effects by sliding the screen window around, or by drawing 
images in a hidden part of video memory and then flipping across to display 
them. 
\par \par For example, you could select a 640x480 mode in which the monitor acts as a 
window onto a 1024x1024 virtual screen, and then move the visible screen 
around in this larger area (hardware scrolling). Initially, with the visible 
screen positioned at the top left corner of video memory, this setup would 
look like: 
\par {\s1 \f1\fs18 
\par       (0,0)------------(640,0)----(1024,0)
\par         |                  |           |
\par         |  visible screen  |           |
\par         |                  |           |
\par       (0,480)----------(640,480)       |
\par         |                              |
\par         |   the rest of video memory   |
\par         |                              |
\par       (0,1024)--------------------(1024,1024)
\par }\par With a virtual screen bigger than the visible screen you can perform smooth 
CPU inexpensive scrolling: you draw your graphics once, and then only tell 
the video card to show a different portion of the screen. However, virtual 
screens are not supported on all platforms, and on some they might be 
emulated through software, losing any performance. On top of that, many video 
cards only allow horizontal scrolling in steps of 32 bytes. This is not a 
problem if your game runs in 24 or 32 bit, but it tends to mean jerky 
scrolling for other color depths. 
\par \par The other reason you could use virtual screens for is page flipping. This 
means showing one portion of the virtual screen while your program draws to 
the hidden one. When you finish, you show the part you have been drawing to 
and repeat the process with the area now hidden. The result is a perfectly 
smooth screen update without flickering or other graphical artifacts. 
\par \par Scrolling manually to one part of the video memory is one non portable way to 
accomplish this. The portable way is to use functions like 
create_system_bitmap(), create_video_bitmap(), show_video_bitmap(), etc. These 
functions divide the memory of the video card in areas and switch between 
them, a feature supported on all platforms and video cards (given that they 
have enough memory for the screen resolutions you asked for). 
\par \par The last thing you need to know about setting a graphic mode are drivers. 
Each platform has a number of graphic drivers which support a different range 
of hardware or behave in different ways. To avoid cluttering your own code 
with #ifdefs and dealing with drivers added after you release your program, 
Allegro provides several so called magic drivers. These magic drivers don't 
really exists, they wrap around a specific kind of functionality. 
\par \par The magic drivers you can use are: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 GFX_AUTODETECT:\par \pard \li400 
Allegro will try to set the specified resolution with the current color 
depth in fullscreen mode. Failing that, it will try to repeat the same 
operation in windowed mode. If the call to set_gfx_mode() succeeds, you 
are guaranteed to have set the specified resolution in the current color 
depth, but you don't know if the program is running fullscreen or 
windowed. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 GFX_AUTODETECT_FULLSCREEN:\par \pard \li400 
Allegro will try to set the specified resolution with the current color 
depth in fullscreen mode. If that is not possible, set_gfx_mode() will 
fail. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 GFX_AUTODETECT_WINDOWED:\par \pard \li400 
Allegro will try to set the specified resolution with the current color 
depth in a windowed mode. If that is not possible, set_gfx_mode() will 
fail. When it comes to windowed modes, the `specified resolution' actually 
means the graphic area your program can draw on, without including window 
decorations (if any). Note that in windowed modes running with a color 
depth other than the desktop may result in non optimal performance due to 
internal color conversions in the graphic driver. Use 
desktop_color_depth() to your advantage in these situations. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 GFX_SAFE:\par \pard \li400 
Using this driver Allegro guarantees that a graphic mode will always be 
set correctly. It will try to select the resolution that you request, and 
if that fails, it will fall back upon whatever mode is known to be 
reliable on the current platform (this is 320x200 VGA mode under DOS, a 
640x480 resolution under Windows, the actual framebuffer's resolution 
under Linux if it's supported, etc). If it absolutely cannot set any 
graphics mode at all, it will return negative as usual, meaning that 
there's no possible video output on the machine, and that you should abort 
your program immediately, possibly after notifying this to the user with 
allegro_message. 
\par \par This fake driver is useful for situations where you just want to get into 
some kind of workable display mode, and can't be bothered with trying 
multiple different resolutions and doing all the error checking yourself. 
Note however, that after a successful call to set_gfx_mode with this 
driver, you cannot make any assumptions about the width, height or color 
depth of the screen: your code will have to deal with this little detail. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 GFX_TEXT:\par \pard \li400 
Closes any previously opened graphics mode, making you unable to use the 
global variable `screen', and in those environments that have text modes, 
sets one previously used or the closest match to that (usually 80x25). 
With this driver the size parameters of set_gfx_mode don't mean anything, 
so you can leave them all to zero or any other number you prefer. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_color_depth}set_color_depth(int depth);\par }
{\li400 Sets the pixel format to be used by subsequent calls to set_gfx_mode() 
and create_bitmap(). Valid depths are 8 (the default), 15, 16, 24, and 32 
bits. Example: 
\par {\s1 \f1\fs18 
\par       set_color_depth(32);
\par       if (set_gfx_mode(GFX_AUTODETECT, 640, 480, 0, 0) != 0) \{
\par          abort_on_error("Couldn't set a 32 bit color resolution");
\par       \}
\par }\par Note that the screen color depth won't change until the next successful 
call to set_gfx_mode(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_color_depth}get_color_depth(void);\par }
{\li400 Returns the current pixel format. This can be very useful to know in order 
to write generic functions which select a different code path internally 
depending on the color depth being used. 
\par \par Note that the function returns whatever value you may have set previously 
with set_color_depth(), which can be different from the current color 
depth of the screen global variable. If you really need to know the color 
depth of the screen, use bitmap_color_depth(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v request_refresh_rate}request_refresh_rate(int rate);\par }
{\li400 Requests that the next call to set_gfx_mode() try to use the specified 
refresh rate, if possible. Not all drivers are able to control this at 
all, and even when they can, not all rates will be possible on all 
hardware, so the actual settings may differ from what you requested. 
After you call set_gfx_mode(), you can use get_refresh_rate() to find out 
what was actually selected. At the moment only the DOS VESA 3.0, X DGA 2.0 
and some Windows DirectX drivers support this function. The speed is 
specified in Hz, eg. 60, 70. To return to the normal default selection, 
pass a rate value of zero. Example: 
\par {\s1 \f1\fs18 
\par       request_refresh_rate(60);
\par       if (set_gfx_mode(GFX_AUTODETECT, 640, 480, 0, 0) != 0)
\par          abort_on_error("Couldn't set graphic mode!");
\par       if (get_refresh_rate() != 60)
\par          abort_on_error("Couldn't set refresh rate to 60Hz!");\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_refresh_rate}get_refresh_rate(void);\par }
{\li400 Returns the current refresh rate, if known (not all drivers are able to 
report this information). Returns zero if the actual rate is unknown. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b GFX_MODE_LIST *{\xe\v get_gfx_mode_list}get_gfx_mode_list(int card);\par }
{\li400 Attempts to create a list of all the supported video modes for a certain 
graphics driver, made up from the GFX_MODE_LIST structure, which has the 
following definition: 
\par {\s1 \f1\fs18 
\par       typedef struct GFX_MODE_LIST
\par       \{
\par          int num_modes;
\par          GFX_MODE *mode;
\par       \} GFX_MODE_LIST;
\par }\par The mode entry  points to the actual list of video modes. 
\par {\s1 \f1\fs18 
\par       typedef struct GFX_MODE
\par       \{
\par          int width, height, bpp;
\par       \} GFX_MODE;
\par }\par This list of video modes is terminated with an \{ 0, 0, 0 \} entry. 
\par \par Note that the card parameter must refer to a _real_ driver. This function 
fails if you pass GFX_SAFE, GFX_AUTODETECT, or any other "magic" driver. 
\par \par Returns a pointer to a list structure of the type GFX_MODE_LIST or NULL 
if the request could not be satisfied. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v destroy_gfx_mode_list}destroy_gfx_mode_list(GFX_MODE_LIST *mode_list);\par }
{\li400 Removes the mode list created by get_gfx_mode_list() from memory. Use this 
once you are done with the generated mode list to avoid memory leaks in 
your program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v set_gfx_mode}set_gfx_mode(int card, int w, int h, int v_w, int v_h);\par }
{\li400 Switches into graphics mode. The card parameter should usually be one of 
the Allegro magic drivers (read introduction of chapter "Graphics modes") 
or see the platform specific documentation for a list of the available 
drivers. The w and h parameters specify what screen resolution you want. 
The color depth of the graphic mode has to be specified before calling 
this function with set_color_depth(). 
\par \par The v_w and v_h parameters specify the minimum virtual screen size, in 
case you need a large virtual screen for hardware scrolling or page 
flipping. You should set them to zero if you don't care about the virtual 
screen size. 
\par \par When you call set_gfx_mode(), the v_w and v_h parameters represent the 
minimum size of virtual screen that is acceptable for your program. The 
range of possible sizes is usually very restricted, and Allegro may 
end up creating a virtual screen much larger than the one you request. 
Allowed sizes are driver dependent and some drivers do not allow virtual 
screens that are larger than the visible screen at all: don't assume 
that whatever you pass will always work. 
\par \par In mode-X the virtual width can be any multiple of eight greater than or 
equal to the physical screen width, and the virtual height will be set 
accordingly (the VGA has 256k of vram, so the virtual height will be 
256*1024/virtual_width). 
\par \par Currently, using a big virtual screen for page flipping is considered bad 
practice.  There are platforms which don't support virtual screens bigger 
than the physical screen but can create different video pages to flip back 
and forth. This means that, if you want page flipping and aren't going to 
use hardware scrolling, you should call set_gfx_mode() with (0,0) as the 
virtual screen size and later create the different video pages with 
create_video_bitmap(). Otherwise your program will be limited to the 
platforms supporting hardware scrolling. 
\par \par After you select a graphics mode, the physical and virtual screen sizes 
can be checked with the macros SCREEN_W, SCREEN_H, VIRTUAL_W, and 
VIRTUAL_H. 
\par \par Returns zero on success. On failure returns a negative number and stores a 
description of the problem in allegro_error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v set_display_switch_mode}set_display_switch_mode(int mode);\par }
{\li400 Sets how the program should handle being switched into the background, 
if the user tabs away from it. Not all of the possible modes will be 
supported by every graphics driver on every platform. The available modes 
are: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 SWITCH_NONE\par \pard \li800 
Disables switching. This is the default in single-tasking systems like 
DOS. It may be supported on other platforms, but you should use it 
with caution, because your users won't be impressed if they want to 
switch away from your program, but you don't let them! 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 SWITCH_PAUSE\par \pard \li800 
Pauses the program whenever it is in the background. Execution will be 
resumed as soon as the user switches back to it. This is the default 
in most fullscreen multitasking environments, for example the Linux 
console, but not under Windows. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 SWITCH_AMNESIA\par \pard \li800 
Like SWITCH_PAUSE, but this mode doesn't bother to remember the 
contents of video memory, so the screen, and any video bitmaps that 
you have created, will be erased after the user switches away and then 
back to your program. This is not a terribly useful mode to have, but 
it is the default for the fullscreen drivers under Windows because 
DirectDraw is too dumb to implement anything better. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 SWITCH_BACKGROUND\par \pard \li800 
The program will carry on running in the background, with the screen 
bitmap temporarily being pointed at a memory buffer for the fullscreen 
drivers. You must take special care when using this mode, because bad 
things will happen if the screen bitmap gets changed around when your 
program isn't expecting it (see below). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 SWITCH_BACKAMNESIA\par \pard \li800 
Like SWITCH_BACKGROUND, but this mode doesn't bother to remember the 
contents of video memory (see SWITCH_AMNESIA). It is again the only 
mode supported by the fullscreen drivers under Windows that lets the 
program keep running in the background. 
\par}\par Note that you should be very careful when you are using graphics routines 
in the switching context: you must always call acquire_screen() before the 
start of any drawing code onto the screen and not release it until you are 
completely finished, because the automatic locking mechanism may not be 
good enough to work when the program runs in the background or has just 
been raised in the foreground. 
\par \par Returns zero on success, invalidating at the same time all callbacks 
previously registered with set_display_switch_callback(). Returns -1 if 
the requested mode is not currently possible. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v set_display_switch_callback}set_display_switch_callback(int dir, void (*cb)());\par }
{\li400 Installs a notification callback for the switching mode that was 
previously selected by calling set_display_switch_mode(). The direction 
parameter can either be SWITCH_IN or SWITCH_OUT, depending whether you 
want to be notified about switches away from your program or back to your 
program. You can sometimes install callbacks for both directions at the 
same time, but not every platform supports this. You can install several 
switch callbacks, but no more than eight on any platform. 
\par \par Returns zero on success, decreasing the number of empty callback slots by 
one. Returns -1 if the request is impossible for the current platform or 
you have reached the maximum number of allowed callbacks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v remove_display_switch_callback}remove_display_switch_callback(void (*cb)());\par }
{\li400 Removes a notification callback that was previously installed by calling 
set_display_switch_callback(). All the callbacks will automatically be 
removed when you call set_display_switch_mode(). You can safely call this 
function even if the callback you want to remove is not installed. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_display_switch_mode}get_display_switch_mode();\par }
{\li400 Returns the current display switching mode, in the same format passed to 
set_display_switch_mode(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v is_windowed_mode}is_windowed_mode(void);\par }
{\li400 This function can be used to detect whether or not set_gfx_mode() selected 
a windowed mode. Example: 
\par {\s1 \f1\fs18 
\par       if (set_gfx_mode(GFX_AUTODETECT, 640, 480, 0, 0) != 0)
\par          abort_on_error("Couldn't set graphic mode!");
\par       if (is_windowed_mode()) \{
\par          /* Windowed mode stuff. */
\par       \} else \{
\par          /* Fullscreen mode stuff. */
\par       \}\par}
\par Returns true if the current graphics mode is a windowed mode, or zero if 
it is a fullscreen mode. You should not call this function if you are not 
in graphics mode. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v gfx_capabilities}gfx_capabilities;\par }
{\li400 Bitfield describing the capabilities of the current graphics driver and 
video hardware. This may contain combination any of the flags: 
\par \par {\b GFX_CAN_SCROLL:\par}
Indicates that the scroll_screen() function may be used with this 
driver. 
\par \par {\b GFX_CAN_TRIPLE_BUFFER:\par}
Indicates that the request_scroll() and poll_scroll() functions may be 
used with this driver. If this flag is not set, it is possible that 
the enable_triple_buffer() function may be able to activate it. 
\par \par {\b GFX_HW_CURSOR:\par}
Indicates that a hardware mouse cursor is in use. When this flag is 
set, it is safe to draw onto the screen without hiding the mouse 
pointer first. Note that not every cursor graphic can be implemented 
in hardware: in particular VBE/AF only supports 2-color images up to 
32x32 in size, where the second color is an exact inverse of the 
first. This means that Allegro may need to switch between hardware and 
software cursors at any point during the execution of your program, so 
you should not assume that this flag will remain constant for long 
periods of time. It only tells you whether a hardware cursor is in use 
at the current time, and may change whenever you hide/redisplay the 
pointer. 
\par \par {\b GFX_SYSTEM_CURSOR\par}
Indicates that the mouse cursor is the default system cursor, not 
Allegro's custom cursor. 
\par \par {\b GFX_HW_HLINE:\par}
Indicates that the normal opaque version of the hline() function is 
implemented using a hardware accelerator. This will improve the 
performance not only of hline() itself, but also of many other 
functions that use it as a workhorse, for example circlefill(), 
triangle(), and floodfill(). 
\par \par {\b GFX_HW_HLINE_XOR:\par}
Indicates that the XOR version of the hline() function, and any other 
functions that use it as a workhorse, are implemented using a hardware 
accelerator. 
\par \par {\b GFX_HW_HLINE_SOLID_PATTERN:\par}
Indicates that the solid and masked pattern modes of the hline() 
function, and any other functions that use it as a workhorse, are 
implemented using a hardware accelerator (see note below). 
\par \par {\b GFX_HW_HLINE_COPY_PATTERN:\par}
Indicates that the copy pattern mode of the hline() function, and any 
other functions that use it as a workhorse, are implemented using a 
hardware accelerator (see note below). 
\par \par {\b GFX_HW_FILL:\par}
Indicates that the opaque version of the rectfill() function, the 
clear_bitmap() routine, and clear_to_color(), are implemented using a 
hardware accelerator. 
\par \par {\b GFX_HW_FILL_XOR:\par}
Indicates that the XOR version of the rectfill() function is 
implemented using a hardware accelerator. 
\par \par {\b GFX_HW_FILL_SOLID_PATTERN:\par}
Indicates that the solid and masked pattern modes of the rectfill() 
function are implemented using a hardware accelerator (see note below). 
\par \par {\b GFX_HW_FILL_COPY_PATTERN:\par}
Indicates that the copy pattern mode of the rectfill() function is 
implemented using a hardware accelerator (see note below). 
\par \par {\b GFX_HW_LINE:\par}
Indicates that the opaque mode line() and vline() functions are 
implemented using a hardware accelerator. 
\par \par {\b GFX_HW_LINE_XOR:\par}
Indicates that the XOR version of the line() and vline() functions are 
implemented using a hardware accelerator. 
\par \par {\b GFX_HW_TRIANGLE:\par}
Indicates that the opaque mode triangle() function is implemented 
using a hardware accelerator. 
\par \par {\b GFX_HW_TRIANGLE_XOR:\par}
Indicates that the XOR version of the triangle() function is 
implemented using a hardware accelerator. 
\par \par {\b GFX_HW_GLYPH:\par}
Indicates that monochrome character expansion (for text drawing) is 
implemented using a hardware accelerator. 
\par \par {\b GFX_HW_VRAM_BLIT:\par}
Indicates that blitting from one part of the screen to another is 
implemented using a hardware accelerator. If this flag is set, 
blitting within the video memory will almost certainly be the fastest 
possible way to display an image, so it may be worth storing some of 
your more frequently used graphics in an offscreen portion of the 
video memory. 
\par \par {\b GFX_HW_VRAM_BLIT_MASKED:\par}
Indicates that the masked_blit() routine is capable of a hardware 
accelerated copy from one part of video memory to another, and that 
draw_sprite() will use a hardware copy when given a sub-bitmap of the 
screen or a video memory bitmap as the source image. If this flag is 
set, copying within the video memory will almost certainly be the 
fastest possible way to display an image, so it may be worth storing 
some of your more frequently used sprites in an offscreen portion of 
the video memory. 
\par \par Warning: if this flag is not set, masked_blit() and draw_sprite() will 
not work correctly when used with a video memory source image! You 
must only try to use these functions to copy within the video memory 
if they are supported in hardware. 
\par \par {\b GFX_HW_MEM_BLIT:\par}
Indicates that blitting from a memory bitmap onto the screen is being 
accelerated in hardware. 
\par \par {\b GFX_HW_MEM_BLIT_MASKED:\par}
Indicates that the masked_blit() and draw_sprite() functions are being 
accelerated in hardware when the source image is a memory bitmap and 
the destination is the physical screen. 
\par \par {\b GFX_HW_SYS_TO_VRAM_BLIT:\par}
Indicates that blitting from a system bitmap onto the screen is being 
accelerated in hardware. Note that some acceleration may be present 
even if this flag is not set, because system bitmaps can benefit from 
normal memory to screen blitting as well. This flag will only be set 
if system bitmaps have further acceleration above and beyond what is 
provided by GFX_HW_MEM_BLIT. 
\par \par {\b GFX_HW_SYS_TO_VRAM_BLIT_MASKED:\par}
Indicates that the masked_blit() and draw_sprite() functions are being 
accelerated in hardware when the source image is a system bitmap and 
the destination is the physical screen. Note that some acceleration 
may be present even if this flag is not set, because system bitmaps 
can benefit from normal memory to screen blitting as well. This flag 
will only be set if system bitmaps have further acceleration above and 
beyond what is provided by GFX_HW_MEM_BLIT_MASKED. 
\par \par {\b GFX_HW_VRAM_STRETCH_BLIT:\par}
Indicates that stretched blitting of video bitmaps onto the screen is 
implemented using hardware acceleration. 
\par \par {\b GFX_HW_SYS_STRETCH_BLIT:\par}
Indicates that stretched blitting of system bitmaps onto the screen is 
implemented using hardware acceleration. 
\par \par {\b GFX_HW_VRAM_STRETCH_BLIT_MASKED:\par}
Indicates that masked stretched blitting (including stretch_sprite) of 
video bitmaps onto the screen is implemented using hardware acceleration. 
NOTE: some display drivers may show artifacts when this function is used. 
If the image does not look correct try updating your video drivers. 
\par \par {\b GFX_HW_SYS_STRETCH_BLIT_MASKED:\par}
Indicates that masked stretched blitting (including stretch_sprite) of 
system bitmaps onto the screen is implemented using hardware acceleration. 
NOTE: some display drivers may show artefact's when this function is used. 
If the image does not look correct try updating your video drivers. 
\par \par Note: even if the capabilities information says that patterned drawing is 
supported by the hardware, it will not be possible for every size of 
pattern. VBE/AF only supports patterns up to 8x8 in size, so Allegro will 
fall back on the original non-accelerated drawing routines whenever you 
use a pattern larger than this. 
\par \par Note2: these hardware acceleration features will only take effect when 
you are drawing directly onto the screen bitmap, a video memory bitmap, 
or a sub-bitmap thereof. Accelerated hardware is most useful in a page 
flipping or triple buffering setup, and is unlikely to make any 
difference to the classic "draw onto a memory bitmap, then blit to the 
screen" system. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v enable_triple_buffer}enable_triple_buffer();\par }
{\li400 If the GFX_CAN_TRIPLE_BUFFER bit of the gfx_capabilities field is not 
set, you can attempt to enable it by calling this function. In particular 
if you are running in mode-X in a clean DOS environment, this routine 
will enable the timer retrace simulator, which will activate the triple 
buffering functions. 
\par \par Returns zero if triple buffering is enabled, -1 otherwise. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v scroll_screen}scroll_screen(int x, int y);\par }
{\li400 Attempts to scroll the hardware screen to display a different part of the 
virtual screen (initially it will be positioned at 0, 0, which is the top 
left corner). You can use this to move the screen display around in a 
large virtual screen space, or to page flip back and forth between two 
non-overlapping areas of the virtual screen. Note that to draw outside the 
original position in the screen bitmap you will have to alter the clipping 
rectangle with set_clip_rect(). 
\par \par Mode-X scrolling is reliable and will work on any card, other drivers may 
not work or not work reliably. See the platform-specific section of the docs 
for more information. 
\par \par Allegro will handle any necessary vertical retrace synchronisation when 
scrolling the screen, so you don't need to call vsync() before it. This 
means that scroll_screen() has the same time delay effects as vsync(). 
\par \par Returns zero on success. Returns non-zero if the graphics driver can't 
handle hardware scrolling or the virtual screen is not large enough. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v request_scroll}request_scroll(int x, int y);\par }
{\li400 This function is used for triple buffering. It requests a hardware scroll 
to the specified position, but returns immediately rather than waiting 
for a retrace. The scroll will then take place during the next vertical 
retrace, but you can carry on running other code in the meantime and use 
the poll_scroll() routine to detect when the flip has actually taken 
place. 
\par \par Triple buffering is only possible with certain drivers: you can look at the 
GFX_CAN_TRIPLE_BUFFER bit in the gfx_capabilities flag to see if it will 
work with the current driver. 
\par \par This function returns zero on success, non-zero otherwise. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v poll_scroll}poll_scroll();\par }
{\li400 This function is used for triple buffering. It checks the status of a 
hardware scroll previously initiated by the request_scroll() routine. 
\par \par Returns non-zero if it is still waiting to take place, and zero if the 
requested scroll has already happened. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v show_video_bitmap}show_video_bitmap(BITMAP *bitmap);\par }
{\li400 Attempts to page flip the hardware screen to display the specified video 
bitmap object, which must be the same size as the physical screen, and 
should have been obtained by calling the create_video_bitmap() function. 
\par \par Allegro will handle any necessary vertical retrace synchronisation when 
page flipping, so you don't need to call vsync() before it. This means 
that show_video_bitmap() has the same time delay effects as vsync() by 
default. This can be adjusted with the "disable_vsync" config key in the 
[graphics] section of allegro.cfg. Example: 
\par {\s1 \f1\fs18 
\par       int current_page;
\par       BITMAP *video_page[2];
\par       ...
\par       /* Create pages for page flipping */
\par       video_page[0] = create_video_bitmap(SCREEN_W, SCREEN_H);
\par       video_page[1] = create_video_bitmap(SCREEN_W, SCREEN_H);
\par       current_page = 0;
\par       ...
\par       /* draw the screen and flip pages */
\par       draw_screen(video_page[current_page]);
\par       show_video_bitmap(video_page[current_page]);
\par       current_page = (current_page+1)%2;
\par       ...\par}
\par Returns zero on success and non-zero on failure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v request_video_bitmap}request_video_bitmap(BITMAP *bitmap);\par }
{\li400 This function is used for triple buffering. It requests a page flip to 
display the specified video bitmap object, but returns immediately rather 
than waiting for a retrace. The flip will then take place during the next 
vertical retrace, but you can carry on running other code in the meantime 
and use the poll_scroll() routine to detect when the flip has actually 
taken place. Triple buffering is only possible on certain hardware: see 
the comments about request_scroll(). Example: 
\par {\s1 \f1\fs18 
\par       int current_page;
\par       BITMAP *video_page[3];
\par       ...
\par       /* Create pages for page flipping */
\par       video_page[0] = create_video_bitmap(SCREEN_W, SCREEN_H);
\par       video_page[1] = create_video_bitmap(SCREEN_W, SCREEN_H);
\par       video_page[2] = create_video_bitmap(SCREEN_W, SCREEN_H);
\par       current_page = 0;
\par       ...
\par       /* draw the screen and flip pages */
\par       draw_screen(video_page[current_page]);
\par       do \{
\par       \} while (poll_scroll());
\par       request_video_bitmap(video_page[current_page]);
\par       current_page = (current_page+1)%3;
\par       ...\par}
\par Returns zero on success and non-zero on failure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v vsync}vsync();\par }
{\li400 Waits for a vertical retrace to begin. The retrace happens when the 
electron beam in your monitor has reached the bottom of the screen and is 
moving back to the top ready for another scan. During this short period 
the graphics card isn't sending any data to the monitor, so you can do 
things to it that aren't possible at other times, such as altering the 
palette without causing flickering (snow). Allegro will automatically 
wait for a retrace before altering the palette or doing any hardware 
scrolling, though, so you don't normally need to bother with this 
function. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Bitmap objects}Bitmap objects\par }
Once you have selected a graphics mode, you can draw things onto the display 
via the `screen' bitmap. All the Allegro graphics routines draw onto BITMAP 
structures, which are areas of memory containing rectangular images, stored 
as packed byte arrays (in 8-bit modes one byte per pixel, in 15- and 16-bit 
modes two bytes per pixel, in 24-bit modes 3 bytes per pixel and in 32-bit 
modes 4 bytes per pixel). You can create and manipulate bitmaps in system 
RAM, or you can write to the special `screen' bitmap which represents the 
video memory in your graphics card. 
\par \par Read chapter "Direct access to video memory" for information on how to get 
direct access to the image memory in a bitmap. 
\par \par Allegro supports several different types of bitmaps: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 The `screen' bitmap, which represents the hardware video memory. Ultimately 
you have to draw onto this in order for your image to be visible. It is 
destroyed by any subsequent calls to set_gfx_mode(), so you should never 
attempt to destroy it yourself. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Memory bitmaps, which are located in system RAM and can be used to store 
graphics or as temporary drawing spaces for double buffered systems. These 
can be obtained by calling create_bitmap(), load_pcx(), or by loading a 
grabber datafile. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Sub-bitmaps. These share image memory with a parent bitmap (which can be 
the screen, a video or system bitmap, a memory bitmap, or another 
sub-bitmap), so drawing onto them will also change their parent. They can 
be of any size and located anywhere within the parent bitmap, and can have 
their own clipping rectangles, so they are a useful way of dividing a 
bitmap into several smaller units, eg. splitting a large virtual screen 
into multiple sections (see examples/exscroll.c). 
\par \pard \li400 \par Warning: Make sure not to destroy a bitmap before all of its sub-bitmaps, 
otherwise bad things will happen when you try to access one of these 
sub-bitmaps. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Video memory bitmaps. These are created by the create_video_bitmap() 
function, and are usually implemented as sub-bitmaps of the screen object. 
They must be destroyed by destroy_bitmap() before any subsequent calls to 
set_gfx_mode(). 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 System bitmaps. These are created by the create_system_bitmap() function, 
and are a sort of halfway house between memory and video bitmaps. They 
live in system memory, so you aren't limited by the amount of video ram in 
your card, but they are stored in a platform-specific format that may 
enable better hardware acceleration than is possible with a normal memory 
bitmap (see the GFX_HW_SYS_TO_VRAM_BLIT and GFX_HW_SYS_TO_VRAM_BLIT_MASKED 
flags in gfx_capabilities). System bitmaps must be accessed in the same way 
as video bitmaps, using the bank switch functions and bmp_write*() macros. 
Not every platform implements this type of bitmap: if they aren't 
available, create_system_bitmap() will function identically to 
create_bitmap(). They must be destroyed by destroy_bitmap() before any 
subsequent calls to set_gfx_mode(). 
\par}\pard \li0 \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b extern BITMAP *{\xe\v screen}screen;\par }
{\li400 Global pointer to a bitmap, sized VIRTUAL_W x VIRTUAL_H. This is created 
by set_gfx_mode(), and represents the hardware video memory. Only a part 
of this bitmap will actually be visible, sized SCREEN_W x SCREEN_H. 
Normally this is the top left corner of the larger virtual screen, so you 
can ignore the extra invisible virtual size of the bitmap if you aren't 
interested in hardware scrolling or page flipping. To move the visible 
window to other parts of the screen bitmap, call scroll_screen(). 
Initially the clipping rectangle will be limited to the physical screen 
size, so if you want to draw onto a larger virtual screen space outside 
this rectangle, you will need to adjust the clipping. 
\par \par For example, to draw a pixel onto the screen you would write: 
\par {\s1 \f1\fs18 
\par       putpixel(screen, x, y, color);
\par }\par Or to implement a double-buffered system: 
\par {\s1 \f1\fs18 
\par       /* Make a bitmap in RAM. */
\par       BITMAP *bmp = create_bitmap(320, 200);
\par       /* Clean the memory bitmap. */
\par       clear_bitmap(bmp);
\par       /* Draw onto the memory bitmap. */
\par       putpixel(bmp, x, y, color);
\par       /* Copy it to the screen. */
\par       blit(bmp, screen, 0, 0, 0, 0, 320, 200);\par}
\par Warning: be very careful when using this pointer at the same time as any 
bitmaps created by the create_video_bitmap() function (see the description 
of this function for more detailed information). And never try to destroy 
it with destroy_bitmap(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 #define {\xe\v SCREEN_W}SCREEN_W;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 #define {\xe\v SCREEN_H}SCREEN_H;\par }
{\li400 Global defines that return the width and height of the screen, or zero if 
the screen has not been initialised yet. Example: 
\par {\s1 \f1\fs18 
\par       char buf[100];
\par       ...
\par       uszprintf(buf, sizeof(buf),
\par                 "The screen size is %d x %d pixels",
\par                 SCREEN_W, SCREEN_H);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 #define {\xe\v VIRTUAL_W}VIRTUAL_W;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 #define {\xe\v VIRTUAL_H}VIRTUAL_H;\par }
{\li400 Global defines that return the width and height of the virtual screen, or 
zero if the screen has not been initialised yet. Example: 
\par {\s1 \f1\fs18 
\par       char buf[100];
\par       ...
\par       uszprintf(buf, sizeof(buf),
\par                 "The virtual screen size is %d x %d pixels",
\par                 SCREEN_W, SCREEN_H);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v create_bitmap}create_bitmap(int width, int height);\par }
{\li400 Creates a memory bitmap sized width by height. The bitmap will have 
clipping turned on, and the clipping rectangle set to the full size of the 
bitmap. The image memory will not be cleared, so it will probably contain 
garbage: you should clear the bitmap before using it. This routine always 
uses the global pixel format, as specified by calling set_color_depth(). 
The minimum height of the BITMAP must be 1 and width can't be negative. 
Example: 
\par {\s1 \f1\fs18 
\par       /* Create a 10 pixel tall bitmap, as wide as the screen. */
\par       BITMAP *bmp = create_bitmap(SCREEN_W, 10);
\par       if (!bmp)
\par          abort_on_error("Couldn't create bitmap!");
\par       /* Use the bitmap. */
\par       ...
\par       /* Destroy it when we don't need it any more. */
\par       destroy_bitmap(bmp);\par}
\par Returns a pointer to the created bitmap, or NULL if the bitmap could not 
be created. Remember to free this bitmap later to avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v create_bitmap_ex}create_bitmap_ex(int color_depth, int width, int height);\par }
{\li400 Creates a bitmap in a specific color depth (8, 15, 16, 24 or 32 bits per 
pixel). Example: 
\par {\s1 \f1\fs18 
\par       /* Create screen sized bitmap in 32 bits per pixel. */
\par       BITMAP *bmp = create_bitmap_ex(32, SCREEN_W, SCREEN_H);
\par       if (!bmp)
\par          abort_on_error("Couldn't create bitmap!");
\par       /* Use the bitmap. */
\par       ...
\par       /* Destroy it when we don't need it any more. */
\par       destroy_bitmap(bmp);\par}
\par Returns a pointer to the created bitmap, or NULL if the bitmap could not 
be created. Remember to free this bitmap later to avoid memory leaks. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v create_sub_bitmap}create_sub_bitmap(BITMAP *parent, int x, y, width, height);\par }
{\li400 Creates a sub-bitmap, ie. a bitmap sharing drawing memory with a 
pre-existing bitmap, but possibly with a different size and clipping 
settings. When creating a sub-bitmap of the mode-X screen, the x position 
must be a multiple of four. The sub-bitmap width and height can extend 
beyond the right and bottom edges of the parent (they will be clipped), 
but the origin point must lie within the parent region. 
\par \par Returns a pointer to the created sub bitmap, or NULL if the sub bitmap 
could not be created. Remember to free the sub bitmap before freeing 
the parent bitmap to avoid memory leaks and potential crashes accessing 
memory which has been freed. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v create_video_bitmap}create_video_bitmap(int width, int height);\par }
{\li400 Allocates a video memory bitmap of the specified size. This can be used 
to allocate offscreen video memory for storing source graphics ready for 
a hardware accelerated blitting operation, or to create multiple video 
memory pages which can then be displayed by calling show_video_bitmap(). 
Read the introduction of this chapter for a comparison with other types 
of bitmaps and other specific details. 
\par \par Warning: video memory bitmaps are usually allocated from the same space 
as the screen bitmap, so they may overlap with it; it is therefore not 
a good idea to use the global screen at the same time as any surfaces 
returned by this function. 
\par \par Returns a pointer to the bitmap on success, or NULL if you have run out 
of video ram. Remember to destroy this bitmap before any subsequent 
call to set_gfx_mode(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v create_system_bitmap}create_system_bitmap(int width, int height);\par }
{\li400 Allocates a system memory bitmap of the specified size. Read the 
introduction of this chapter for a comparison with other types of bitmaps 
and other specific details. 
\par \par Returns a pointer to the bitmap on success, NULL otherwise. Remember to 
destroy this bitmap before any subsequent call to set_gfx_mode(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v destroy_bitmap}destroy_bitmap(BITMAP *bitmap);\par }
{\li400 Destroys a memory bitmap, sub-bitmap, video memory bitmap, or system 
bitmap when you are finished with it. If you pass a NULL pointer this 
function won't do anything. See above for the restrictions as to when you 
are allowed to destroy the various types of bitmaps. 
\par \par The bitmap must not have a mouse cursor shown on it at the time it is 
destroyed. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v lock_bitmap}lock_bitmap(BITMAP *bitmap);\par }
{\li400 Under DOS, locks all the memory used by a bitmap. You don't normally need 
to call this function unless you are doing very weird things in your 
program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v bitmap_color_depth}bitmap_color_depth(BITMAP *bmp);\par }
{\li400 Returns the color depth of the specified bitmap (8, 15, 16, 24, or 32). 
Example: 
\par {\s1 \f1\fs18 
\par       switch (bitmap_color_depth(screen)) \{
\par          case 8:
\par             /* Access screen using optimized 8-bit code. */
\par             break;
\par          default:
\par             /* Use generic slow functions. */
\par             break;
\par       \}\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v bitmap_mask_color}bitmap_mask_color(BITMAP *bmp);\par }
{\li400 Returns the mask color for the specified bitmap (the value which is 
skipped when drawing sprites). For 256-color bitmaps this is zero, and 
for truecolor bitmaps it is bright pink (maximum red and blue, zero 
green). A frequent use of this function is to clear a bitmap with the mask 
color so you can later use this bitmap with masked_blit() or 
draw_sprite() after drawing other stuff on it. Example: 
\par {\s1 \f1\fs18 
\par       /* Replace mask color with another color. */
\par       for (y = 0; y h; y++)
\par          for (x = 0; x w; x++)
\par             if (getpixel(bmp, x, y) == bitmap_mask_color(bmp))
\par                putpixel(bmp, x, y, another_color);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v is_same_bitmap}is_same_bitmap(BITMAP *bmp1, BITMAP *bmp2);\par }
{\li400 Returns TRUE if the two bitmaps describe the same drawing surface, ie. 
the pointers are equal, one is a sub-bitmap of the other, or they are 
both sub-bitmaps of a common parent. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v is_planar_bitmap}is_planar_bitmap(BITMAP *bmp);\par }
{\li400 Returns TRUE if bmp is a planar (mode-X or Xtended mode) screen bitmap. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v is_linear_bitmap}is_linear_bitmap(BITMAP *bmp);\par }
{\li400 Returns TRUE if bmp is a linear bitmap, i.e. a bitmap that can be accessed 
linearly within each scanline (for example a memory bitmap, the DOS VGA 
or SVGA screen, Windows bitmaps, etc). Linear bitmaps can be used with the 
_putpixel(), _getpixel(), bmp_write_line(), and bmp_read_line() functions. 
\par \par Historically there were only linear and planar bitmaps for Allegro, so 
is_linear_bitmap() is actually an alias for !is_planar_bitmap(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v is_memory_bitmap}is_memory_bitmap(BITMAP *bmp);\par }
{\li400 Returns TRUE if bmp is a memory bitmap, ie. it was created by calling 
create_bitmap() or loaded from a grabber datafile or image file. Memory 
bitmaps can be accessed directly via the line pointers in the bitmap 
structure, eg. bmp->line[y][x] = color. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v is_screen_bitmap}is_screen_bitmap(BITMAP *bmp);\par }
{\li400 Returns TRUE if bmp is the screen bitmap, or a sub-bitmap of the screen. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v is_video_bitmap}is_video_bitmap(BITMAP *bmp);\par }
{\li400 Returns TRUE if bmp is the screen bitmap, a video memory bitmap, or a 
sub-bitmap of either. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v is_system_bitmap}is_system_bitmap(BITMAP *bmp);\par }
{\li400 Returns TRUE if bmp is a system bitmap object, or a sub-bitmap of one. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v is_sub_bitmap}is_sub_bitmap(BITMAP *bmp);\par }
{\li400 Returns TRUE if bmp is a sub-bitmap. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v acquire_bitmap}acquire_bitmap(BITMAP *bmp);\par }
{\li400 Acquires the specified video bitmap prior to drawing onto it. You never need 
to call the function explicitly as it is low level, and will only give you a 
speed up if you know what you are doing. Using it wrongly may cause slowdown, 
or even lock up your program. 
\par \par Note: You do never need to use acquire_bitmap on a memory bitmap, i.e. a 
normal bitmap created with create_bitmap. It will simply do nothing in that 
case. 
\par \par It still can be useful, because e.g. under the current DirectDraw driver of 
Allegro, most drawing functions need to lock a video bitmap before drawing to 
it. But doing this is very slow, so you will get much better performance if 
you acquire the screen just once at the start of your main redraw function, 
then call multiple drawing operations which need the bitmap locked, and only 
release it when done. 
\par \par Multiple acquire calls may be nested, but you must make sure to match up the 
acquire_bitmap and release_bitmap calls. Be warned that DirectX and X11 
programs activate a mutex lock whenever a surface is locked, which prevents 
them from getting any input messages, so you must be sure to release all your 
bitmaps before using any timer, keyboard, or other non-graphics routines! 
\par \par Note that if you are using hardware accelerated VRAM->VRAM functions, you 
should not call acquire_bitmap(). Such functions need an unlocked target 
bitmap under DirectX, so there is now just the opposite case from before - if 
the bitmap is already locked with acquire_bitmap, the drawing 
operation has to unlock it. 
\par \par Note: For backwards compatibility, the unlocking behavior of such functions 
is permanent. That is, if you call acquire_bitmap first, then call e.g. an 
accelerated blit, the DirectX bitmap will be unlocked internally (it won't 
affect the nesting counter of acquire/release calls). 
\par \par There is no clear cross-platform way in this Allegro version to know which 
drawing operations need a locked/unlocked state. For example a normal 
rectfill most probably is accelerated under DirectX, and therefore needs the 
screen unlocked, but an XOR rectfill, or one with blending activated, most 
probably is not, and therefore locks the screen. And while the DirectX driver 
will do automatic unlocking, there is no such thing under X11, where the 
function is used to synchronize X11 calls from different threads. Your best 
bet is to never use acquire_bitmap - changes are you are doing something in 
the wrong way if you think you need it. 
\par \par Warning: This function can be very dangerous to use, since the whole program 
may get locked while the bitmap is locked. So the lock should only be held 
for a short time, and you should not call anything but drawing operations 
onto the locked video bitmap while a lock is in place. Especially don't call 
things like show_mouse (or scare_mouse which calls that) or readkey, since 
it will most likely deadlock your entire program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v release_bitmap}release_bitmap(BITMAP *bmp);\par }
{\li400 Releases a bitmap that was previously locked by calling acquire_bitmap(). 
If the bitmap was locked multiple times, you must release it the same 
number of times before it will truly be unlocked. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v acquire_screen}acquire_screen();\par }
{\li400 Shortcut version of acquire_bitmap(screen); 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v release_screen}release_screen();\par }
{\li400 Shortcut version of release_bitmap(screen); 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_clip_rect}set_clip_rect(BITMAP *bitmap, int x1, int y1, int x2, int y2);\par }
{\li400 Each bitmap has an associated clipping rectangle, which is the area of 
the image that it is OK to draw onto. Nothing will be drawn to positions 
outside this space. This function sets the clipping rectangle for the 
specified bitmap. Pass the coordinates of the top-left and bottom-right 
corners of the clipping rectangle in this order; these are both inclusive, 
i.e. set_clip_rect(bitmap, 16, 16, 32, 32) will allow drawing to (16, 16) 
and (32, 32), but not to (15, 15) and (33, 33). 
\par \par Drawing operations will be performed (at least partially) on the bitmap as 
long as the first coordinates of its clipping rectangle are not greater 
than the second coordinates and its intersection with the actual image 
is non-empty. If either condition is not fulfilled, drawing will be turned 
off for the bitmap, e.g. 
\par {\s1 \f1\fs18 
\par       set_clip_rect(bmp, 0, 0, -1, -1); /* disable drawing on bmp */\par}
\par Note that passing "out-of-bitmap" coordinates is allowed, but they are 
likely to be altered (and so the coordinates returned by get_clip_rect() 
will be different). However, such modifications are guaranteed to preserve 
the external effect of the clipping rectangle, that is not to modify the 
actual area of the image that it is OK to draw onto. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_clip_rect}get_clip_rect(BITMAP *bitmap, int *x1, int *y1, int *x2, int *y2);\par }
{\li400 Returns the clipping rectangle for the specified bitmap. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v add_clip_rect}add_clip_rect(BITMAP *bitmap, int x1, int y1, int x2, int y2);\par }
{\li400 Sets the clipping rectangle of the specified bitmap as the intersection of 
its current clipping rectangle and the rectangle described by the four 
coordinates. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_clip_state}set_clip_state(BITMAP *bitmap, int state)\par }
{\li400 Turns on (if state is non-zero) or off (if state is zero) clipping for the 
specified bitmap. Turning clipping off may slightly speed up some drawing 
operations (usually a negligible  difference, although every little helps) 
but will result in your program dying a horrible death if you try to draw 
beyond the edges of the bitmap. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_clip_state}get_clip_state(BITMAP *bitmap)\par }
{\li400 Returns non-zero if clipping is turned on for the specified bitmap and 
zero otherwise. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v is_inside_bitmap}is_inside_bitmap(BITMAP *bmp, int x, int y, int clip);\par }
{\li400 Returns non-zero if point (x, y) lies inside the bitmap. If `clip' is 
non-zero, the function compares the coordinates with the clipping 
rectangle, that is it returns non-zero if the point lies inside the 
clipping rectangle or if clipping is disabled for the bitmap. If `clip' 
is zero, the function compares the coordinates with the actual dimensions 
of the bitmap. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Loading image files}Loading image files\par }
Warning: when using truecolor images, you should always set the graphics 
mode before loading any bitmap data! Otherwise the pixel format (RGB or BGR) 
will not be known, so the file may be converted wrongly. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v load_bitmap}load_bitmap(const char *filename, RGB *pal);\par }
{\li400 Loads a bitmap from a file. The palette data will be stored in the second 
parameter, which should be an array of 256 RGB structures. At present this 
function supports BMP, LBM, PCX, and TGA files, determining the type from 
the file extension. 
\par \par If the file contains a truecolor image, you must set the video mode or 
call set_color_conversion() before loading it. In this case, if the 
destination color depth is 8-bit, the palette will be generated by calling 
generate_optimized_palette() on the bitmap; otherwise, the returned 
palette will be generated by calling generate_332_palette(). 
\par \par The pal argument may be NULL. In this case, the palette data are simply 
not returned. Additionally, if the file is a truecolor image and the 
destination color depth is 8-bit, the color conversion process will use 
the current palette instead of generating an optimized one. 
\par \par Example: 
\par {\s1 \f1\fs18 
\par       BITMAP *bmp;
\par       PALETTE palette;
\par       ...
\par       bmp = load_bitmap("image.pcx", palette);
\par       if (!bmp)
\par          abort_on_error("Couldn't load image.pcx!");
\par       ...
\par       destroy_bitmap(bmp);\par}
\par Returns a pointer to the bitmap or NULL on error. Remember that you are 
responsible for destroying the bitmap when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v load_bmp}load_bmp(const char *filename, RGB *pal);\par }
{\li400 Loads an 8-bit, 16-bit, 24-bit or 32-bit Windows or OS/2 BMP file. 
\par \par Returns a pointer to the bitmap or NULL on error. Remember that you are 
responsible for destroying the bitmap when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v load_bmp_pf}load_bmp_pf(PACKFILE *f, RGB *pal);\par }
{\li400 A version of load_bmp() which reads from a packfile. Example: 
\par {\s1 \f1\fs18 
\par       PACKFILE *packfile;
\par       BITMAP *bmp;
\par 
\par       packfile = pack_fopen("mybitmap.bmp", F_READ);
\par       if (!packfile)
\par          abort_on_error("Couldn't open mybitmap.bmp");
\par          
\par       bmp = load_bmp_pf(packfile, pal);
\par       if (!bmp)
\par          abort_on_error("Error loading mybitmap.bmp");\par}
\par Returns a pointer to the bitmap or NULL on error. Remember that you are 
responsible for destroying the bitmap when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v load_lbm}load_lbm(const char *filename, RGB *pal);\par }
{\li400 Loads a 256-color IFF ILBM/PBM file. 
\par \par Returns a pointer to the bitmap or NULL on error. Remember that you are 
responsible for destroying the bitmap when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v load_pcx}load_pcx(const char *filename, RGB *pal);\par }
{\li400 Loads a 256-color or 24-bit truecolor PCX file. 
\par \par Returns a pointer to the bitmap or NULL on error. Remember that you are 
responsible for destroying the bitmap when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v load_pcx_pf}load_pcx_pf(PACKFILE *f, RGB *pal);\par }
{\li400 A version of load_pcx() which reads from a packfile. Example: 
\par {\s1 \f1\fs18 
\par       PACKFILE *packfile;
\par       BITMAP *bmp;
\par 
\par       packfile = pack_fopen("mybitmap.pcx", F_READ);
\par       if (!packfile)
\par          abort_on_error("Couldn't open mybitmap.pcx");
\par          
\par       bmp = load_bmp_pf(packfile, pal);
\par       if (!bmp)
\par          abort_on_error("Error loading mybitmap.pcx");\par}
\par Returns a pointer to the bitmap or NULL on error. Remember that you are 
responsible for destroying the bitmap when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v load_tga}load_tga(const char *filename, RGB *pal);\par }
{\li400 Loads a 256-color, 15-bit hicolor, 24-bit truecolor, or 32-bit 
truecolor+alpha TGA file. 
\par \par Returns a pointer to the bitmap or NULL on error. Remember that you are 
responsible for destroying the bitmap when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v load_tga_pf}load_tga_pf(PACKFILE *f, RGB *pal);\par }
{\li400 A version of load_tga() which reads from a packfile. Example: 
\par {\s1 \f1\fs18 
\par       PACKFILE *packfile;
\par       BITMAP *bmp;
\par 
\par       packfile = pack_fopen("mybitmap.tga", F_READ);
\par       if (!packfile)
\par          abort_on_error("Couldn't open mybitmap.tga");
\par          
\par       bmp = load_bmp_pf(packfile, pal);
\par       if (!bmp)
\par          abort_on_error("Error loading mybitmap.tga");\par}
\par Returns a pointer to the bitmap or NULL on error. Remember that you are 
responsible for destroying the bitmap when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v save_bitmap}save_bitmap(const char *filename, BITMAP *bmp, const RGB *pal);\par }
{\li400 Writes a bitmap into a file, using the specified palette, which should be 
an array of 256 RGB structures. The output format is determined from the 
filename extension: at present this function supports BMP, PCX and TGA 
formats. 
\par \par Two things to watch out for: on some video cards it may be faster to copy 
the screen to a memory bitmap and save the latter, and if you use this to 
dump the screen into a file you may end up with an image much larger than 
you were expecting, because Allegro often creates virtual screens larger 
than the visible screen. You can get around this by using a sub-bitmap to 
specify which part of the screen to save, eg: 
\par {\s1 \f1\fs18 
\par       BITMAP *bmp;
\par       PALETTE pal;
\par       ...
\par       get_palette(pal);
\par       bmp = create_sub_bitmap(screen, 0, 0, SCREEN_W, SCREEN_H);
\par       save_bitmap("dump.pcx", bmp, pal);
\par       destroy_bitmap(bmp);\par}
\par Returns non-zero on error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v save_bmp}save_bmp(const char *filename, BITMAP *bmp, const RGB *pal);\par }
{\li400 Writes a bitmap into a 256-color or 24-bit truecolor BMP file. 
\par \par Returns non-zero on error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v save_bmp_pf}save_bmp_pf(PACKFILE *f, BITMAP *bmp, RGB *pal);\par }
{\li400 A version of save_bmp which writes to a packfile. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v save_pcx}save_pcx(const char *filename, BITMAP *bmp, const RGB *pal);\par }
{\li400 Writes a bitmap into a 256-color or 24-bit truecolor PCX file. 
\par \par Returns non-zero on error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v save_pcx_pf}save_pcx_pf(PACKFILE *f, BITMAP *bmp, RGB *pal);\par }
{\li400 A version of save_pcx which writes to a packfile. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v save_tga}save_tga(const char *filename, BITMAP *bmp, const RGB *pal);\par }
{\li400 Writes a bitmap into a 256-color, 15-bit hicolor, 24-bit truecolor, or 
32-bit truecolor+alpha TGA file. 
\par \par Returns non-zero on error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v save_tga_pf}save_tga_pf(PACKFILE *f, BITMAP *bmp, RGB *pal);\par }
{\li400 A version of save_tga which writes to a packfile. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v register_bitmap_file_type}register_bitmap_file_type(const char *ext, BITMAP *(*load)(const char *filename, RGB *pal), int (*save)(const char *filename, BITMAP *bmp, const RGB *pal));\par }
{\li400 Informs the load_bitmap() and save_bitmap() functions of a new file type, 
providing routines to read and write images in this format (either 
function may be NULL). The functions you supply must follow the same 
prototype as load_bitmap() and save_bitmap(). Example: 
\par {\s1 \f1\fs18 
\par       BITMAP *load_dump(const char *filename, RGB *pal)
\par       \{
\par          ...
\par       \}
\par       
\par       int save_dump(const char *filename, BITMAP *bmp, const RGB *pal)
\par       \{
\par          ...
\par       \}
\par 
\par          register_bitmap_file_type("dump", load_dump, save_dump);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_color_conversion}set_color_conversion(int mode);\par }
{\li400 Specifies how to convert images between the various color depths when 
reading graphics from external bitmap files or datafiles. The mode is a 
bitmask specifying which types of conversion are allowed. If the 
appropriate bit is set, data will be converted into the current pixel 
format (selected by calling the set_color_depth() function), otherwise it 
will be left in the same format as the disk file, leaving you to convert 
it manually before the graphic can be displayed. The default mode is 
total conversion, so that all images will be loaded in the appropriate 
format for the current video mode. Valid bit flags are: 
\par {\s1 \f1\fs18 
\par       COLORCONV_NONE                // disable all format
\par                                     // conversions
\par       COLORCONV_8_TO_15             // expand 8-bit to 15-bit
\par       COLORCONV_8_TO_16             // expand 8-bit to 16-bit
\par       COLORCONV_8_TO_24             // expand 8-bit to 24-bit
\par       COLORCONV_8_TO_32             // expand 8-bit to 32-bit
\par       COLORCONV_15_TO_8             // reduce 15-bit to 8-bit
\par       COLORCONV_15_TO_16            // expand 15-bit to 16-bit
\par       COLORCONV_15_TO_24            // expand 15-bit to 24-bit
\par       COLORCONV_15_TO_32            // expand 15-bit to 32-bit
\par       COLORCONV_16_TO_8             // reduce 16-bit to 8-bit
\par       COLORCONV_16_TO_15            // reduce 16-bit to 15-bit
\par       COLORCONV_16_TO_24            // expand 16-bit to 24-bit
\par       COLORCONV_16_TO_32            // expand 16-bit to 32-bit
\par       COLORCONV_24_TO_8             // reduce 24-bit to 8-bit
\par       COLORCONV_24_TO_15            // reduce 24-bit to 15-bit
\par       COLORCONV_24_TO_16            // reduce 24-bit to 16-bit
\par       COLORCONV_24_TO_32            // expand 24-bit to 32-bit
\par       COLORCONV_32_TO_8             // reduce 32-bit RGB to 8-bit
\par       COLORCONV_32_TO_15            // reduce 32-bit RGB to 15-bit
\par       COLORCONV_32_TO_16            // reduce 32-bit RGB to 16-bit
\par       COLORCONV_32_TO_24            // reduce 32-bit RGB to 24-bit
\par       COLORCONV_32A_TO_8            // reduce 32-bit RGBA to 8-bit
\par       COLORCONV_32A_TO_15           // reduce 32-bit RGBA to 15-bit
\par       COLORCONV_32A_TO_16           // reduce 32-bit RGBA to 16-bit
\par       COLORCONV_32A_TO_24           // reduce 32-bit RGBA to 24-bit
\par       COLORCONV_DITHER_PAL          // dither when reducing to 8-bit
\par       COLORCONV_DITHER_HI           // dither when reducing to
\par                                     // hicolor
\par       COLORCONV_KEEP_TRANS          // keep original transparency
\par }\par For convenience, the following macros can be used to select common 
combinations of these flags: 
\par {\s1 \f1\fs18 
\par       COLORCONV_EXPAND_256          // expand 256-color to hi/truecolor
\par       COLORCONV_REDUCE_TO_256       // reduce hi/truecolor to 256-color
\par       COLORCONV_EXPAND_15_TO_16     // expand 15-bit hicolor to 16-bit
\par       COLORCONV_REDUCE_16_TO_15     // reduce 16-bit hicolor to 15-bit
\par       COLORCONV_EXPAND_HI_TO_TRUE   // expand 15/16-bit to 24/32-bit
\par       COLORCONV_REDUCE_TRUE_TO_HI   // reduce 24/32-bit to 15/16-bit
\par       COLORCONV_24_EQUALS_32        // convert between 24- and 32-bit
\par       COLORCONV_TOTAL               // everything to current format
\par       COLORCONV_PARTIAL             // convert 15 <-> 16-bit and
\par                                     // 24 <-> 32-bit
\par       COLORCONV_MOST                // all but hi/truecolor <-> 256
\par       COLORCONV_DITHER              // dither during all color reductions
\par       COLORCONV_KEEP_ALPHA          // convert everything to current format
\par                                     // unless it would lose alpha information
\par }\par If you enable the COLORCONV_DITHER flag, dithering will be performed 
whenever truecolor graphics are converted into a hicolor or paletted 
format, including by the blit() function, and any automatic conversions 
that take place while reading graphics from disk. This can produce much 
better looking results, but is obviously slower than a direct conversion. 
\par \par If you intend using converted bitmaps with functions like masked_blit() 
or draw_sprite(), you should specify the COLORCONV_KEEP_TRANS flag. It 
will ensure that the masked areas in the bitmap before and after the 
conversion stay exactly the same, by mapping transparent colors to each 
other and adjusting colors which would be converted to the transparent 
color otherwise. It affects every blit() operation between distinct pixel 
formats and every automatic conversion. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_color_conversion}get_color_conversion();\par }
{\li400 Returns the current color conversion mode. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Palette routines}Palette routines\par }
All the Allegro drawing functions use integer parameters to represent 
colors. In truecolor resolutions these numbers encode the color directly as 
a collection of red, green, and blue bits, but in a regular 256-color mode 
the values are treated as indexes into the current palette, which is a table 
listing the red, green and blue intensities for each of the 256 possible 
colors. 
\par \par Palette entries are stored in an RGB structure, which contains red, green 
and blue intensities in the VGA hardware format, ranging from 0-63, and is 
defined as: 
\par {\s1 \f1\fs18 
\par    typedef struct RGB
\par    \{
\par       unsigned char r, g, b;
\par    \} RGB;
\par }\par It contains an additional field for the purpose of padding but you should 
not usually care about it. For example: 
\par {\s1 \f1\fs18 
\par    RGB black = \{ 0,  0,  0  \};
\par    RGB white = \{ 63, 63, 63 \};
\par    RGB green = \{ 0,  63, 0  \};
\par    RGB grey  = \{ 32, 32, 32 \};
\par }\par The type PALETTE is defined to be an array of PAL_SIZE RGB structures, where 
PAL_SIZE is a preprocessor constant equal to 256. 
\par \par You may notice that a lot of the code in Allegro spells 'palette' as 
'pallete'. This is because the headers from my old Mark Williams compiler on 
the Atari spelt it with two l's, so that is what I'm used to. Allegro will 
happily accept either spelling, due to some #defines in allegro/alcompat.h 
(which can be turned off by defining the ALLEGRO_NO_COMPATIBILITY symbol 
before including Allegro headers). 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_color}set_color(int index, const RGB *p);\par }
{\li400 Sets the specified palette entry to the specified RGB triplet. Unlike the 
other palette functions this doesn't do any retrace synchronisation, so 
you should call vsync() before it to prevent snow problems. Example: 
\par {\s1 \f1\fs18 
\par       RGB rgb;
\par       ...
\par       vsync();
\par       set_color(192, &rgb);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v _set_color}_set_color(int index, const RGB *p);\par }
{\li400 This is an inline version of set_color(), intended for use in the 
vertical retrace simulator callback function (retrace_proc, which is now 
deprecated). 
\par \par If you really must use _set_color from retrace_proc, note that it should 
only be used under DOS, in VGA mode 13h and mode-X. Some SVGA chipsets 
aren't VGA compatible (set_color() and set_palette() will use VESA calls on 
these cards, but _set_color() doesn't know about that). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_palette}set_palette(const PALETTE p);\par }
{\li400 Sets the entire palette of 256 colors. You should provide an array of 256 
RGB structures. Unlike set_color(), there is no need to call vsync() 
before this function. Example: 
\par {\s1 \f1\fs18 
\par       BITMAP *bmp;
\par       PALETTE palette;
\par       ...
\par       bmp = load_bitmap(filename, palette);
\par       if (!bmp)
\par          abort_on_error("Couldn't load bitmap!");
\par       set_palette(palette);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_palette_range}set_palette_range(const PALETTE p, int from, int to, int vsync);\par }
{\li400 Sets the palette entries between from and to (inclusive: pass 0 and 255 
to set the entire palette). If vsync is set it waits for the vertical 
retrace, otherwise it sets the colors immediately. Example: 
\par {\s1 \f1\fs18 
\par       PALETTE palette;
\par       ...
\par       /* Modify the first 16 entries. */
\par       change_first_16_colors(palette);
\par       /* Now update them waiting for vsync. */
\par       set_palette_range(palette, 0, 15, 1);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_color}get_color(int index, RGB *p);\par }
{\li400 Retrieves the specified palette entry. Example: 
\par {\s1 \f1\fs18 
\par       RGB color;
\par       ...
\par       get_color(11, &color);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_palette}get_palette(PALETTE p);\par }
{\li400 Retrieves the entire palette of 256 colors. You should provide an array 
of 256 RGB structures to store it in. Example: 
\par {\s1 \f1\fs18 
\par       PALETTE pal;
\par       ...
\par       get_palette(pal);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_palette_range}get_palette_range(PALETTE p, int from, int to);\par }
{\li400 Retrieves the palette entries between from and to (inclusive: pass 0 and 
255 to get the entire palette). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v fade_interpolate}fade_interpolate(const PALETTE source, const PALETTE dest, PALETTE output, int pos, int from, int to);\par }
{\li400 Calculates a temporary palette part way between source and dest, 
returning it in the output parameter. The position between the two 
extremes is specified by the pos value: 0 returns an exact copy of 
source, 64 returns dest, 32 returns a palette half way between the two, 
etc. This routine only affects colors between from and to (inclusive: 
pass 0 and 255 to interpolate the entire palette). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v fade_from_range}fade_from_range(const PALETTE source, const PALETTE dest, int speed, int from, int to);\par }
{\li400 Gradually fades a part of the palette from the source palette to the dest 
palette. The speed is from 1 (the slowest) up to 64 (instantaneous). This 
routine only affects colors between from and to (inclusive: pass 0 and 
255 to fade the entire palette). 
\par \par Note that this function will block your game while the fade is in effect, 
and it won't work right visually if you are not in an 8 bit color depth 
resolution. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v fade_in_range}fade_in_range(const PALETTE p, int speed, int from, int to);\par }
{\li400 Gradually fades a part of the palette from a black screen to the 
specified palette. The speed is from 1 (the slowest) up to 64 
(instantaneous). This routine only affects colors between from and to 
(inclusive: pass 0 and 255 to fade the entire palette). 
\par \par Note that this function will block your game while the fade is in effect, 
and it won't work right visually if you are not in an 8 bit color depth 
resolution. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v fade_out_range}fade_out_range(int speed, int from, int to);\par }
{\li400 Gradually fades a part of the palette from the current palette to a black 
screen. The speed is from 1 (the slowest) up to 64 (instantaneous). This 
routine only affects colors between from and to (inclusive: pass 0 and 
255 to fade the entire palette). 
\par \par Note that this function will block your game while the fade is in effect, 
and it won't work right visually if you are not in an 8 bit color depth 
resolution. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v fade_from}fade_from(const PALETTE source, const PALETTE dest, int speed);\par }
{\li400 Fades gradually from the source palette to the dest palette. The speed is 
from 1 (the slowest) up to 64 (instantaneous). 
\par \par Note that this function will block your game while the fade is in effect, 
and it won't work right visually if you are not in an 8 bit color depth 
resolution. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v fade_in}fade_in(const PALETTE p, int speed);\par }
{\li400 Fades gradually from a black screen to the specified palette. The speed 
is from 1 (the slowest) up to 64 (instantaneous). 
\par \par Note that this function will block your game while the fade is in effect, 
and it won't work right visually if you are not in an 8 bit color depth 
resolution. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v fade_out}fade_out(int speed);\par }
{\li400 Fades gradually from the current palette to a black screen. The speed is 
from 1 (the slowest) up to 64 (instantaneous). 
\par \par Note that this function will block your game while the fade is in effect, 
and it won't work right visually if you are not in an 8 bit color depth 
resolution. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v select_palette}select_palette(const PALETTE p);\par }
{\li400 Ugly hack for use in various dodgy situations where you need to convert 
between paletted and truecolor image formats. Sets the internal palette 
table in the same way as the set_palette() function, so the conversion 
will use the specified palette, but without affecting the display 
hardware in any way. The previous palette settings are stored in an 
internal buffer, and can be restored by calling unselect_palette(). If 
you call select_palette() again, however, the internal buffer will be 
overwritten. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v unselect_palette}unselect_palette();\par }
{\li400 Restores the palette tables that were in use before the last call to 
select_palette(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v generate_332_palette}generate_332_palette(PALETTE pal);\par }
{\li400 Constructs a fake truecolor palette, using three bits for red and green 
and two for the blue. The load_bitmap() function fills the palette 
parameter with this if the file does not contain a palette itself (ie. you 
are reading a truecolor bitmap). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v generate_optimized_palette}generate_optimized_palette(BITMAP *bmp, PALETTE pal, const char rsvd[PAL_SIZE]);\par }
{\li400 Generates a 256-color palette suitable for making a reduced color version 
of the specified truecolor image. The rsvd parameter points to a table 
indicating which colors it is allowed to modify: zero for free colors 
which may be set to whatever the optimiser likes, negative values for 
reserved colors which cannot be used, and positive values for fixed 
palette entries that must not be changed, but can be used in the 
optimisation. 
\par \par Returns the number of different colors recognised in the provided bitmap, 
zero if the bitmap is not a truecolor image or there wasn't enough memory 
to perform the operation, and negative if there was any internal error in 
the color reduction code. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern PALETTE {\xe\v default_palette}default_palette;\par }
{\li400 The default IBM BIOS palette. This will be automatically selected 
whenever you set a new graphics mode. The palette contains 16 basic 
colors plus many gradients between them. If you want to see the values, 
you can write a small Allegro program which saves a screenshot with this 
palette, or open the grabber tool provided with Allegro and create a new 
palette object, which will use this palette by default. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern PALETTE {\xe\v black_palette}black_palette;\par }
{\li400 A palette containing solid black colors, used by the fade routines. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern PALETTE {\xe\v desktop_palette}desktop_palette;\par }
{\li400 The palette used by the Atari ST low resolution desktop. I'm not quite 
sure why this is still here, except that the grabber and test programs 
use it. It is probably the only Atari legacy code left in Allegro, and it 
would be a shame to remove it :-) 
\par \par The contents of this palette are 16 colors repeated 16 times. Color entry 
zero is equal to color entry 16, which is equal to color entry 24, etc. 
\par {\s1 \f1\fs18 
\par        Index      Color       RGB values
\par          0     White          63  63  63
\par          1     Red            63   0   0
\par          2     Green           0  63   0
\par          3     Yellow         63  63   0
\par          4     Blue            0   0  63
\par          5     Pink           63   0  63
\par          6     Cyan            0  63  63
\par          7     Grey           16  16  16
\par          8     Light grey     31  31  31
\par          9     Light red      63  31  31
\par         10     Light green    31  63  31
\par         11     Light yellow   63  63  31
\par         12     Light blue     31  31  63
\par         13     Light pink     63  31  63
\par         14     Light cyan     31  63  63
\par         15     Black           0   0   0\par}
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Truecolor pixel formats}Truecolor pixel formats\par }
In a truecolor video mode the red, green, and blue components for each pixel 
are packed directly into the color value, rather than using a palette lookup 
table. In a 15-bit mode there are 5 bits for each color, in 16-bit modes 
there are 5 bits each of red and blue and six bits of green, and both 24 and 
32-bit modes use 8 bits for each color (the 32-bit pixels simply have an 
extra padding byte to align the data nicely). The layout of these components 
can vary depending on your hardware, but will generally either be RGB or 
BGR. Since the layout is not known until you select the video mode you will 
be using, you must call set_gfx_mode() before using any of the following 
routines! 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 int {\xe\v makecol8}makecol8(int r, int g, int b);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v makecol15}makecol15(int r, int g, int b);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v makecol16}makecol16(int r, int g, int b);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v makecol24}makecol24(int r, int g, int b);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 int {\xe\v makecol32}makecol32(int r, int g, int b);\par }
{\li400 These functions convert colors from a hardware independent form (red, 
green, and blue values ranging 0-255) into various display dependent 
pixel formats. Converting to 15, 16, 24, or 32-bit formats only takes a 
few shifts, so it is fairly efficient. Converting to an 8-bit color 
involves searching the palette to find the closest match, which is quite 
slow unless you have set up an RGB mapping table (see below). Example: 
\par {\s1 \f1\fs18 
\par       /* 16 bit color version of green. */
\par       int green_color = makecol16(0, 255, 0);\par}
\par Returns the requested RGB triplet in the specified color depth. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v makeacol32}makeacol32(int r, int g, int b, int a);\par }
{\li400 Converts an RGBA color into a 32-bit display pixel format, which includes 
an alpha (transparency) value. There are no versions of this routine for 
other color depths, because only the 32-bit format has enough room to 
store a proper alpha channel. You should only use RGBA format colors as 
the input to draw_trans_sprite() or draw_trans_rle_sprite() after calling 
set_alpha_blender(), rather than drawing them directly to the screen. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v makecol}makecol(int r, int g, int b);\par }
{\li400 Converts colors from a hardware independent format (red, green, and blue 
values ranging 0-255) to the pixel format required by the current video 
mode, calling the preceding 8, 15, 16, 24, or 32-bit makecol functions as 
appropriate. Example: 
\par {\s1 \f1\fs18 
\par       /* Regardless of color depth, this will look green. */
\par       int green_color = makecol(0, 255, 0);\par}
\par Returns the requested RGB triplet in the current color depth. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v makecol_depth}makecol_depth(int color_depth, int r, int g, int b);\par }
{\li400 Converts colors from a hardware independent format (red, green, and blue 
values ranging 0-255) to the pixel format required by the specified color 
depth. Example: 
\par {\s1 \f1\fs18 
\par       /* Compose the green color for 15 bit color depth. */
\par       int green_15bit = makecol_depth(15, 0, 255, 0);\par}
\par Returns the requested RGB triplet in the specified color depth. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 int {\xe\v makeacol}makeacol(int r, int g, int b, int a);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 int {\xe\v makeacol_depth}makeacol_depth(int color_depth, int r, int g, int b, int a);\par }
{\li400 Convert RGBA colors into display dependent pixel formats. In anything 
less than a 32-bit mode, these are the same as calling makecol() or 
makecol_depth(), but by using these routines it is possible to create 
32-bit color values that contain a true 8 bit alpha channel along with 
the red, green, and blue components. You should only use RGBA format 
colors as the input to draw_trans_sprite() or draw_trans_rle_sprite() 
after calling set_alpha_blender(), rather than drawing them directly to 
the screen. 
\par \par Returns the requested RGBA quadruplet. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 int {\xe\v makecol15_dither}makecol15_dither(int r, int g, int b, int x, int y);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 int {\xe\v makecol16_dither}makecol16_dither(int r, int g, int b, int x, int y);\par }
{\li400 Given both a color value and a pixel coordinate, calculate a dithered 15 
or 16-bit RGB value. This can produce better results when reducing images 
from truecolor to hicolor. In addition to calling these functions 
directly, hicolor dithering can be automatically enabled when loading 
graphics by calling the set_color_conversion() function, for example 
set_color_conversion(COLORCONV_REDUCE_TRUE_TO_HI | COLORCONV_DITHER). 
\par \par Example: 
\par {\s1 \f1\fs18 
\par       int pixel1, pixel2;
\par 
\par       /* The following two color values MAY be different. */
\par       pixel1 = makecol16_dither(255, 192, 64, 0, 0);
\par       pixel2 = makecol16_dither(255, 192, 64, 1, 0);\par}
\par Returns the RGB value dithered for the specified coordinate. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 int {\xe\v getr8}getr8(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getg8}getg8(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getb8}getb8(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getr15}getr15(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getg15}getg15(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getb15}getb15(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getr16}getr16(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getg16}getg16(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getb16}getb16(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getr24}getr24(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getg24}getg24(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getb24}getb24(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getr32}getr32(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getg32}getg32(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 int {\xe\v getb32}getb32(int c);\par }
{\li400 Given a color in a display dependent format, these functions extract one 
of the red, green, or blue components (ranging 0-255). Example: 
\par {\s1 \f1\fs18 
\par       int r, g, b, color_value;
\par 
\par       color_value = _getpixel15(screen, 100, 100);
\par       r = getr15(color_value);
\par       g = getg15(color_value);
\par       b = getb15(color_value);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v geta32}geta32(int c);\par }
{\li400 Given a color in a 32-bit pixel format, this function extracts the alpha 
component (ranging 0-255). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 int {\xe\v getr}getr(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getg}getg(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getb}getb(int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 int {\xe\v geta}geta(int c);\par }
{\li400 Given a color in the format being used by the current video mode, these 
functions extract one of the red, green, blue, or alpha components 
(ranging 0-255), calling the preceding 8, 15, 16, 24, or 32-bit get 
functions as appropriate. The alpha part is only meaningful for 32-bit 
pixels. Example: 
\par {\s1 \f1\fs18 
\par       int r, g, b, color_value;
\par 
\par       color_value = getpixel(screen, 100, 100);
\par       r = getr(color_value);
\par       g = getg(color_value);
\par       b = getb(color_value);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 int {\xe\v getr_depth}getr_depth(int color_depth, int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getg_depth}getg_depth(int color_depth, int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v getb_depth}getb_depth(int color_depth, int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 int {\xe\v geta_depth}geta_depth(int color_depth, int c);\par }
{\li400 Given a color in the format being used by the specified color depth, 
these functions extract one of the red, green, blue, or alpha components 
(ranging 0-255). The alpha part is only meaningful for 32-bit pixels. 
Example: 
\par {\s1 \f1\fs18 
\par       int r, g, b, color_value, bpp;
\par 
\par       bpp = bitmap_color_depth(bitmap);
\par       color_value = getpixel(bitmap, 100, 100);
\par       r = getr_depth(bpp, color_value);
\par       g = getg_depth(bpp, color_value);
\par       b = getb_depth(bpp, color_value);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v palette_color}palette_color[256];\par }
{\li400 Table mapping palette index colors (0-255) into whatever pixel format is 
being used by the current display mode. In a 256-color mode this just 
maps onto the array index. In truecolor modes it looks up the specified 
entry in the current palette, and converts that RGB value into the 
appropriate packed pixel format. Example: 
\par {\s1 \f1\fs18 
\par       set_color_depth(32);
\par       ...
\par       set_palette(desktop_palette);
\par       /* Put a pixel with the color 2 (green) of the palette */
\par       putpixel(screen, 100, 100, palette_color[2]);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 #define {\xe\v MASK_COLOR_8}MASK_COLOR_8 0\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 #define {\xe\v MASK_COLOR_15}MASK_COLOR_15 (5.5.5 pink)\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 #define {\xe\v MASK_COLOR_16}MASK_COLOR_16 (5.6.5 pink)\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 #define {\xe\v MASK_COLOR_24}MASK_COLOR_24 (8.8.8 pink)\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 #define {\xe\v MASK_COLOR_32}MASK_COLOR_32 (8.8.8 pink)\par }
{\li400 Constants representing the colors used to mask transparent sprite pixels 
for each color depth. In 256-color resolutions this is zero, and in 
truecolor modes it is bright pink (maximum red and blue, zero green). 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Drawing primitives}Drawing primitives\par }
Except for _putpixel(), all these routines are affected by the current 
drawing mode and the clipping rectangle of the destination bitmap. Unless 
specified otherwise, all coordinates for drawing operations are inclusive, 
and they, as well as lengths, are specified in pixel units. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v clear_bitmap}clear_bitmap(BITMAP *bitmap);\par }
{\li400 Clears the bitmap to color 0. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v clear_to_color}clear_to_color(BITMAP *bitmap, int color);\par }
{\li400 Clears the bitmap to the specified color. Example: 
\par {\s1 \f1\fs18 
\par       /* Clear the screen to red. */
\par       clear_to_color(bmp, makecol(255, 0, 0));\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v putpixel}putpixel(BITMAP *bmp, int x, int y, int color);\par }
{\li400 Writes a pixel to the specified position in the bitmap, using the current 
drawing mode and the bitmap's clipping rectangle. Example: 
\par {\s1 \f1\fs18 
\par       putpixel(screen, 10, 30, some_color);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v _putpixel}_putpixel(BITMAP *bmp, int x, int y, int color);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 void {\xe\v _putpixel15}_putpixel15(BITMAP *bmp, int x, int y, int color);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 void {\xe\v _putpixel16}_putpixel16(BITMAP *bmp, int x, int y, int color);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 void {\xe\v _putpixel24}_putpixel24(BITMAP *bmp, int x, int y, int color);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v _putpixel32}_putpixel32(BITMAP *bmp, int x, int y, int color);\par }
{\li400 Like the regular putpixel(), but much faster because they are implemented 
as an inline assembler functions for specific color depths. These won't 
work in mode-X graphics modes, don't perform any clipping (they will 
crash if you try to draw outside the bitmap!), and ignore the drawing 
mode. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v getpixel}getpixel(BITMAP *bmp, int x, int y);\par }
{\li400 Reads a pixel from point (x, y) in the bitmap. 
\par \par Returns -1 if the point lies outside the bitmap (ignoring the clipping 
rectangle), otherwise the value of the pixel in the color format of the 
bitmap. 
\par \par Warning: -1 is also a valid value for pixels contained in 32-bit bitmaps 
with alpha channel (when R,G,B,A are all equal to 255) so you can't use 
the test against -1 as a predicate for such bitmaps. In this cases, the 
only reliable predicate is is_inside_bitmap(). 
\par \par To extract the individual color components, use the getr() / getg() / 
getb() / geta() family of functions. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 int {\xe\v _getpixel}_getpixel(BITMAP *bmp, int x, int y);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v _getpixel15}_getpixel15(BITMAP *bmp, int x, int y);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v _getpixel16}_getpixel16(BITMAP *bmp, int x, int y);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v _getpixel24}_getpixel24(BITMAP *bmp, int x, int y);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 int {\xe\v _getpixel32}_getpixel32(BITMAP *bmp, int x, int y);\par }
{\li400 Faster inline versions of getpixel() for specific color depths. These 
won't work in mode-X, and don't do any clipping, so you must make sure 
the point lies inside the bitmap. 
\par \par Returns the value of the pixel in the color format you specified. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v vline}vline(BITMAP *bmp, int x, int y1, int y2, int color);\par }
{\li400 Draws a vertical line onto the bitmap, from point (x, y1) to (x, y2). 
\par \par Note: vline() is implemented as an alias to another function. 
See ALLEGRO_NO_VHLINE_ALIAS in the `Differences between platforms' 
section for details. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v hline}hline(BITMAP *bmp, int x1, int y, int x2, int color);\par }
{\li400 Draws a horizontal line onto the bitmap, from point (x1, y) to (x2, y). 
\par \par Note: hline() is implemented as an alias to another function. 
See ALLEGRO_NO_VHLINE_ALIAS in the `Differences between platforms' 
section for details. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v do_line}do_line(BITMAP *bmp, int x1, y1, x2, y2, int d,  void (*proc)(BITMAP *bmp, int x, int y, int d));\par }
{\li400 Calculates all the points along a line from point (x1, y1) to (x2, y2), 
calling the supplied function for each one. This will be passed a copy of 
the bmp parameter, the x and y position, and a copy of the d parameter, 
so it is suitable for use with putpixel(). Example: 
\par {\s1 \f1\fs18 
\par       void draw_dust_particle(BITMAP *bmp, int x, int y, int d)
\par       \{
\par          ...
\par       \}
\par       
\par          do_line(screen, 0, 0, SCREEN_W-1, SCREEN_H-2,
\par                  dust_strength, draw_dust_particle);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v line}line(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);\par }
{\li400 Draws a line onto the bitmap, from point (x1, y1) to (x2, y2). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v fastline}fastline(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);\par }
{\li400 Faster version of the previous function. Note that pixel correctness is 
not guaranteed for this function. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v triangle}triangle(BITMAP *bmp, int x1, y1, x2, y2, x3, y3, int color);\par }
{\li400 Draws a filled triangle between the three points. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v polygon}polygon(BITMAP *bmp, int vertices, const int *points, int color);\par }
{\li400 Draws a filled polygon with an arbitrary number of corners. Pass the 
number of vertices and an array containing a series of x, y points (a 
total of vertices*2 values). Example: 
\par {\s1 \f1\fs18 
\par       int points[12] = \{ 50, 50,   100, 100,  100, 150,
\par                          50, 200,  0,   150,  0,   100 \};
\par       ...
\par       clear_to_color(screen, makecol(255, 255, 255));
\par       polygon(screen, 6, points, makecol(0, 0, 0));\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v rect}rect(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);\par }
{\li400 Draws an outline rectangle with the two points as its opposite corners. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v rectfill}rectfill(BITMAP *bmp, int x1, int y1, int x2, int y2, int color);\par }
{\li400 Draws a solid, filled rectangle with the two points as its opposite 
corners. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v do_circle}do_circle(BITMAP *bmp, int x, int y, int radius, int d, void (*proc)(BITMAP *bmp, int x, int y, int d));\par }
{\li400 Calculates all the points in a circle around point (x, y) with radius r, 
calling the supplied function for each one. This will be passed a copy of 
the bmp parameter, the x and y position, and a copy of the d parameter, 
so it is suitable for use with putpixel(). Example: 
\par {\s1 \f1\fs18 
\par       void draw_explosion_ring(BITMAP *bmp, int x, int y, int d)
\par       \{
\par          ...
\par       \}
\par       
\par          do_circle(screen, SCREEN_W/2, SCREEN_H/2,
\par                    SCREEN_H/16, flame_color,
\par                    draw_explosion_ring);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v circle}circle(BITMAP *bmp, int x, int y, int radius, int color);\par }
{\li400 Draws a circle with the specified centre and radius. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v circlefill}circlefill(BITMAP *bmp, int x, int y, int radius, int color);\par }
{\li400 Draws a filled circle with the specified centre and radius. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v do_ellipse}do_ellipse(BITMAP *bmp, int x, int y, int rx, ry, int d, void (*proc)(BITMAP *bmp, int x, int y, int d));\par }
{\li400 Calculates all the points in an ellipse around point (x, y) with radius 
rx and ry, calling the supplied function for each one. This will be 
passed a copy of the bmp parameter, the x and y position, and a copy of 
the d parameter, so it is suitable for use with putpixel(). Example: 
\par {\s1 \f1\fs18 
\par       void draw_explosion_ring(BITMAP *bmp, int x, int y, int d)
\par       \{
\par          ...
\par       \}
\par       
\par          do_ellipse(screen, SCREEN_W/2, SCREEN_H/2,
\par                    SCREEN_H/16, SCREEN_H/32, flame_color,
\par                    draw_explosion_ring);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v ellipse}ellipse(BITMAP *bmp, int x, int y, int rx, int ry, int color);\par }
{\li400 Draws an ellipse with the specified centre and radius. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v ellipsefill}ellipsefill(BITMAP *bmp, int x, int y, int rx, int ry, int color);\par }
{\li400 Draws a filled ellipse with the specified centre and radius. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v do_arc}do_arc(BITMAP *bmp, int x, int y, fixed a1, fixed a2, int r, int d, void (*proc)(BITMAP *bmp, int x, int y, int d));\par }
{\li400 Calculates all the points in a circular arc around point (x, y) with 
radius r, calling the supplied function for each one. This will be passed 
a copy of the bmp parameter, the x and y position, and a copy of the d 
parameter, so it is suitable for use with putpixel(). The arc will be 
plotted in an anticlockwise direction starting from the angle a1 and 
ending when it reaches a2. These values are specified in 16.16 fixed 
point format, with 256 equal to a full circle, 64 a right angle, etc. 
Zero is to the right of the centre point, and larger values rotate 
anticlockwise from there. Example: 
\par {\s1 \f1\fs18 
\par       void draw_explosion_ring(BITMAP *bmp, int x, int y, int d)
\par       \{
\par          ...
\par       \}
\par          do_arc(screen, SCREEN_W/2, SCREEN_H/2,
\par              itofix(-21), itofix(43), 50, flame_color,
\par              draw_explosion_ring);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v arc}arc(BITMAP *bmp, int x, y, fixed ang1, ang2, int r, int color);\par }
{\li400 Draws a circular arc with centre x, y and radius r, in an anticlockwise 
direction starting from the angle a1 and ending when it reaches a2. These 
values are specified in 16.16 fixed point format, with 256 equal to a 
full circle, 64 a right angle, etc. Zero is to the right of the centre 
point, and larger values rotate anticlockwise from there. Example: 
\par {\s1 \f1\fs18 
\par       /* Draw a black arc from 4 to 1 o'clock. */
\par       arc(screen, SCREEN_W/2, SCREEN_H/2,
\par           itofix(-21), itofix(43), 50, makecol(0, 0, 0));\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v calc_spline}calc_spline(const int points[8], int npts, int *x, int *y);\par }
{\li400 Calculates a series of npts values along a Bezier spline, storing them in 
the output x and y arrays. The Bezier curve is specified by the four x/y 
control points in the points array: points[0] and points[1] contain the 
coordinates of the first control point, points[2] and points[3] are the 
second point, etc. Control points 0 and 3 are the ends of the spline, and 
points 1 and 2 are guides. The curve probably won't pass through points 1 
and 2, but they affect the shape of the curve between points 0 and 3 (the 
lines p0-p1 and p2-p3 are tangents to the spline). The easiest way to 
think of it is that the curve starts at p0, heading in the direction of 
p1, but curves round so that it arrives at p3 from the direction of p2. 
In addition to their role as graphics primitives, spline curves can be 
useful for constructing smooth paths around a series of control points, 
as in exspline.c. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v spline}spline(BITMAP *bmp, const int points[8], int color);\par }
{\li400 Draws a Bezier spline using the four control points specified in the 
points array. Read the description of calc_spline() for information on 
how to build the points array. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v floodfill}floodfill(BITMAP *bmp, int x, int y, int color);\par }
{\li400 Floodfills an enclosed area, starting at point (x, y), with the specified 
color. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Blitting and sprites}Blitting and sprites\par }
As far as Allegro is concerned, a bitmap and a sprite are the same thing, 
but to many people the two words imply slightly different things.  The 
function draw_sprite() is called so rather than draw_bitmap() partly because 
it indicates that it uses a masked drawing mode (if it existed, you could 
expect draw_bitmap() to be a simple block copy), and partly for historical 
reasons. In Allegro 1.0 there were actually different structures for sprites 
and bitmaps, each with their own set of abilities. Allegro 2.0 merged these 
into a single more flexible structure, but retained some names like 
draw_sprite(). 
\par \par In wider (non-Allegro) terms, the two words can mean quite different things. 
Generally you can say that sprites are a subset of bitmaps, but even that 
isn't true in 100% of cases. 
\par \par BITMAP: a widely accepted term that will be understood by anyone even 
remotely connected with computer graphics. It simply means an image built up 
from a grid of pixels, ie. just about any picture that you are likely to come 
across on a computer (vector graphics formats are the exception, but those 
must be rendered into a bitmap format before they can be displayed by most 
hardware). A more accurate term but slightly rarer term with the same meaning 
is "pixmap" (pixel-map). 
\par \par SPRITE: a particular usage of bitmapped images, restricted to video games 
(other types of programmer probably won't be familiar with this term). 
Originally on machines like the C64, sprites were a hardware feature that 
allowed a number of small bitmap images to be loaded into special registers, 
and they could then be superimposed over the main graphics display and moved 
around just by modifying the position register. They were used for the moving 
objects (player and enemy characters), and enabled the C64 to do much more 
impressive things than would have been possible if all the drawing had to be 
done directly by the puny CPU. 
\par \par Later on, a lot of old C64 programmers upgraded to machines like the Atari 
ST, which didn't have any special sprite hardware, but they carried on 
referring to their main moving objects as sprites (the routine to draw such a 
thing would obviously be called draw_sprite()).  A sprite is really just a 
bitmap graphic which is drawn onto the screen, but when you call it a sprite 
rather than a bitmap, this suggests it is a gameplay element that can move 
freely around the world rather than being a static part of the environment, 
and that it will be drawn in a masked overlay mode rather than as a solid 
rectangle (there is also a strong implication that a sprite will be animated 
by cycling through a number of frames, but that isn't always the case). 
\par \par In recent years some people have started using "sprite" to refer to any 
character graphics, even if they are not in fact drawn as 2d bitmaps, eg. 
"this game uses 3d polygonal player sprites". This is a confusing misuse of 
the word (Doom uses sprites, Quake does not), but it does happen. 
\par \par The origin of the term "blit" is also rather interesting. This was originally 
BitBlt, an abbreviation of BITmap BLock Transfer, which was a function 
designed (possibly) by the people at Xerox who did so much of the pioneering 
work on graphics display systems, and subsequently copied by virtually 
everybody doing computer graphics (the Microsoft Windows GDI still provides a 
BitBlt function with identical functionality to the original). This routine 
was a workhorse for all sorts of drawing operations, basically copying bitmap 
graphics from one place to another, but including a number of different ROP 
modes (Raster OPerations) for doing things like XOR, inverting pixels, etc. 
A whole family of related words grew up around the BitBlt function, but "blt" 
is impossible to speak (try saying "bltter" or "bltting" :-) so people added 
the vowel to make it easier to pronounce. 
\par \par Therefore, the act of calling the BitBlt function came to be known as "doing a 
blit". The obvious next step was to rename the function itself to blit(), 
which generally took place at the same time as people decided to simplify the 
original, removing the different ROP modes on the grounds that they aren't 
needed for games coding and don't work well with anything higher than 
monochrome images in any case. This leaves us with a function called blit(), 
which is an abbreviation for "block transfer". A strong case could be made 
for calling this blot() instead, but somehow that just doesn't sound the 
same! 
\par \par Anyway, all the routines in this chapter are affected by the 
clipping rectangle of the destination bitmap. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v blit}blit(BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height);\par }
{\li400 Copies a rectangular area of the source bitmap to the destination bitmap. 
The source_x and source_y parameters are the top left corner of the area 
to copy from the source bitmap, and dest_x and dest_y are the 
corresponding position in the destination bitmap. This routine respects 
the destination clipping rectangle, and it will also clip if you try to 
blit from areas outside the source bitmap. Example: 
\par {\s1 \f1\fs18 
\par       BITMAP *bmp;
\par       ...
\par       /* Blit src on the screen. */
\par       blit(bmp, screen, 0, 0, 0, 0, bmp->w, bmp->h);
\par       
\par       /* Now copy a chunk to a corner, slightly outside. /*
\par       blit(screen, screen, 100, 100, -10, -10, 25, 30);
\par }\par You can blit between any parts of any two bitmaps, even if the two memory 
areas overlap (ie. source and dest are the same, or one is sub-bitmap of 
the other). You should be aware, however, that a lot of SVGA cards don't 
provide separate read and write banks, which means that blitting from one 
part of the screen to another requires the use of a temporary bitmap in 
memory, and is therefore extremely slow. As a general rule you should 
avoid blitting from the screen onto itself in SVGA modes. 
\par \par In mode-X, on the other hand, blitting from one part of the screen to 
another can be significantly faster than blitting from memory onto the 
screen, as long as the source and destination are correctly aligned with 
each other. Copying between overlapping screen rectangles is slow, but if 
the areas don't overlap, and if they have the same plane alignment (ie. 
(source_x%4) == (dest_x%4)), the VGA latch registers can be used for a 
very fast data transfer. To take advantage of this, in mode-X it is often 
worth storing tile graphics in a hidden area of video memory (using a 
large virtual screen), and blitting them from there onto the visible part 
of the screen. 
\par \par If the GFX_HW_VRAM_BLIT bit in the gfx_capabilities flag is set, the 
current driver supports hardware accelerated blits from one part of the 
screen onto another. This is extremely fast, so when this flag is set it 
may be worth storing some of your more frequently used graphics in an 
offscreen portion of the video memory. 
\par \par Unlike most of the graphics routines, blit() allows the source and 
destination bitmaps to be of different color depths, so it can be 
used to convert images from one pixel format to another. In this 
case, the behavior is affected by the COLORCONV_KEEP_TRANS and 
COLORCONV_DITHER* flags of the current color conversion mode: see 
set_color_conversion() for more information. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v stretch_blit}stretch_blit(BITMAP *source, BITMAP *dest, int source_x, source_y, source_width, source_height, int dest_x, dest_y, dest_width, dest_height);\par }
{\li400 Like blit(), except it can scale images (so the source and destination 
rectangles don't need to be the same size) and requires the source and 
destination bitmaps to be of the same color depth. This routine doesn't 
do as much safety checking as the regular blit(): in particular you must 
take care not to copy from areas outside the source bitmap, and you 
cannot blit between overlapping regions, ie. you must use different 
bitmaps for the source and the destination. Moreover, the source must 
be a memory bitmap. Example: 
\par {\s1 \f1\fs18 
\par       BITMAP *bmp;
\par       ...
\par       /* Stretch bmp to fill the screen. */
\par       stretch_blit(bmp, screen, 0, 0, bmp->w, bmp->h,
\par                    0, 0, SCREEN_W, SCREEN_H);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v masked_blit}masked_blit(BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height);\par }
{\li400 Like blit(), but skips transparent pixels, which are marked by a zero in 
256-color modes or bright pink for truecolor data (maximum red and blue, 
zero green), and requires the source and destination bitmaps to be of 
the same color depth. The source and destination regions must not overlap. 
Example: 
\par {\s1 \f1\fs18 
\par       BITMAP *hud_overlay;
\par       ...
\par       /* Paint hud overlay on the screen. */
\par       masked_blit(hud_overlay, screen, 0, 0, 0, 0,
\par                   hud_overlay->w, hud_overlay->h);\par}
\par If the GFX_HW_VRAM_BLIT_MASKED bit in the gfx_capabilities flag is set, 
the current driver supports hardware accelerated masked blits from one 
part of the screen onto another. This is extremely fast, so when this 
flag is set it may be worth storing some of your more frequently used 
sprites in an offscreen portion of the video memory. 
\par \par Warning: if the hardware acceleration flag is not set, masked_blit() will 
not work correctly when used with a source image in system or video 
memory so the latter must be a memory bitmap. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v masked_stretch_blit}masked_stretch_blit(BITMAP *source, BITMAP *dest, int source_x, source_y, source_w, source_h, int dest_x, dest_y, dest_w, dest_h);\par }
{\li400 Like masked_blit(), except it can scale images (so the source and 
destination rectangles don't need to be the same size). This routine 
doesn't do as much safety checking as the regular masked_blit(): in 
particular you must take care not to copy from areas outside the source 
bitmap. Moreover, the source must be a memory bitmap. Example: 
\par {\s1 \f1\fs18 
\par       BITMAP *hud_overlay;
\par       ...
\par       /* Stretch hud overlay over the screen. */
\par       masked_stretch_blit(hud_overlay, screen, 0, 0,
\par                           hud_overlay->w, hud_overlay->h,
\par                           0, 0, SCREEN_W, SCREEN_H);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v draw_sprite}draw_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y);\par }
{\li400 Draws a copy of the sprite bitmap onto the destination bitmap at the 
specified position. This is almost the same as blit(sprite, bmp, 0, 0, x, 
y, sprite->w, sprite->h), but it uses a masked drawing mode where 
transparent pixels are skipped, so the background image will show through 
the masked parts of the sprite. Transparent pixels are marked by a zero 
in 256-color modes or bright pink for truecolor data (maximum red and 
blue, zero green). Example: 
\par {\s1 \f1\fs18 
\par       BITMAP *spaceship;
\par       ...
\par       draw_sprite(screen, spaceship, x, y);\par}
\par If the GFX_HW_VRAM_BLIT_MASKED bit in the gfx_capabilities flag is set, 
the current driver supports hardware accelerated sprite drawing when the 
source image is a video memory bitmap or a sub-bitmap of the screen. This 
is extremely fast, so when this flag is set it may be worth storing some 
of your more frequently used sprites in an offscreen portion of the video 
memory. 
\par \par Warning: if the hardware acceleration flag is not set, draw_sprite() will 
not work correctly when used with a sprite image in system or video 
memory so the latter must be a memory bitmap. 
\par \par Although generally not supporting graphics of mixed color depths, as a 
special case this function can be used to draw 256-color source images 
onto truecolor destination bitmaps, so you can use palette effects on 
specific sprites within a truecolor program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v stretch_sprite}stretch_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, int w, int h);\par }
{\li400 Like draw_sprite(), except it can stretch the sprite image to the 
specified width and height and requires the sprite image and destination 
bitmap to be of the same color depth. Moreover, the sprite image must 
be a memory bitmap. Example: 
\par {\s1 \f1\fs18 
\par       /* Create tunnel like effect. */
\par       for (step = 1; step 
\par          int width = SCREEN_W / step;
\par          int height = SCREEN_H / step;
\par          stretch_sprite(screen, image, SCREEN_W / 2 - width / 2,
\par                         SCREEN_H / 2 - height / 2, width, height);
\par       \}\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v draw_sprite_v_flip}draw_sprite_v_flip(BITMAP *bmp, BITMAP *sprite, int x, int y);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 void {\xe\v draw_sprite_h_flip}draw_sprite_h_flip(BITMAP *bmp, BITMAP *sprite, int x, int y);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v draw_sprite_vh_flip}draw_sprite_vh_flip(BITMAP *bmp, BITMAP *sprite, int x, int y);\par }
{\li400 These are like draw_sprite(), but they additionally flip the image 
vertically, horizontally, or both, respectively. Flipping vertically 
means that the y-axis is reversed, while flipping horizontally means 
that the x-axis is reversed, between the source and the destination. 
This produces exact mirror images, which is not the same as rotating the 
sprite (and it is a lot faster than the rotation routine). The sprite 
must be a memory bitmap. Example: 
\par {\s1 \f1\fs18 
\par       if (key[KEY_RIGHT])
\par          draw_sprite(screen, hero_right, pos_x, pos_y);
\par       else if (key[KEY_LEFT])
\par          draw_sprite_h_flip(screen, hero_right, pos_x, pos_y);
\par       else
\par          draw_sprite(screen, hero_idle, pos_x, pos_y);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v draw_trans_sprite}draw_trans_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y);\par }
{\li400 Uses the global color_map table or truecolor blender functions to overlay 
the sprite on top of the existing image. This must only be used after you 
have set up the color mapping table (for 256-color modes) or blender 
functions (for truecolor modes). Because it involves reading as well as 
writing the bitmap memory, translucent drawing is very slow if you draw 
directly to video RAM, so wherever possible you should use a memory 
bitmap instead. Example: 
\par {\s1 \f1\fs18 
\par       /* Some one time initialisation code. */
\par       COLOR_MAP global_trans_table;
\par       create_trans_table(&global_trans_table, my_palette,
\par                          128, 128, 128, NULL);
\par       ...
\par       if (get_color_depth() == 8)
\par          color_map = &global_trans_table;
\par       else
\par          set_trans_blender(128, 128, 128, 128);
\par 
\par       draw_trans_sprite(buffer, ghost_sprite, x, y);\par}
\par The bitmap and sprite must normally be in the same color depth, but as a 
special case you can draw 32 bit RGBA format sprites onto any hicolor or 
truecolor bitmap, as long as you call set_alpha_blender() first, and you 
can draw 8-bit alpha images onto a 32-bit RGBA destination, as long as you 
call set_write_alpha_blender() first. As draw_sprite() this function skips 
transparent pixels, except if the source sprite is an 8-bit image; if this 
is the case, you should pay attention to properly set up your color map 
table for index 0. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v draw_lit_sprite}draw_lit_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, int color);\par }
{\li400 In 256-color modes, uses the global color_map table to tint the sprite 
image to the specified color or to light it to the level specified by 
'color', depending on the function which was used to build the table 
(create_trans_table or create_light_table), and draws the resulting image 
to the destination bitmap. In truecolor modes, uses the blender functions 
to light the sprite image using the alpha level specified by 'color' (the 
alpha level which was passed to the blender functions is ignored) and 
draws the resulting image to the destination bitmap. The 'color' parameter 
must be in the range [0-255] whatever its actual meaning is. This must 
only be used after you have set up the color mapping table (for 256-color 
modes) or blender functions (for truecolor modes). Example: 
\par {\s1 \f1\fs18 
\par       /* Some one time initialisation code. */
\par       COLOR_MAP global_light_table;
\par       create_light_table(&global_trans_table, my_palette,
\par                          10, 10, 60, NULL);
\par       ...
\par       if (get_color_depth() == 8)
\par          color_map = &global_light_table;
\par       else
\par          set_trans_blender(40, 40, 255, 255);
\par 
\par       /* Lit the cape with a blueish light. */
\par       draw_lit_sprite(buffer, colored_cape, x, y, 64);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v draw_gouraud_sprite}draw_gouraud_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, int c1, int c2, int c3, int c4);\par }
{\li400 More sophisticated version of draw_lit_sprite(): the 'color' parameter is 
not constant across the sprite image anymore but interpolated between the 
four specified corner colors. The corner values passed to this function 
indicate the strength of the color applied on them, ranging from 0 (no 
strength) to 255 (full strength). Example: 
\par {\s1 \f1\fs18 
\par       /* Some one time initialisation code. */
\par       COLOR_MAP global_light_table;
\par       create_light_table(&global_trans_table, my_palette,
\par                          0, 0, 0, NULL);
\par       ...
\par       if (get_color_depth() == 8)
\par          color_map = &global_light_table;
\par       else
\par          set_trans_blender(0, 0, 0, 128);
\par 
\par       /* Enemies are in shadow unless lit by torch. */
\par       draw_gouraud_sprite(buffer, menacing_spy, x, y,
\par                           light_strength_on_corner_1,
\par                           light_strength_on_corner_2,
\par                           light_strength_on_corner_3,
\par                           light_strength_on_corner_4);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v draw_character_ex}draw_character_ex(BITMAP *bmp, BITMAP *sprite, int x, int y, color, bg);\par }
{\li400 Draws a copy of the sprite bitmap onto the destination bitmap at the 
specified position, drawing transparent pixels in the background color 
(or skipping them if the background color is -1) and setting all other 
pixels to the specified color. Transparent pixels are marked by a zero 
in 256-color modes or bright pink for truecolor data (maximum red and 
blue, zero green). The sprite must be an 8-bit image, even if the 
destination is a truecolor bitmap. Example: 
\par {\s1 \f1\fs18 
\par       BITMAP *logo;
\par       ...
\par       /* Draw the logo silhouette in red. */
\par       draw_character_ex(screen, logo, SCREEN_W / 2, SCREEN_H / 2,
\par                         makecol(255, 0, 0), -1);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v rotate_sprite}rotate_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle);\par }
{\li400 Draws the sprite image onto the bitmap. It is placed with its top left 
corner at the specified position, then rotated by the specified angle 
around its centre. The angle is a fixed point 16.16 number in the same 
format used by the fixed point trig routines, with 256 equal to a full 
circle, 64 a right angle, etc. All rotation functions can draw between any 
two bitmaps, even screen bitmaps or bitmaps of different color depth. 
\par \par Positive increments of the angle will make the sprite rotate clockwise 
on the screen, as demonstrated by the Allegro example. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v rotate_sprite_v_flip}rotate_sprite_v_flip(BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle);\par }
{\li400 Like rotate_sprite, but flips the image vertically before rotating it. To 
flip horizontally, use this routine but add itofix(128) to the angle. To 
flip in both directions, use rotate_sprite() and add itofix(128) to its 
angle. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v rotate_scaled_sprite}rotate_scaled_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle, fixed scale);\par }
{\li400 Like rotate_sprite(), but stretches or shrinks the image at the same time 
as rotating it. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v rotate_scaled_sprite_v_flip}rotate_scaled_sprite_v_flip(BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle, fixed scale);\par }
{\li400 Draws the sprite, similar to rotate_scaled_sprite() except that it flips 
the sprite vertically first. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v pivot_sprite}pivot_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle);\par }
{\li400 Like rotate_sprite(), but aligns the point in the sprite given by (cx, cy) 
to (x, y) in the bitmap, then rotates around this point. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v pivot_sprite_v_flip}pivot_sprite_v_flip(BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle);\par }
{\li400 Like rotate_sprite_v_flip(), but aligns the point in the sprite given by 
(cx, cy) to (x, y) in the bitmap, then rotates around this point. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v pivot_scaled_sprite}pivot_scaled_sprite(BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle, fixed scale);\par }
{\li400 Like rotate_scaled_sprite(), but aligns the point in the sprite given by 
(cx, cy) to (x, y) in the bitmap, then rotates and scales around this 
point. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v pivot_scaled_sprite_v_flip}pivot_scaled_sprite_v_flip(BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle, fixed scale);\par }
{\li400 Like rotate_scaled_sprite_v_flip(), but aligns the point in the sprite 
given by (cx, cy) to (x, y) in the bitmap, then rotates and scales around 
this point. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v RLE sprites}RLE sprites\par }
Because bitmaps can be used in so many different ways, the bitmap structure 
is quite complicated, and it contains a lot of data. In many situations, 
though, you will find yourself storing images that are only ever copied to 
the screen, rather than being drawn onto or used as filling patterns, etc. 
If this is the case you may be better off storing your images in RLE_SPRITE 
(read chapter "Structures and types defined by Allegro" for an internal 
description of the RLE_SPRITE structure) or COMPILED_SPRITE (see next 
chapter) structures rather than regular bitmaps. 
\par \par RLE sprites store the image in a simple run-length encoded format, where 
repeated zero pixels are replaced by a single length count, and strings of 
non-zero pixels are preceded by a counter giving the length of the solid 
run. RLE sprites are usually much smaller than normal bitmaps, both because 
of the run length compression, and because they avoid most of the overhead 
of the bitmap structure. They are often also faster than normal bitmaps, 
because rather than having to compare every single pixel with zero to 
determine whether it should be drawn, it is possible to skip over a whole 
run of zeros with a single add, or to copy a long run of non-zero pixels 
with fast string instructions. 
\par \par Every silver lining has a cloud, though, and in the case of RLE sprites it 
is a lack of flexibility. You can't draw onto them, and you can't flip them, 
rotate them, or stretch them. In fact the only thing you can do with them is 
to blast them onto a bitmap with the draw_rle_sprite() function, which is 
equivalent to using draw_sprite() with a regular bitmap. You can convert 
bitmaps into RLE sprites at runtime, or you can create RLE sprite structures 
in grabber datafiles by making a new object of type 'RLE sprite'. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b RLE_SPRITE *{\xe\v get_rle_sprite}get_rle_sprite(BITMAP *bitmap);\par }
{\li400 Creates an RLE sprite based on the specified bitmap (which must be a 
memory bitmap). Remember to free this RLE sprite later to avoid memory 
leaks. Example: 
\par {\s1 \f1\fs18 
\par       RLE_SPRITE *rle;
\par       BITMAP *bmp;
\par       ...
\par       /* Create RLE sprite from an existent bitmap. */
\par       rle = get_rle_sprite(bmp);
\par       if (!rle)
\par          abort_on_error("Couldn't create RLE sprite!");
\par          
\par       /* We don't need the bitmap any more.*/
\par       destroy_bitmap(bmp);
\par       
\par       /* Use the RLE sprite. */
\par       ...
\par       /* Destroy it when we don't need it any more. */
\par       destroy_rle_sprite(rle);\par}
\par Returns a pointer to the created RLE sprite, or NULL if the RLE sprite 
could not be created. Remember to free this RLE sprite later to avoid 
memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v destroy_rle_sprite}destroy_rle_sprite(RLE_SPRITE *sprite);\par }
{\li400 Destroys an RLE sprite structure previously returned by get_rle_sprite(). 
If you pass a NULL pointer this function won't do anything. Use this once 
you are done with an RLE sprite to avoid memory leaks in your program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v draw_rle_sprite}draw_rle_sprite(BITMAP *bmp, const RLE_SPRITE *sprite, int x, int y);\par }
{\li400 Draws an RLE sprite onto a bitmap at the specified position. Example: 
\par {\s1 \f1\fs18 
\par       RLE_SPRITE *rle_sprite;
\par       ...
\par       draw_rle_sprite(screen, rle_sprite, 100, 100);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v draw_trans_rle_sprite}draw_trans_rle_sprite(BITMAP *bmp, const RLE_SPRITE *sprite, int x, int y);\par }
{\li400 Translucent version of draw_rle_sprite(). See the description of 
draw_trans_sprite(). This must only be used after you have set up the 
color mapping table (for 256-color modes) or blender functions (for 
truecolor modes). The bitmap and sprite must normally be in the same 
color depth, but as a special case you can draw 32-bit RGBA format 
sprites onto any hicolor or truecolor bitmap, as long as you call 
set_alpha_blender() first. Example: 
\par {\s1 \f1\fs18 
\par       /* Some one time initialisation code. */
\par       COLOR_MAP global_trans_table;
\par       create_trans_table(&global_trans_table, my_palette,
\par                          128, 128, 128, NULL);
\par       ...
\par       if (get_color_depth() == 8)
\par          color_map = &global_trans_table;
\par       else
\par          set_trans_blender(128, 128, 128, 128);
\par 
\par       draw_trans_rle_sprite(buffer, rle_ghost_sprite, x, y);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v draw_lit_rle_sprite}draw_lit_rle_sprite(BITMAP *bmp, const RLE_SPRITE *sprite, int x, y, color);\par }
{\li400 Tinted version of draw_rle_sprite(). See the description of 
draw_lit_sprite(). This must only be used after you have set up the color 
mapping table (for 256-color modes) or blender functions (for truecolor 
modes). Example: 
\par {\s1 \f1\fs18 
\par       /* Some one time initialisation code. */
\par       COLOR_MAP global_light_table;
\par       create_light_table(&global_trans_table, my_palette,
\par                          10, 10, 60, NULL);
\par       ...
\par       if (get_color_depth() == 8)
\par          color_map = &global_light_table;
\par       else
\par          set_trans_blender(40, 40, 255, 255);
\par 
\par       /* Lit the cape with a blueish light. */
\par       draw_lit_rle_sprite(buffer, rle_colored_cape, x, y, 64);\par}
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Compiled sprites}Compiled sprites\par }
Compiled sprites are stored as actual machine code instructions that draw a 
specific image onto a bitmap, using mov instructions with immediate data 
values. This is the fastest way to draw a masked image: on slow machines, 
up to and including a 486, drawing compiled sprites can be about to five 
times as fast as using draw_sprite() with a regular bitmap. On newer 
machines the difference is usually negligible. 
\par \par Compiled sprites are big, so if memory is tight you should use RLE sprites 
instead, and what you can do with them is even more restricted than with RLE 
sprites, because they don't support clipping. If you try to draw one off the 
edge of a bitmap, you will corrupt memory and probably crash the system. You 
can convert bitmaps into compiled sprites at runtime, or you can create 
compiled sprite structures in grabber datafiles by making a new object of 
type 'Compiled sprite' or 'Compiled x-sprite'. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b COMPILED_SPRITE *{\xe\v get_compiled_sprite}get_compiled_sprite(BITMAP *bitmap, int planar);\par }
{\li400 Creates a compiled sprite based on the specified bitmap (which must be a 
memory bitmap). Compiled sprites are device-dependent, so you have to 
specify whether to compile it into a linear or planar format. Pass FALSE 
as the second parameter if you are going to be drawing it onto memory 
bitmaps or mode 13h and SVGA screen bitmaps, and pass TRUE if you are 
going to draw it onto mode-X or Xtended mode screen bitmaps. Example: 
\par {\s1 \f1\fs18 
\par       COMPILED_SPRITE *cspr;
\par       BITMAP *bmp;
\par       ...
\par       /* Create compiled sprite from an existent bitmap. */
\par       cspr = get_compiled_sprite(bmp, 0);
\par       if (!cspr)
\par          abort_on_error("Couldn't create compiled sprite!");
\par       
\par       /* We don't need the bitmap any more.*/
\par       destroy_bitmap(bmp);
\par       
\par       /* Use the compiled sprite. */
\par       ...
\par       /* Destroy it when we don't need it any more. */
\par       destroy_compiled_sprite(cspr);
\par }\par Returns a pointer to the created compiled sprite, or NULL if the compiled 
sprite could not be created. Remember to free this compiled sprite later 
to avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v destroy_compiled_sprite}destroy_compiled_sprite(COMPILED_SPRITE *sprite);\par }
{\li400 Destroys a compiled sprite structure previously returned by 
get_compiled_sprite(). If you pass a NULL pointer this function won't do 
anything. Use this once you are done with a compiled sprite to avoid 
memory leaks in your program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v draw_compiled_sprite}draw_compiled_sprite(BITMAP *bmp, const COMPILED_SPRITE *sprite, int x, int y);\par }
{\li400 Draws a compiled sprite onto a bitmap at the specified position. The 
sprite must have been compiled for the correct type of bitmap (linear or 
planar). This function does not support clipping. 
\par \par Hint: if not being able to clip compiled sprites is a problem, a neat 
trick is to set up a work surface (memory bitmap, mode-X virtual screen, 
or whatever) a bit bigger than you really need, and use the middle of it 
as your screen. That way you can draw slightly off the edge without any 
trouble... 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Fonts}Fonts\par }
Allegro provides routines for loading fonts directly from GRX format .fnt 
files, 8x8 or 8x16 BIOS format .fnt files, from bitmap images, from datafiles 
or you can import a multiple-range Unicode font by writing a .txt script that 
specifies a number of different source files for each range of characters. 
\par \par By default, Allegro can only use bitmapped (non-scalable) fonts. If you want 
to use TrueType fonts, you will need to use an add-on library which allows 
you to load them on the fly (like AllegTTF or Glyph Keeper, listed among 
others at http://www.allegro.cc/) and render them directly, or generate a 
bitmapped version of a TrueType font with tools like TTF2PCX 
(http://www.talula.demon.co.uk/ttf2pcx/index.html). 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v register_font_file_type}register_font_file_type(const char *ext, FONT *(*load)(const char *filename, RGB *pal, void *param));\par }
{\li400 Informs the load_font() functions of a new file type, providing a routine 
to read fonts in this format. The function you supply must follow the 
following prototype: 
\par {\s1 \f1\fs18 
\par       FONT *load_my_font(const char *filename, RGB *pal, void *param)
\par       \{
\par          ...
\par       \}
\par }\par The pal parameter can optionally be used to return a palette for the FONT. 
The parameter param can be anything you like: you can use this to pass 
information to your loading routine, such as for instance the font height, 
the character range to load or the index number of a font in a datafile. 
If you choose to write your own font loading code, your function should be 
prepared to deal with a value of NULL for either of these parameters. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b FONT *{\xe\v load_font}load_font(const char *filename, RGB *pal, void *param);\par }
{\li400 Loads a font from a file. At present, this supports loading fonts from 
a GRX format .fnt file, a 8x8 or 8x16 BIOS format .fnt file, a datafile or 
any bitmap format that can be loaded by load_bitmap(). 
\par \par If the font contains palette information, then the palette is returned in 
the second parameter, which should be an array of 256 RGB structures 
(a PALETTE). The pal argument may be NULL. In this case, the palette data, 
if present, is simply not returned. 
\par \par The third parameter can be used to pass specific information to a custom 
loader routine. Normally, you can just leave this as NULL. Note that 
another way of loading fonts is embedding them into a datafile and using 
the datafile related functions. 
\par \par Example: 
\par {\s1 \f1\fs18 
\par       FONT *myfont;
\par       PALETTE palette;
\par       ...
\par       myfont = load_font("my_font.pcx", palette, NULL);
\par       if (!myfont)
\par          abort_on_error("Couldn't load font!");
\par       ...
\par       textout_centre_ex(screen, myfont, "This is my own pretty font!",
\par                         SCREEN_W / 2, SCREEN_H / 2, white, black);
\par       ...
\par       destroy_font(myfont);\par}
\par Returns a pointer to the font or NULL on error. Remember that you are 
responsible for destroying the font when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v destroy_font}destroy_font(FONT *f);\par }
{\li400 Frees the memory being used by a font structure. Don't use this on the 
default global Allegro font or any text routines using it could crash. You 
should use this only on fonts you have loaded manually after you are done 
with them, to prevent memory leaks in your program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v make_trans_font}make_trans_font(FONT *f);\par }
{\li400 This function converts a font to use transparency for drawing. That is, each 
glyph in the font will be drawn with draw_trans_sprite, so you can use the 
same blenders as with draw_trans_sprite to draw the font. One common use of 
this is to load a bitmap font with an alpha channel, and therefore get 
anti-aliased text output by using Allegro's alpha blender. Here's an example 
how to do that: 
\par \par \par {\s1 \f1\fs18 
\par    FONT *f = load_font("alphafont.tga", NULL, NULL);
\par    make_trans_font(f);
\par    set_alpha_blender();
\par    textprintf_centre_ex(screen, f, 320, 240, -1, -1, "Anti-aliased Font!");\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v is_trans_font}is_trans_font(FONT *f)\par }
{\li400 This function checks if the given font is a color font using 
draw_trans_sprite to render glyphs. 
\par \par Returns TRUE if the font uses transparency, FALSE if it does not. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v is_color_font}is_color_font(FONT *f)\par }
{\li400 This function checks if the given font is a color font, as opposed to a 
monochrome font. 
\par \par Returns TRUE if the font is a color font, FALSE if it is not. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v is_mono_font}is_mono_font(FONT *f)\par }
{\li400 This function checks if the given font is a mono font, as opposed to a 
color font. 
\par \par Returns TRUE if the font is a monochrome font, FALSE if it is not. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v font_has_alpha}font_has_alpha(FONT *f)\par }
{\li400 This function goes through all pixels of all glyphs in the font and looks for 
alpha values. 
\par \par Returns TRUE if any alpha pixels are found, else FALSE. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int *{\xe\v is_compatible_font}is_compatible_font(FONT *f1, FONT *f2)\par }
{\li400 This function compares the two fonts, which you can use to find out if 
Allegro is capable of merging them. 
\par \par Returns TRUE if the two fonts are of the same general type (both are color 
fonts or both are monochrome fonts, for instance). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_font_ranges}get_font_ranges(FONT *f)\par }
{\li400 Use this function to find out the number of character ranges in a font. You 
should query each of these ranges with get_font_range_begin() and 
get_font_range_end() to find out what characters are available in the 
font. Example: 
\par {\s1 \f1\fs18 
\par       FONT *f;
\par       int range;
\par       int n;
\par       ...
\par       
\par       range = get_font_ranges(f);
\par       printf("The font has %d character ranges:\\n", range);
\par       for (n = 0; n < range; n++)
\par          printf("Range %d from 0x%03x - 0x%03x\\n",
\par                 get_font_range_begin(f, n),
\par                 get_font_range_end(f, n));\par}
\par Returns the number of continuous character ranges in a font, or -1 if that 
information is not available. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_font_range_begin}get_font_range_begin(FONT *f, int range)\par }
{\li400 This function allows you to find out the start of a specific character 
range for a font. You can pass -1 for the `range' parameter if you want to 
know the start of the whole font range, or a number from 0 to (but not 
including) get_font_ranges(f) to get the start of a specific character 
range in the font. Example: 
\par {\s1 \f1\fs18 
\par       printf("The font has a character range of %d - %d\\n",
\par              get_font_range_begin(font, -1),
\par              get_font_range_end(font, -1));\par}
\par Returns the first character in the font range, or -1 if that information 
is not available. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_font_range_end}get_font_range_end(FONT *f, int range)\par }
{\li400 This function allows you to find out the index to the last character of a 
character range for a font. You can pass -1 for the range parameter if you 
want to know the start of the whole font range, or a number from 0 to (but 
not including) get_font_ranges(f) to get the start of a specific character 
range in the font. You should check the start and end of all font ranges to 
see if a specific character is actually available in the font. Not all 
characters in the range returned by get_font_range_begin(f, -1) and 
get_font_range_end(f, -1) need to be available! Example: 
\par {\s1 \f1\fs18 
\par       printf("The font has a character range of %d - %d\\n",
\par              get_font_range_begin(font, -1),
\par              get_font_range_end(font, -1));\par}
\par Returns the last character in the font range, or -1 if that information is 
not available. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b FONT *{\xe\v extract_font_range}extract_font_range(FONT *f, int begin, int end)\par }
{\li400 This function extracts a character range from a font and returns a new font 
that contains only the range of characters selected by this function. You 
can pass -1 for either the lower or upper bound if you want to select all 
characters from the start or to the end of the font. 
Example: 
\par {\s1 \f1\fs18 
\par       FONT *myfont;
\par       FONT *capitals;
\par       FONT *fontcopy;
\par       ...
\par       /* Create a font of only capital letters */
\par       capitals = extract_font_range(myfont, 'A', 'Z');
\par 
\par       /* Create a copy of the font */
\par       fontcopy = extract_font_range(myfont, -1, -1);
\par       ...
\par       destroy_font(capitals);
\par       destroy_font(fontcopy);\par}
\par Returns a pointer to the new font or NULL on error. Remember that you are 
responsible for destroying the font when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v transpose_font}transpose_font(FONT *f, int drange)\par }
{\li400 This function transposes all characters in a font, effectively remapping the 
font. Example: 
\par {\s1 \f1\fs18 
\par       FONT *myfont;
\par       FONT *capitals;
\par       ...
\par       /* Create a font of only capital letters */
\par       capitals = extract_font_range(myfont, 'A', 'Z');
\par 
\par       /* Now transpose the characters in the font so that they will be used */
\par       /*  for the lower case letters a-z */
\par       transpose_font(capitals, 'a'-'A');
\par       textout_ex(screen, capitals, "allcaps",
\par                  100, 100, makecol(255,255,255), 0);\par}
\par Returns 0 on success, -1 on failure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b FONT *{\xe\v merge_fonts}merge_fonts(FONT *f1, FONT *f2)\par }
{\li400 This function merges the character ranges from two fonts and returns a new 
font containing all characters in the old fonts. In general, you cannot 
merge fonts of different types (eg, TrueType fonts and bitmapped fonts), 
but as a special case, this function can promote a monochrome bitmapped 
font to a color font and merge those. Example: 
\par {\s1 \f1\fs18 
\par       FONT *myfont;
\par       FONT *myfancy_font;
\par       FONT *lower_range;
\par       FONT *upper_range;
\par       FONT *capitals;
\par       FONT *combined_font;
\par       FONT *tempfont;
\par       ...
\par       /* Create a font that contains the capitals from  */
\par       /* the fancy font but other characters from myfont */
\par       lower_range = extract_font_range(myfont, -1, 'A'-1);
\par       upper_range = extract_font_range(myfont, 'Z'+1, -1);
\par       capitals = extract_font_range(myfancy_font, 'A', 'Z');
\par 
\par       tempfont = merge_fonts(lower_range, capitals);
\par       combined_font = merge_fonts(tempfont, upper_range);
\par 
\par       /* Clean up temporary fonts */
\par       destroy_font(lower_range);
\par       destroy_font(upper_range);
\par       destroy_font(capitals);
\par       destroy_font(tempfont);\par}
\par Returns a pointer to the new font or NULL on error. Remember that you are 
responsible for destroying the font when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b FONT *{\xe\v load_dat_font}load_dat_font(const char *filename, RGB *pal, void *param)\par }
{\li400 Loads a FONT from an Allegro datafile. You can set param parameter to 
point to an array that holds two strings that identify the font and the 
palette in the datafile by name. 
The first string in this list is the name of the font. You can pass NULL 
here to just load the first font found in the datafile. The second string 
can be used to specify the name of the palette associated with the font. 
This is only returned if the pal parameter is not NULL. If you pass NULL 
for the name of the palette, the last palette found before the font was 
found is returned. 
You can also pass NULL for param, which is treated as if you had passed 
NULL for both strings separately. In this case, the function will simply 
load the first font it finds from the datafile and the palette that 
precedes it. 
\par \par For example, suppose you have a datafile named `fonts.dat' with the 
following contents: 
\par {\s1 \f1\fs18 
\par       FONT  FONT_1_DATA
\par       FONT  FONT_2_DATA
\par       FONT  FONT_3_DATA
\par       PAL   FONT_1_PALETTE
\par       PAL   FONT_2_PALETTE
\par }\par Then the following code will load FONT_1_DATA as a FONT and return 
FONT_1_PALETTE as the palette: 
\par {\s1 \f1\fs18 
\par       FONT *f;
\par       PALETTE pal;
\par       char *names[] = \{ "FONT_1_DATA", "FONT_1_PALETTE" \}
\par       
\par       f = load_dat_font("fonts.dat", pal, names);
\par }\par If instead you want to load the second font, FONT_2, from the datafile, 
you would use: 
\par {\s1 \f1\fs18 
\par       FONT *f;
\par       PALETTE pal;
\par       char *names[] = \{ "FONT_2_DATA", "FONT_2_PALETTE" \}
\par       
\par       f = load_dat_font("fonts.dat", pal, names);
\par }\par If you want to load the third font, but not bother with a palette, use: 
\par {\s1 \f1\fs18 
\par       FONT *f;
\par       char *names[] = \{ "FONT_3_DATA", NULL \}
\par       
\par       f = load_dat_font("fonts.dat", NULL, names);\par}
\par Returns a pointer to the font or NULL on error. Remember that you are 
responsible for destroying the font when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b FONT *{\xe\v load_bios_font}load_bios_font(const char *filename, RGB *pal, void *param)\par }
{\li400 Loads a 8x8 or 8x16 BIOS format font. You shouldn't normally call this 
routine directly. 
\par \par Returns a pointer to the font or NULL on error. Remember that you are 
responsible for destroying the font when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b FONT *{\xe\v load_grx_font}load_grx_font(const char *filename, RGB *pal, void *param)\par }
{\li400 Loads a GRX format font. You shouldn't normally call this routine 
directly. 
\par \par Returns a pointer to the font or NULL on error. Remember that you are 
responsible for destroying the font when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b FONT *{\xe\v load_grx_or_bios_font}load_grx_or_bios_font(const char *filename, RGB *pal, void *param)\par }
{\li400 Loads either a BIOS or GRX format font. You shouldn't normally call this 
routine directly. 
\par \par Returns a pointer to the font or NULL on error. Remember that you are 
responsible for destroying the font when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b FONT *{\xe\v load_bitmap_font}load_bitmap_font(const char *filename, RGB *pal, void *param)\par }
{\li400 Tries to grab a font from a bitmap. The bitmap can be in any format that 
load_bitmap understands. 
\par \par The size of each character is determined by the layout of the image, which 
should be a rectangular grid containing all the ASCII characters from 
space (32) up to the tilde (126). The way the characters are separated 
depends on the color depth of the image file: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 paletted (8 bit) image file 
Use color 0 for the transparent portions of the characters and fill the 
spaces between each letter with color 255.  
\par \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 High (15/16 bit) and true (24/32 bit) color image file 
Use bright pink (maximum red and blue, zero green) for the transparent 
portions of the characters and fill the spaces between each letter with 
bright yellow (maximum red and green, zero blue). 
\par}\pard \li400 \par \par \par Note that in each horizontal row the bounding boxes around the characters 
should align and have the same height. 
\par \par Probably the easiest way to get to grips with how this works is to load up 
the `demo.dat' file and export the TITLE_FONT into a PCX file. Have a look 
at the resulting picture in your paint program: that is the format a font 
should be in. 
\par \par Take care with high and true color fonts: Allegro will convert these to the 
current color depth when you load the font. If you try to use a font on 
a bitmap with a different color depth Allegro will do color conversions on 
the fly, which will be rather slow. For optimal performance you should 
set the color depth to the color depth you want to use before loading any 
fonts. 
\par \par Returns a pointer to the font or NULL on error. Remember that you are 
responsible for destroying the font when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b FONT *{\xe\v grab_font_from_bitmap}grab_font_from_bitmap(BITMAP *bmp)\par }
{\li400 This function is the work-horse of load_bitmap_font, and can be used to 
grab a font from a bitmap in memory. You can use this if you want to 
generate or modify a font at runtime. The bitmap should follow the layout 
described for load_bitmap_font. 
\par \par Returns a pointer to the font or NULL on error. Remember that you are 
responsible for destroying the font when you are finished with it to 
avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b FONT *{\xe\v load_txt_font}load_txt_font(const char *filename, RGB *pal, void *param)\par }
{\li400 This function can be used to load scripted fonts. The script file 
contains a number of lines in the format "filename start end", which 
specify the source file for that range of characters, the Unicode value of 
the first character in the range, and the end character in the range 
(optional, if left out, the entire input file will be grabbed). If the 
filename is replaced by a hyphen, more characters will be grabbed from the 
previous input file. 
For example, the script: 
\par {\s1 \f1\fs18 
\par       ascii.fnt 0x20 0x7F
\par       - 0xA0 0xFF
\par       dingbats.fnt 0x1000
\par    \par}would import the first 96 characters from ascii.fnt as the range 
0x20-0x7F, the next 96 characters from ascii.fnt as the range 0xA0-0xFF, 
and the entire contents of dingbats.fnt starting at Unicode position 
0x1000. 
\par \par Returns a pointer to the font or NULL on error. Remember that you are 
responsible for destroying the font when you are finished with it to 
avoid memory leaks. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Text output}Text output\par }
Allegro provides text output routines that work with both monochrome and 
color fonts, which can contain any number of Unicode character ranges. The 
grabber program can create fonts from sets of characters drawn in a bitmap 
file (see grabber.txt for more information), and can also import GRX or BIOS 
format font files. The font structure contains a number of hooks that can be 
used to extend it with your own custom drawing code: see the definition in 
allegro/text.h for details. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b extern FONT *{\xe\v font}font;\par }
{\li400 A simple 8x8 fixed size font (the mode 13h BIOS default). If you want to 
alter the font used by the GUI routines, change this to point to one of 
your own fonts. This font contains the standard ASCII (U+20 to U+7F), 
Latin-1 (U+A1 to U+FF), and Latin Extended-A (U+0100 to U+017F) character 
ranges. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v allegro_404_char}allegro_404_char;\par }
{\li400 When Allegro cannot find a glyph it needs in a font, it will instead 
output the character given in allegro_404_char. By default, this is set to 
the caret symbol, `^', but you can change this global to use any other 
character instead. Example: 
\par {\s1 \f1\fs18 
\par       /* Show unknown glyphs with an asterisk. */
\par       allegro_404_char = '*';\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v text_length}text_length(const FONT *f, const char *str);\par }
{\li400 Returns the length (in pixels) of a string in the specified font. Example: 
\par {\s1 \f1\fs18 
\par       int width = text_length(font, "I love spam");
\par       ...
\par       bmp = create_bitmap(width, height);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v text_height}text_height(const FONT *f)\par }
{\li400 Returns the height (in pixels) of the specified font. Example: 
\par {\s1 \f1\fs18 
\par       int height = text_height(font);
\par       ...
\par       bmp = create_bitmap(width, height);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v textout_ex}textout_ex(BITMAP *bmp, const FONT *f, const char *s, int x, int y, int color, int bg);\par }
{\li400 Writes the string `s' onto the bitmap at position x, y, using the 
specified font, foreground color and background color. If the background 
color is -1, then the text is written transparently. If the foreground 
color is -1 and a color font is in use, it will be drawn using the colors 
from the original font bitmap (the one you imported into the grabber 
program), which allows multicolored text output. For high and true color 
fonts, the foreground color is ignored and always treated as -1. Example: 
\par {\s1 \f1\fs18 
\par       /* Show the program's version in blue letters. */
\par       textout_ex(screen, font, "v4.2.0-beta2", 10, 10,
\par                  makecol(0, 0, 255), -1);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v textout_centre_ex}textout_centre_ex(BITMAP *bmp, const FONT *f, const char *s, int x, y, int color, int bg);\par }
{\li400 Like textout_ex(), but interprets the x coordinate as the centre rather 
than the left edge of the string. Example: 
\par {\s1 \f1\fs18 
\par       /* Important texts go in the middle. */
\par       width = text_length("GAME OVER");
\par       textout_centre_ex(screen, font, "GAME OVER",
\par                         SCREEN_W / 2, SCREEN_H / 2,
\par                         makecol(255, 0, 0), makecol(0, 0, 0));\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v textout_right_ex}textout_right_ex(BITMAP *bmp, const FONT *f, const char *s, int x, int y, int color, int bg);\par }
{\li400 Like textout_ex(), but interprets the x coordinate as the right rather 
than the left edge of the string. Example: 
\par {\s1 \f1\fs18 
\par       textout_right_ex(screen, font, "Look at this color!",
\par                        SCREEN_W - 10, 10, my_yellow, -1);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v textout_justify_ex}textout_justify_ex(BITMAP *bmp, const FONT *f, const char *s, int x1, int x2, int y, int diff, int color, int bg);\par }
{\li400 Draws justified text within the region x1-x2. If the amount of spare 
space is greater than the diff value, it will give up and draw regular 
left justified text instead. Example: 
\par {\s1 \f1\fs18 
\par       char *lines[] = \{"Draws justified text",
\par                        "within the specified",
\par                        "x2-x1 area. But not",
\par                        "T H I S !", NULL\};
\par       /* Show the justification marker. */
\par       vline(screen, 200, 0, SCREEN_H-1, makecol(0, 0, 0));
\par       /* Draw all the lines until we reach a NULL entry. */
\par       for (num = 0, y = 0; lines[num]; num++, y += text_height(font))
\par          textout_justify_ex(screen, font, lines[num], 0, 200,
\par                             y, 80, makecol(0, 0, 0),
\par                             makecol(255, 255, 255));\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v textprintf_ex}textprintf_ex(BITMAP *bmp, const FONT *f, int x, int y, int color, int bg, const char *fmt, ...);\par }
{\li400 Formatted text output, using a printf() style format string. Due to an 
internal limitation, this function can't be used for extremely long texts. 
If you happen to reach this limit, you can work around it by using 
uszprintf() and textout_ex(), which don't have any. Example: 
\par {\s1 \f1\fs18 
\par       int player_score;
\par       ...
\par       textprintf_ex(screen, font, 10, 10, makecol(255, 100, 200),
\par                     -1, "Score: %d", player_score);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v textprintf_centre_ex}textprintf_centre_ex(BITMAP *bmp, const FONT *f, int x, int y, int color, int bg, const char *fmt, ...);\par }
{\li400 Like textprintf_ex(), but interprets the x coordinate as the centre rather 
than the left edge of the string. This function shares the text length 
limitation of textprintf_ex(). Example: 
\par {\s1 \f1\fs18 
\par       textprintf_centre_ex(screen, font, SCREEN_W / 2, 120,
\par                            makecol(0, 100, 243), -1,
\par                            "Your best score so far was %d!",
\par                            total_max_points);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v textprintf_right_ex}textprintf_right_ex(BITMAP *bmp, const FONT *f, int x, y, color, bg, const char *fmt, ...);\par }
{\li400 Like textprintf_ex(), but interprets the x coordinate as the right rather 
than the left edge of the string. This function shares the text length 
limitation of textprintf_ex(). Example: 
\par {\s1 \f1\fs18 
\par       textprintf_right_ex(screen, font, SCREEN_W - 10, 10,
\par                           makecol(200, 200, 20), -1,
\par                           "%d bullets left", player_ammo);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v textprintf_justify_ex}textprintf_justify_ex(BITMAP *bmp, const FONT *f, int x1, x2, y, diff, color, bg, const char *fmt, ...);\par }
{\li400 Like textout_justify_ex(), but using a printf() style format string. This 
function shares the text length limitation of textprintf_ex(). Example: 
\par {\s1 \f1\fs18 
\par       char *lines[] = \{"Line %02d: Draws justified text",
\par                        "Line %02d: within the specified",
\par                        "Line %02d: x2-x1 area. But not",
\par                        "Line %02d: T H I S !", NULL\};
\par       /* Show the justification marker. */
\par       vline(screen, 300, 0, SCREEN_H-1, makecol(0, 0, 0));
\par       /* Draw all the lines until we reach a NULL entry. */
\par       for (num = 0, y = 0; lines[num]; num++, y += text_height(font))
\par          textprintf_justify_ex(screen, font, 0, 300, y, 180,
\par                                makecol(0, 0, 0), makecol(255, 255, 255),
\par                                lines[num], num);\par}
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Polygon rendering}Polygon rendering\par }
All the 3d functions that accept a `type' parameter are asking for a polygon 
rendering mode, which can be any of the following POLYTYPE_* values. If the 
CPU_MMX flag of the cpu_capabilities global variable is set, the GRGB and 
truecolor *LIT routines will be optimised using MMX instructions. If the 
CPU_3DNOW flag is set, the truecolor PTEX*LIT routines will take advantage of 
the 3DNow! CPU extensions. 
\par \par Using MMX for *LIT routines has a side effect: normally (without MMX), these 
routines use the blender functions used also for other lighting functions, 
set with set_trans_blender() or set_blender_mode(). The MMX versions only use 
the RGB value passed to set_trans_blender() and do the linear interpolation 
themselves. Therefore a new set of blender functions passed to 
set_blender_mode() is ignored. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b #define {\xe\v POLYTYPE_FLAT}POLYTYPE_FLAT\par }
{\li400 A simple flat shaded polygon, taking the color from the `c' value of the 
first vertex. This polygon type is affected by the drawing_mode() function, 
so it can be used to render XOR or translucent polygons. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b #define {\xe\v POLYTYPE_GCOL}POLYTYPE_GCOL\par }
{\li400 A single-color gouraud shaded polygon. The colors for each vertex are taken 
from the `c' value, and interpolated across the polygon. This is very fast, 
but will only work in 256-color modes if your palette contains a smooth 
gradient between the colors. In truecolor modes it interprets the color as 
a packed, display-format value as produced by the makecol() function. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b #define {\xe\v POLYTYPE_GRGB}POLYTYPE_GRGB\par }
{\li400 A gouraud shaded polygon which interpolates RGB triplets rather than a 
single color. In 256-color modes this uses the global rgb_map table to 
convert the result to an 8-bit paletted color, so it must only be used 
after you have set up the RGB mapping table! The colors for each vertex are 
taken from the `c' value, which is interpreted as a 24-bit RGB triplet 
(0xFF0000 is red, 0x00FF00 is green, and 0x0000FF is blue). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b #define {\xe\v POLYTYPE_ATEX}POLYTYPE_ATEX\par }
{\li400 An affine texture mapped polygon. This stretches the texture across the 
polygon with a simple 2d linear interpolation, which is fast but not 
mathematically correct. It can look OK if the polygon is fairly small or 
flat-on to the camera, but because it doesn't deal with perspective 
foreshortening, it can produce strange warping artifacts. To see what this 
means, run Allegro's test program and see what happens to the polygon3d() 
test when you zoom in very close to the cube. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b #define {\xe\v POLYTYPE_PTEX}POLYTYPE_PTEX\par }
{\li400 A perspective-correct texture mapped polygon. This uses the `z' value from 
the vertex structure as well as the u/v coordinates, so textures are 
displayed correctly regardless of the angle they are viewed from. Because 
it involves division calculations in the inner texture mapping loop, this 
mode is a lot slower than POLYTYPE_ATEX, and it uses floating point so it 
will be very slow on anything less than a Pentium (even with an FPU, a 486 
can't overlap floating point division with other integer operations like 
the Pentium can). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 #define {\xe\v POLYTYPE_ATEX_MASK}POLYTYPE_ATEX_MASK\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 #define {\xe\v POLYTYPE_PTEX_MASK}POLYTYPE_PTEX_MASK\par }
{\li400 Like POLYTYPE_ATEX and POLYTYPE_PTEX, but zero texture map pixels are 
skipped, allowing parts of the texture map to be transparent. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 #define {\xe\v POLYTYPE_ATEX_LIT}POLYTYPE_ATEX_LIT\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 #define {\xe\v POLYTYPE_PTEX_LIT}POLYTYPE_PTEX_LIT\par }
{\li400 Like POLYTYPE_ATEX and POLYTYPE_PTEX, but the global color_map table (for 
256-color modes) or blender function (for non-MMX truecolor modes) is used 
to blend the texture with a light level taken from the `c' value in the 
vertex structure. This must only be used after you have set up the color 
mapping table or blender functions! 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 #define {\xe\v POLYTYPE_ATEX_MASK_LIT}POLYTYPE_ATEX_MASK_LIT\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 #define {\xe\v POLYTYPE_PTEX_MASK_LIT}POLYTYPE_PTEX_MASK_LIT\par }
{\li400 Like POLYTYPE_ATEX_LIT and POLYTYPE_PTEX_LIT, but zero texture map pixels 
are skipped, allowing parts of the texture map to be transparent. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 #define {\xe\v POLYTYPE_ATEX_TRANS}POLYTYPE_ATEX_TRANS\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 #define {\xe\v POLYTYPE_PTEX_TRANS}POLYTYPE_PTEX_TRANS\par }
{\li400 Render translucent textures. All the general rules for drawing 
translucent things apply. However, these modes have a major 
limitation: they only work with memory bitmaps or linear frame 
buffers (not with banked frame buffers). Don't even try, they do not 
check and your program will die horribly (or at least draw wrong 
things). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 #define {\xe\v POLYTYPE_ATEX_MASK_TRANS}POLYTYPE_ATEX_MASK_TRANS\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 #define {\xe\v POLYTYPE_PTEX_MASK_TRANS}POLYTYPE_PTEX_MASK_TRANS\par }
{\li400 Like POLYTYPE_ATEX_TRANS and POLYTYPE_PTEX_TRANS, but zero texture map 
pixels are skipped. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v polygon3d}polygon3d(BITMAP *bmp, int type, BITMAP *texture, int vc, V3D *vtx[]);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v polygon3d_f}polygon3d_f(BITMAP *bmp, int type, BITMAP *texture, int vc, V3D_f *vtx[]);\par }
{\li400 Draw 3d polygons onto the specified bitmap, using the specified rendering 
mode. Unlike the regular polygon() function, these routines don't support 
concave or self-intersecting shapes, and they can't draw onto mode-X 
screen bitmaps (if you want to write 3d code in mode-X, draw onto a 
memory bitmap and then blit to the screen). The width and height of the 
texture bitmap must be powers of two, but can be different, eg. a 64x16 
texture is fine, but a 17x3 one is not. The vertex count parameter (vc) 
should be followed by an array containing the appropriate number of 
pointers to vertex structures: polygon3d() uses the fixed point V3D 
structure, while polygon3d_f() uses the floating point V3D_f structure. 
These are defined as: 
\par {\s1 \f1\fs18 
\par       typedef struct V3D
\par       \{
\par          fixed x, y, z;       - position
\par          fixed u, v;          - texture map coordinates
\par          int c;               - color
\par       \} V3D;
\par    
\par       typedef struct V3D_f
\par       \{
\par          float x, y, z;       - position
\par          float u, v;          - texture map coordinates
\par          int c;               - color
\par       \} V3D_f;
\par }\par How the vertex data is used depends on the rendering mode: 
\par \par The `x' and `y' values specify the position of the vertex in 2d screen 
coordinates. 
\par \par The `z' value is only required when doing perspective correct texture 
mapping, and specifies the depth of the point in 3d world coordinates. 
\par \par The `u' and `v' coordinates are only required when doing texture mapping, 
and specify a point on the texture plane to be mapped on to this vertex. 
The texture plane is an infinite plane with the texture bitmap tiled 
across it. Each vertex in the polygon has a corresponding vertex on the 
texture plane, and the image of the resulting polygon in the texture plane 
will be mapped on to the polygon on the screen. 
\par \par We refer to pixels in the texture plane as texels. Each texel is a block, 
not just a point, and whole numbers for u and v refer to the top-left 
corner of a texel. This has a few implications. If you want to draw a 
rectangular polygon and map a texture sized 32x32 on to it, you would use 
the texture coordinates (0,0), (0,32), (32,32) and (32,0), assuming the 
vertices are specified in anticlockwise order. The texture will then be 
mapped perfectly on to the polygon. However, note that when we set u=32, 
the last column of texels seen on the screen is the one at u=31, and the 
same goes for v. This is because the coordinates refer to the top-left 
corner of the texels. In effect, texture coordinates at the right and 
bottom on the texture plane are exclusive. 
\par \par There is another interesting point here. If you have two polygons side 
by side sharing two vertices (like the two parts of folded piece of 
cardboard), and you want to map a texture across them seamlessly, the 
values of u and v on the vertices at the join will be the same for both 
polygons. For example, if they are both rectangular, one polygon may use 
(0,0), (0,32), (32,32) and (32,0), and the other may use (32,0), (32,32), 
(64,32), (64,0). This would create a seamless join. 
\par \par Of course you can specify fractional numbers for u and v to indicate a 
point part-way across a texel. In addition, since the texture plane is 
infinite, you can specify larger values than the size of the texture. 
This can be used to tile the texture several times across the polygon. 
\par \par The `c' value specifies the vertex color, and is interpreted differently 
by various rendering modes. Read the beginning of chapter "Polygon 
rendering" for a list of rendering types you can use with this function. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v triangle3d}triangle3d(BITMAP *bmp, int type, BITMAP *tex, V3D *v1, *v2, *v3);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v triangle3d_f}triangle3d_f(BITMAP *bmp, int type, BITMAP *tex, V3D_f *v1, *v2, *v3);\par }
{\li400 Draw 3d triangles, using either fixed or floating point vertex structures. 
Unlike quad3d[_f](), triangle3d[_f]() functions are not wrappers of 
polygon3d[_f](). The triangle3d[_f]() functions use their own routines 
taking into account the constantness of the gradients. Therefore 
triangle3d[_f](bmp, type, tex, v1, v2, v3) is faster than 
polygon3d[_f](bmp, type, tex, 3, v[]). 
\par \par Read the beginning of chapter "Polygon rendering" for a list of rendering 
types you can use with this function. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v quad3d}quad3d(BITMAP *bmp, int type, BITMAP *tex, V3D *v1, *v2, *v3, *v4);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v quad3d_f}quad3d_f(BITMAP *bmp, int type, BITMAP *tex, V3D_f *v1, *v2, *v3, *v4);\par }
{\li400 Draw 3d quads, using either fixed or floating point vertex structures. 
These are equivalent to calling polygon3d(bmp, type, tex, 4, v[]) or 
polygon3d_f(bmp, type, tex, 4, v[]). 
\par \par Read the beginning of chapter "Polygon rendering" for a list of rendering 
types you can use with this function. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v clip3d_f}clip3d_f(int type, float min_z, float max_z, int vc, const V3D_f *vtx[], V3D_f *vout[], V3D_f *vtmp[], int out[]);\par }
{\li400 Clips the polygon given in `vtx'. The number of vertices is `vc', the 
result goes in `vout', and `vtmp' and `out' are needed for internal 
purposes. The pointers in `vtx', `vout' and `vtmp' must point to valid 
V3D_f structures. 
\par \par As additional vertices may appear in the process of clipping, so the 
size of `vout', `vtmp' and `out' should be at least vc * (1.5 ^ n), where 
`n' is the number of clipping planes (5 or 6), and `^' denotes "to the 
power of". 
\par \par The frustum (viewing volume) is defined by -z<x<z, -z<y<z, 
0<min_z<z<max_z. If  max_z<=min_z, the z<max_z clipping is 
not done. As you can see, clipping is done in the camera space, with 
perspective in mind, so this routine should be called after you apply 
the camera matrix, but before the perspective projection. The routine 
will correctly interpolate u, v, and c in the vertex structure. However, 
no provision is made for high/truecolor GCOL. 
\par \par Returns the number of vertices after clipping is done. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v clip3d}clip3d(int type, fixed min_z, fixed max_z, int vc, const V3D *vtx[], V3D *vout[], V3D *vtmp[], int out[]);\par }
{\li400 Fixed point version of clip3d_f(). This function should be used with 
caution, due to the limited precision of fixed point arithmetic and high 
chance of rounding errors: the floating point code is better for most 
situations. 
\par \par Returns the number of vertices after clipping is done. 
\par}\par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v Zbuffered rendering}
A Z-buffer stores the depth of each pixel that is drawn on a viewport. 
When a 3D object is rendered, the depth of each of its pixels is compared 
against the value stored into the Z-buffer: if the pixel is closer it is 
drawn, otherwise it is skipped. 
\par \par No polygon sorting is needed. However, backface culling should be done 
because it prevents many invisible polygons being compared against the 
Z-buffer. Z-buffered rendering is the only algorithm supported by Allegro 
that directly solves penetrating shapes (see example exzbuf.c, for instance). 
The price to pay is more complex (and slower) routines. 
\par \par Z-buffered polygons are designed as an extension of the normal POLYTYPE_* 
rendering styles. Just OR the POLYTYPE with the value POLYTYPE_ZBUF, and 
the normal polygon3d(), polygon3d_f(), quad3d(), etc. functions will 
render z-buffered polygons. 
\par \par Example: 
\par {\s1 \f1\fs18 
\par    polygon3d(bmp, POLYTYPE_ATEX | POLYTYPE_ZBUF, tex, vc, vtx);\par}
\par Of course, the z coordinates have to be valid regardless of rendering style. 
\par \par A Z-buffered rendering procedure looks like a double-buffered rendering 
procedure. You should follow four steps: create a Z-buffer at the beginning 
of the program and make the library use it by calling set_zbuffer(). Then, 
for each frame, clear the Z-buffer and draw polygons with 
POLYTYPE_* | POLYTYPE_ZBUF and finally destroy the Z-buffer when leaving the 
program. 
\par \par Notes on Z-buffered renderers: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Unlike the normal POLYTYPE_FLAT renderers, the Z-buffered ones don't use 
the hline() routine. Therefore DRAW_MODE has no effect. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 The *LIT* routines work the traditional way - through the set of 
blender routines. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 All the Z-buffered routines are much slower than their normal counterparts 
(they all use the FPU to interpolate and test 1/z values). 
\par}\pard \li0 \par {\s3 \f0\fs24\sb200\keepn\sa200\b ZBUFFER *{\xe\v create_zbuffer}create_zbuffer(BITMAP *bmp);\par }
{\li400 Creates a Z-buffer using the size of the BITMAP you are planning to draw 
on. Several Z-buffers can be defined but only one can be used at the same 
time, so you must call set_zbuffer() to make this Z-buffer active. 
\par \par Returns the pointer to the ZBUFFER or NULL if there was an error. Remember 
to destroy the ZBUFFER once you are done with it, to avoid having memory 
leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b ZBUFFER *{\xe\v create_sub_zbuffer}create_sub_zbuffer(ZBUFFER *parent, int x, int y, int width, int height);\par }
{\li400 Creates a sub-z-buffer, ie. a z-buffer sharing drawing memory with a 
pre-existing z-buffer, but possibly with a different size. The same rules 
as for sub-bitmaps apply: the sub-z-buffer width and height can extend 
beyond the right and bottom edges of the parent (they will be clipped), 
but the origin point must lie within the parent region. 
\par \par When drawing z-buffered to a bitmap, the top left corner of the bitmap is 
always mapped to the top left corner of the current z-buffer. So this 
function is primarily useful if you want to draw to a sub-bitmap and use 
the corresponding sub-area of the z-buffer. In other cases, eg. if you 
just want to draw to a sub-bitmap of screen (and not to other parts of 
screen), then you would usually want to create a normal z-buffer (not 
sub-z-buffer) the size of the visible screen. You don't need to first 
create a z-buffer the size of the virtual screen and then a sub-z-buffer 
of that. 
\par \par Returns the pointer to the sub ZBUFFER or NULL if there was an error. 
Remember to destroy the ZBUFFER once you are done with it, to avoid having 
memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_zbuffer}set_zbuffer(ZBUFFER *zbuf);\par }
{\li400 Makes the given Z-buffer be the active one. This should have been 
previously created with create_zbuffer(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v clear_zbuffer}clear_zbuffer(ZBUFFER *zbuf, float z);\par }
{\li400 Writes z into the given Z-buffer (0 means far away). This function should 
be used to initialize the Z-buffer before each frame. Actually, low-level 
routines compare depth of the current pixel with 1/z: for example, if you 
want to clip polygons farther than 10, you must call 
clear_zbuffer(zbuf, 0.1). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v destroy_zbuffer}destroy_zbuffer(ZBUFFER *zbuf);\par }
{\li400 Destroys the Z-buffer when you are finished with it. Use this to avoid 
memory leaks in your program. 
\par}\par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v Scene rendering}
Allegro provides two simple approaches to remove hidden surfaces: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Z-buffering - (see above) 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Scan-line algorithms - along each scanline on your screen, you keep 
track of what polygons you are "in" and which is the nearest. This 
status changes only where the scanline crosses some polygon edge. So you 
have to juggle an edge list and a polygon list. And you have to sort the 
edges for each scanline (this can be countered by keeping the order of 
the previous scanline - it won't change much). The BIG advantage is that 
you write each pixel only once. If you have a lot of overlapping 
polygons you can get incredible speeds compared to any of the previous 
algorithms. This algorithm is covered by the *_scene routines. 
\par}\pard \li0 \par \par \par The scene rendering has approximately the following steps: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Initialize the scene (set the clip area, clear the bitmap, blit a 
background, etc.) 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Call clear_scene(). 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Transform all your points to camera space. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Clip polygons. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Project with persp_project() or persp_project_f(). 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 "Draw" polygons with scene_polygon3d() and/or scene_polygon3d_f(). 
This doesn't do any actual drawing, only initializes tables. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Render all the polygons defined previously to the bitmap with 
render_scene(). 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Overlay some non-3D graphics. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Show the bitmap (blit it to screen, flip the page, etc). 
\par}\pard \li0 \par \par \par For each horizontal line in the viewport an x-sorted edge list is used to 
keep track of what polygons are "in" and which is the nearest. Vertical 
coherency is used - the edge list for a scanline is sorted starting from 
the previous one - it won't change much. The scene rendering routines use 
the same low-level asm routines as normal polygon3d(). 
\par \par Notes on scene rendering: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Unlike polygon3d(), scene_polygon3d() requires valid z coordinates 
for all vertices, regardless of rendering style (unlike 
polygon3d(), which only uses z coordinate for *PTEX*). 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 All polygons passed to scene_polygon3d() have to be 
persp_project()'ed. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 After render_scene() the mode is reset to SOLID. 
\par}\pard \li0 \par Using a lot of *MASK* polygons drastically reduces performance, because 
when a MASKed polygon is the first in line of sight, the polygons 
underneath have to be drawn too. The same applies to FLAT polygons drawn 
with DRAW_MODE_TRANS. 
\par \par Z-buffered rendering works also within the scene renderer. It may be 
helpful when you have a few intersecting polygons, but most of the 
polygons may be safely rendered by the normal scanline sorting algorithm. 
Same as before: just OR the POLYTYPE with POLYTYPE_ZBUF. Also, you 
have to clear the z-buffer at the start of the frame. Example: 
\par {\s1 \f1\fs18 
\par    clear_scene(buffer);
\par    if (some_polys_are_zbuf) clear_zbuffer(0.);
\par    while (polygons) \{
\par       ...
\par       if (this_poly_is_zbuf) type |= POLYTYPE_ZBUF;
\par       scene_polygon3d(type, tex, vc, vtx);
\par    \}
\par    render_scene();\par}
\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v create_scene}create_scene(int nedge, int npoly);\par }
{\li400 Allocates memory for a scene, `nedge' and `npoly' are your estimates of how 
many edges and how many polygons you will render (you cannot get over the 
limit specified here). If you use same values in successive calls, the 
space will be reused (no new malloc()). 
\par \par The memory allocated is a little less than 150 * (nedge + npoly) bytes. 
\par \par Returns zero on success, or a negative number if allocations fail. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v clear_scene}clear_scene(BITMAP *bmp);\par }
{\li400 Initializes a scene. The bitmap is the bitmap you will eventually render 
on. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v destroy_scene}destroy_scene();\par }
{\li400 Deallocate memory previously allocated by create_scene. Use this to avoid 
memory leaks in your program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 int {\xe\v scene_polygon3d}scene_polygon3d(int type, BITMAP *texture, int vc, V3D *vtx[]);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 int {\xe\v scene_polygon3d_f}scene_polygon3d_f(int type, BITMAP *texture, int vc, V3D_f *vtx[]);\par }
{\li400 Puts a polygon in the rendering list. Nothing is really rendered at this 
moment. Should be called between clear_scene() and render_scene(). 
\par \par Arguments are the same as for polygon3d(), except the bitmap is missing. 
The one passed to clear_scene() will be used. 
\par \par Unlike polygon3d(), the polygon may be concave or self-intersecting. 
Shapes that penetrate one another may look OK, but they are not really 
handled by this code. 
\par \par Note that the texture is stored as a pointer only, and you should keep 
the actual bitmap around until render_scene(), where it is used. 
\par \par Since the FLAT style is implemented with the low-level hline() function, 
the FLAT style is subject to DRAW_MODEs. All these modes are valid. Along 
with the polygon, this mode will be stored for the rendering moment, and 
also all the other related variables (color_map pointer, pattern pointer, 
anchor, blender values). 
\par \par The settings of the CPU_MMX and CPU_3DNOW flags of the cpu_capabilities 
global variable on entry in this routine affect the choice of low-level 
asm routine that will be used by render_scene() for this polygon. 
\par \par Returns zero on success, or a negative number if it won't be rendered for 
lack of a rendering routine. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v render_scene}render_scene();\par }
{\li400 Renders all the specified scene_polygon3d()'s on the bitmap passed to 
clear_scene(). Rendering is done one scanline at a time, with no pixel 
being processed more than once. 
\par \par Note that between clear_scene() and render_scene() you shouldn't change 
the clip rectangle of the destination bitmap. For speed reasons, you 
should set the clip rectangle to the minimum. 
\par \par Note also that all the textures passed to scene_polygon3d() are stored as 
pointers only and actually used in render_scene(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern float {\xe\v scene_gap}scene_gap;\par }
{\li400 This number (default value = 100.0) controls the behaviour of the 
z-sorting algorithm. When an edge is very close to another's polygon 
plane, there is an interval of uncertainty in which you cannot tell which 
object is visible (which z is smaller). This is due to cumulative 
numerical errors for edges that have undergone a lot of transformations 
and interpolations. 
\par \par The default value means that if the 1/z values (in projected space) 
differ by only 1/100 (one percent), they are considered to be equal and 
the x-slopes of the planes are used to find out which plane is getting 
closer when we move to the right. 
\par \par Larger values means narrower margins, and increasing the chance of 
missing true adjacent edges/planes. Smaller values means larger margins, 
and increasing the chance of mistaking close polygons for adjacent ones. 
The value of 100 is close to the optimum. However, the optimum shifts 
slightly with resolution, and may be application-dependent. It is here 
for you to fine-tune. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Transparency and patterned drawing}Transparency and patterned drawing\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v drawing_mode}drawing_mode(int mode, BITMAP *pattern, int x_anchor, int y_anchor);\par }
{\li400 Sets the graphics drawing mode. This only affects the geometric routines 
like putpixel, lines, rectangles, circles, polygons, floodfill, etc, not 
the text output, blitting, or sprite drawing functions. The mode should 
be one of the following constants: 
\par {\s1 \f1\fs18 
\par       DRAW_MODE_SOLID               - the default, solid color
\par                                       drawing
\par       DRAW_MODE_XOR                 - exclusive-or drawing
\par       DRAW_MODE_COPY_PATTERN        - multicolored pattern fill
\par       DRAW_MODE_SOLID_PATTERN       - single color pattern fill
\par       DRAW_MODE_MASKED_PATTERN      - masked pattern fill
\par       DRAW_MODE_TRANS               - translucent color blending
\par }\par In DRAW_MODE_SOLID, pixels of the bitmap being drawn onto are simply 
replaced by those produced by the drawing function. 
\par \par In DRAW_MODE_XOR, pixels are written to the bitmap with an exclusive-or 
operation rather than a simple copy, so drawing the same shape twice will 
erase it. Because it involves reading as well as writing the bitmap 
memory, xor drawing is a lot slower than the normal replace mode. 
\par \par With the patterned modes, you provide a pattern bitmap which is tiled 
across the surface of the shape. Allegro stores a pointer to this bitmap 
rather than copying it, so you must not destroy the bitmap while it is 
still selected as the pattern. The width and height of the pattern must 
be powers of two, but they can be different, eg. a 64x16 pattern is fine, 
but a 17x3 one is not. The pattern is tiled in a grid starting at point 
(x_anchor, y_anchor). Normally you should just pass zero for these 
values, which lets you draw several adjacent shapes and have the patterns 
meet up exactly along the shared edges. Zero alignment may look peculiar 
if you are moving a patterned shape around the screen, however, because 
the shape will move but the pattern alignment will not, so in some 
situations you may wish to alter the anchor position. 
\par \par When you select DRAW_MODE_COPY_PATTERN, pixels are simply copied from the 
pattern bitmap onto the destination bitmap. This allows the use of 
multicolored patterns, and means that the color you pass to the drawing 
routine is ignored. This is the fastest of the patterned modes. 
\par \par In DRAW_MODE_SOLID_PATTERN, each pixel in the pattern bitmap is compared 
with the mask color, which is zero in 256-color modes or bright pink for 
truecolor data (maximum red and blue, zero green). If the pattern pixel 
is solid, a pixel of the color you passed to the drawing routine is 
written to the destination bitmap, otherwise a zero is written. The 
pattern is thus treated as a monochrome bitmask, which lets you use the 
same pattern to draw different shapes in different colors, but prevents 
the use of multicolored patterns. 
\par \par DRAW_MODE_MASKED_PATTERN is almost the same as DRAW_MODE_SOLID_PATTERN, 
but the masked pixels are skipped rather than being written as zeros, so 
the background shows through the gaps. 
\par \par In DRAW_MODE_TRANS, the global color_map table or truecolor blender 
functions are used to overlay pixels on top of the existing image. This 
must only be used after you have set up the color mapping table (for 256 
color modes) or blender functions (for truecolor modes). Because it 
involves reading as well as writing the bitmap memory, translucent 
drawing is very slow if you draw directly to video RAM, so wherever 
possible you should use a memory bitmap instead. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v xor_mode}xor_mode(int on);\par }
{\li400 This is a shortcut for toggling xor drawing mode on and off. Calling 
xor_mode(TRUE) is equivalent to drawing_mode(DRAW_MODE_XOR, NULL, 0, 0). 
Calling xor_mode(FALSE) is equivalent to 
drawing_mode(DRAW_MODE_SOLID, NULL, 0, 0). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v solid_mode}solid_mode();\par }
{\li400 This is a shortcut for selecting solid drawing mode. It is equivalent to 
calling drawing_mode(DRAW_MODE_SOLID, NULL, 0, 0). 
\par}\par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v 256-color transparency}
In paletted video modes, translucency and lighting are implemented with a 
64k lookup table, which contains the result of combining any two colors c1 
and c2. You must set up this table before you use any of the translucency 
or lighting routines. Depending on how you construct the table, a range of 
different effects are possible. For example, translucency can be implemented 
by using a color halfway between c1 and c2 as the result of the combination. 
Lighting is achieved by treating one of the colors as a light level (0-255) 
rather than a color, and setting up the table appropriately. A range of 
specialised effects are possible, for instance replacing any color with any 
other color and making individual source or destination colors completely 
solid or invisible. Color mapping tables can be precalculated with the 
colormap utility, or generated at runtime. Read chapter "Structures and types 
defined by Allegro" for an internal description of the COLOR_MAP structure. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b extern COLOR_MAP *{\xe\v color_map}color_map;\par }
{\li400 Global pointer to the color mapping table. You must allocate your own 
COLOR_MAP either statically or dynamically and set color_map to it 
before using any translucent or lit drawing functions in a 256-color 
video mode! Example: 
\par {\s1 \f1\fs18 
\par       color_map = malloc(sizeof(COLOR_MAP));
\par       if (!color_map)
\par          abort_on_error("Not enough memory for color map!");\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v create_trans_table}create_trans_table(COLOR_MAP *table, const PALETTE pal, int r, g, b, void (*callback)(int pos));\par }
{\li400 Fills the specified color mapping table with lookup data for doing 
translucency effects with the specified palette. When combining the 
colors c1 and c2 with this table, the result will be a color somewhere 
between the two. The r, g, and b parameters specify the solidity of each 
color component, ranging from 0 (totally transparent) to 255 (totally 
solid). For 50% solidity, pass 128. 
\par \par This function treats source color #0 as a special case, leaving the 
destination unchanged whenever a zero source pixel is encountered, so that 
masked sprites will draw correctly. This function will take advantage of 
the global rgb_map variable to speed up color conversions. If the callback 
function is not NULL, it will be called 256 times during the calculation, 
allowing you to display a progress indicator. Example: 
\par {\s1 \f1\fs18 
\par       COLOR_MAP trans_table;
\par       ...
\par       /* Build a color lookup table for translucent drawing. */
\par       create_trans_table(&trans_table, pal, 128, 128, 128, NULL);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v create_light_table}create_light_table(COLOR_MAP *table, const PALETTE pal, int r, g, b, void (*callback)(int pos));\par }
{\li400 Fills the specified color mapping table with lookup data for doing 
lighting effects with the specified palette. When combining the colors c1 
and c2 with this table, c1 is treated as a light level from 0-255. At 
light level 255 the table will output color c2 unchanged, at light level 
0 it will output the r, g, b value you specify to this function, and at 
intermediate light levels it will output a color somewhere between the 
two extremes. The r, g, and b values are in the range 0-63. 
\par \par This function will take advantage of the global rgb_ap variable to speed 
up color conversions. If the callback function is not NULL, it will be 
called 256 times during the calculation, allowing you to display a 
progress indicator. Example: 
\par {\s1 \f1\fs18 
\par       COLOR_MAP light_table;
\par       ...
\par       /* Build a color lookup table for lighting effects. */
\par       create_light_table(&light_table, pal, 0, 0, 0, NULL);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v create_color_table}create_color_table(COLOR_MAP *table, const PALETTE pal, void (*blend)(PALETTE pal, int x, int y, RGB *rgb), void (*callback)(int pos));\par }
{\li400 Fills the specified color mapping table with lookup data for doing 
customised effects with the specified palette, calling the blend function 
to determine the results of each color combination. 
\par \par Your blend routine will be passed a pointer to the palette and the two 
indices of the colors which are to be combined, and should fill in the RGB 
structure with the desired result in 0-63 format. Allegro will then search 
the palette for the closest match to the RGB color that you requested, so 
it doesn't matter if the palette has no exact match for this color. 
\par \par If the callback function is not NULL, it will be called 256 times during 
the calculation, allowing you to display a progress indicator. Example: 
\par {\s1 \f1\fs18 
\par       COLOR_MAP greyscale_table;
\par       ...
\par       void return_grey_color(const PALETTE pal,
\par                              int x, int y, RGB *rgb)
\par       \{
\par          ...
\par       \}
\par       ...
\par          /* Build a color lookup table for greyscale effect. */
\par          create_color_table(&greyscale_table, pal,
\par                             return_grey_color, NULL);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v create_blender_table}create_blender_table(COLOR_MAP *table, const PALETTE pal, void (*callback)(int pos));\par }
{\li400 Fills the specified color mapping table with lookup data for doing a 
paletted equivalent of whatever truecolor blender mode is currently 
selected. After calling set_trans_blender(), set_blender_mode(), or any 
of the other truecolor blender mode routines, you can use this function 
to create an 8-bit mapping table that will have the same results as 
whatever 24-bit blending mode you have enabled. 
\par}\par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v Truecolor transparency}
In truecolor video modes, translucency and lighting are implemented by a 
blender function of the form: 
\par {\s1 \f1\fs18 
\par    unsigned long (*BLENDER_FUNC)(unsigned long x, y, n);\par}
\par For each pixel to be drawn, this routine is passed two color parameters x 
and y, decomposes them into their red, green and blue components, combines 
them according to some mathematical transformation involving the 
interpolation factor n, and then merges the result back into a single 
return color value, which will be used to draw the pixel onto 
the destination bitmap. 
\par \par The parameter x represents the blending modifier color and the parameter y 
represents the base color to be modified. The interpolation factor n is in 
the range [0-255] and controls the solidity of the blending. 
\par \par When a translucent drawing function is used, x is the color of the source, 
y is the color of the bitmap being drawn onto and n is the alpha level   
that was passed to the function that sets the blending mode (the RGB triplet 
that was passed to this function is not taken into account). 
\par \par When a lit sprite drawing function is used, x is the color represented by 
the RGB triplet that was passed to the function that sets the blending mode 
(the alpha level that was passed to this function is not taken into 
account), y is the color of the sprite and n is the alpha level that was 
passed to the drawing function itself. 
\par \par Since these routines may be used from various different color depths, there 
are three such callbacks, one for use with 15-bit 5.5.5 pixels, one for 16 
bit 5.6.5 pixels, and one for 24-bit 8.8.8 pixels (this can be shared 
between the 24 and 32-bit code since the bit packing is the same). 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_trans_blender}set_trans_blender(int r, int g, int b, int a);\par }
{\li400 Enables a linear interpolator blender mode for combining translucent 
or lit truecolor pixels. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_alpha_blender}set_alpha_blender();\par }
{\li400 Enables the special alpha-channel blending mode, which is used for 
drawing 32-bit RGBA sprites. After calling this function, you can use 
draw_trans_sprite() or draw_trans_rle_sprite() to draw a 32-bit source 
image onto any hicolor or truecolor destination. The alpha values will be 
taken directly from the source graphic, so you can vary the solidity of 
each part of the image. You can't use any of the normal translucency 
functions while this mode is active, though, so you should reset to one 
of the normal blender modes (eg. set_trans_blender()) before drawing 
anything other than 32-bit RGBA sprites. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_write_alpha_blender}set_write_alpha_blender();\par }
{\li400 Enables the special alpha-channel editing mode, which is used for drawing 
alpha channels over the top of an existing 32-bit RGB sprite, to turn it 
into an RGBA format image. After calling this function, you can set the 
drawing mode to DRAW_MODE_TRANS and then write draw color values (0-255) 
onto a 32-bit image. This will leave the color values unchanged, but 
alter the alpha to whatever values you are writing. After enabling this 
mode you can also use draw_trans_sprite() to superimpose an 8-bit alpha 
mask over the top of an existing 32-bit sprite. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_add_blender}set_add_blender(int r, int g, int b, int a);\par }
{\li400 Enables an additive blender mode for combining translucent or lit 
truecolor pixels. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_burn_blender}set_burn_blender(int r, int g, int b, int a);\par }
{\li400 Enables a burn blender mode for combining translucent or lit truecolor 
pixels. Here the lightness values of the colours of the source image 
reduce the lightness of the destination image, darkening the image. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_color_blender}set_color_blender(int r, int g, int b, int a);\par }
{\li400 Enables a color blender mode for combining translucent or lit truecolor 
pixels. Applies only the hue and saturation of the source image to the 
destination image. The luminance of the destination image is not affected. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_difference_blender}set_difference_blender(int r, int g, int b, int a);\par }
{\li400 Enables a difference blender mode for combining translucent or lit 
truecolor pixels. This makes an image which has colours calculated by the 
difference between the source and destination colours. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_dissolve_blender}set_dissolve_blender(int r, int g, int b, int a);\par }
{\li400 Enables a dissolve blender mode for combining translucent or lit 
truecolor pixels. Randomly replaces the colours of some pixels in the 
destination image with those of the source image. The number of pixels 
replaced depends on the alpha value (higher value, more pixels replaced; 
you get the idea :). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_dodge_blender}set_dodge_blender(int r, int g, int b, int a);\par }
{\li400 Enables a dodge blender mode for combining translucent or lit truecolor 
pixels. The lightness of colours in the source lighten the colours of the 
destination. White has the most effect; black has none. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_hue_blender}set_hue_blender(int r, int g, int b, int a);\par }
{\li400 Enables a hue blender mode for combining translucent or lit truecolor 
pixels. This applies the hue of the source to the destination. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_invert_blender}set_invert_blender(int r, int g, int b, int a);\par }
{\li400 Enables an invert blender mode for combining translucent or lit truecolor 
pixels. Blends the inverse (or negative) colour of the source with the 
destination. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_luminance_blender}set_luminance_blender(int r, int g, int b, int a);\par }
{\li400 Enables a luminance blender mode for combining translucent or lit 
truecolor pixels. Applies the luminance of the source to the destination. 
The colour of the destination is not affected. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_multiply_blender}set_multiply_blender(int r, int g, int b, int a);\par }
{\li400 Enables a multiply blender mode for combining translucent or lit 
truecolor pixels. Combines the source and destination images, multiplying 
the colours to produce a darker colour. If a colour is multiplied by 
white it remains unchanged; when multiplied by black it also becomes 
black. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_saturation_blender}set_saturation_blender(int r, int g, int b, int a);\par }
{\li400 Enables a saturation blender mode for combining translucent or lit 
truecolor pixels. Applies the saturation of the source to the destination 
image. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_screen_blender}set_screen_blender(int r, int g, int b, int a);\par }
{\li400 Enables a screen blender mode for combining translucent or lit truecolor 
pixels. This blender mode lightens the colour of the destination image by 
multiplying the inverse of the source and destination colours. Sort of 
like the opposite of the multiply blender mode. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_blender_mode}set_blender_mode(BLENDER_FUNC b15, b16, b24, int r, g, b, a);\par }
{\li400 Specifies a custom set of truecolor blender routines, which can be used 
to implement whatever special interpolation modes you need. This function 
shares a single blender between the 24 and 32-bit modes. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_blender_mode_ex}set_blender_mode_ex(BLENDER_FUNC b15, b16, b24, b32, b15x, b16x, b24x, int r, g, b, a);\par }
{\li400 Like set_blender_mode(), but allows you to specify a more complete set of 
blender routines. The b15, b16, b24, and b32 routines are used when 
drawing pixels onto destinations of the same format, while b15x, b16x, 
and b24x are used by draw_trans_sprite() and draw_trans_rle_sprite() when 
drawing RGBA images onto destination bitmaps of another format. These 
blenders will be passed a 32-bit x parameter, along with a y value of a 
different color depth, and must try to do something sensible in response. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Converting between color formats}Converting between color formats\par }
In general, Allegro is designed to be used in only one color depth at a 
time, so you will call set_color_depth() once and then store all your 
bitmaps in the same format. If you want to mix several different pixel 
formats, you can use create_bitmap_ex() in place of create_bitmap(), and 
call bitmap_color_depth() to query the format of a specific image. Most of 
the graphics routines require all their input parameters to be in the same 
format (eg. you cannot stretch a 15-bit source bitmap onto a 24-bit 
destination), but there are some exceptions: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 blit() and the rotation routines can copy between bitmaps of any format, 
converting the data as required. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 draw_sprite() can draw 256-color source images onto destinations of any 
format. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 draw_character_ex() _always_ uses a 256-color source bitmap, whatever the 
format of the destination. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 The draw_trans_sprite() and draw_trans_rle_sprite() functions are able to 
draw 32-bit RGBA images onto any hicolor or truecolor destination, as long 
as you call set_alpha_blender() first. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 The draw_trans_sprite() function is able to draw an 8-bit alpha channel 
image over the top of an existing 32-bit image, as long as you call 
set_write_alpha_blender() first. 
\par}\pard \li0 \par Expanding a 256-color source onto a truecolor destination is fairly fast 
(obviously you must set the correct palette before doing this conversion!). 
Converting between different truecolor formats is slightly slower, and 
reducing truecolor images to a 256-color destination is very slow (it can be 
sped up significantly if you set up the global rgb_map table before doing 
the conversion). 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v bestfit_color}bestfit_color(const PALETTE pal, int r, int g, int b);\par }
{\li400 Searches the specified palette for the closest match to the requested 
color, which are specified in the VGA hardware 0-63 format. Normally you 
should call makecol8() instead, but this lower level function may be 
useful if you need to use a palette other than the currently selected 
one, or specifically don't want to use the rgb_map lookup table. 
\par \par Returns the index of the palette for the closest match to the requested 
color. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern RGB_MAP *{\xe\v rgb_map}rgb_map;\par }
{\li400 To speed up reducing RGB values to 8-bit paletted colors, Allegro uses a 
32k lookup table (5 bits for each color component). You must set up this 
table before using the gouraud shading routines, and if present the table 
will also vastly accelerate the makecol8() and some create_*_table() 
functions. RGB tables can be precalculated with the rgbmap utility, or 
generated at runtime with create_rgb_table(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v create_rgb_table}create_rgb_table(RGB_MAP *table, const PALETTE pal, void (*callback)(int pos));\par }
{\li400 Fills the specified RGB mapping table with lookup data for the specified 
palette. If the callback function is not NULL, it will be called 256 
times during the calculation, allowing you to display a progress 
indicator. Example: 
\par {\s1 \f1\fs18 
\par       RGB_MAP rgb_table;
\par       
\par       create_rgb_table(&rgb_table, palette, NULL);
\par       rgb_map = &rgb_table;\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v hsv_to_rgb}hsv_to_rgb(float h, float s, float v, int *r, int *g, int *b);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v rgb_to_hsv}rgb_to_hsv(int r, int g, int b, float *h, float *s, float *v);\par }
{\li400 Convert color values between the HSV and RGB color spaces. The RGB values 
range from 0 to 255, hue is from 0 to 360, and saturation and value are 
from 0 to 1. Example: 
\par {\s1 \f1\fs18 
\par       int r, g, b;
\par       float hue, saturation, value;
\par       ...
\par       /* Convert a reddish color to HSV format. */
\par       rgb_to_hsv(255, 0, 128, &hue, &saturation, &value);
\par       
\par       /* Now put our tin foil hat, and verify that. */
\par       hsv_to_rgb(hue, saturation, value, &r, &g, &b);
\par       ASSERT(r == 255);
\par       ASSERT(g == 0);
\par       ASSERT(b == 128);\par}
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Direct access to video memory}Direct access to video memory\par }
Read chapter "Structures and types defined by Allegro" for an internal 
description of the BITMAP structure. There are several ways to get direct 
access to the image memory of a bitmap, varying in complexity depending on 
what sort of bitmap you are using. 
\par \par The simplest approach will only work with memory bitmaps (obtained from 
create_bitmap(), grabber datafiles, and image files) and sub-bitmaps of 
memory bitmaps. This uses a table of char pointers, called `line', which is 
a part of the bitmap structure and contains pointers to the start of each 
line of the image. For example, a simple memory bitmap putpixel function is: 
\par {\s1 \f1\fs18 
\par    void memory_putpixel(BITMAP *bmp, int x, int y, int color)
\par    \{
\par       bmp->line[y][x] = color;
\par    \}
\par }\par For truecolor modes you need to cast the line pointer to the appropriate 
type, for example: 
\par {\s1 \f1\fs18 
\par    void memory_putpixel_15_or_16_bpp(BITMAP *bmp, int x, int y, int color)
\par    \{
\par       ((short *)bmp->line[y])[x] = color;
\par    \}
\par 
\par    void memory_putpixel_32(BITMAP *bmp, int x, int y, int color)
\par    \{
\par       ((long *)bmp->line[y])[x] = color;
\par    \}
\par }\par If you want to write to the screen as well as to memory bitmaps, you need to 
use some helper macros, because the video memory may not be part of your 
normal address space. This simple routine will work for any linear screen, 
eg. a VESA linear framebuffers: 
\par {\s1 \f1\fs18 
\par    void linear_screen_putpixel(BITMAP *bmp, int x, int y, int color)
\par    \{
\par       bmp_select(bmp);
\par       bmp_write8((unsigned long)bmp->line[y]+x, color);
\par    \}
\par }\par For truecolor modes you should replace the bmp_write8() with bmp_write16(), 
bmp_write24(), or bmp_write32(), and multiply the x offset by the number of 
bytes per pixel. There are of course similar functions to read a pixel value 
from a bitmap, namely bmp_read8(), bmp_read16(), bmp_read24() and 
bmp_read32(). 
\par \par This still won't work in banked SVGA modes, however, or on platforms like 
Windows that do special processing inside the bank switching functions. For 
more flexible access to bitmap memory, you need to call the following 
routines. They are implemented as inline assembler routines, so they are not 
as inefficient as they might seem. If the bitmap doesn't require bank 
switching (ie. it is a memory bitmap, mode 13h screen, etc), these functions 
just return bmp->line[line]. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b unsigned long {\xe\v bmp_write_line}bmp_write_line(BITMAP *bmp, int line);\par }
{\li400 Selects the line of a bitmap that you are going to draw onto. 
\par \par Returns the address of the selected line for writing. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b unsigned long {\xe\v bmp_read_line}bmp_read_line(BITMAP *bmp, int line);\par }
{\li400 Selects the line of a bitmap that you are going to read from. 
\par \par Returns the address of the selected line for reading. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v bmp_unwrite_line}bmp_unwrite_line(BITMAP *bmp);\par }
{\li400 Releases the bitmap memory after you are finished with it. You only need 
to call this once at the end of a drawing operation, even if you have 
called bmp_write_line() or bmp_read_line() several times before it. 
\par}\par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v More on banked direct memory access}
\par \par Although SVGA bitmaps are banked, Allegro provides linear access to the 
memory within each scanline, so you only need to pass a y coordinate to 
these functions. Various x positions can be obtained by simply adding the x 
coordinate to the returned address. The return value is an unsigned long 
rather than a char pointer because the bitmap memory may not be in your data 
segment, and you need to access it with far pointers. For example, a 
putpixel using the bank switching functions is: 
\par {\s1 \f1\fs18 
\par    void banked_putpixel(BITMAP *bmp, int x, int y, int color)
\par    \{
\par       unsigned long address = bmp_write_line(bmp, y);
\par       bmp_select(bmp);
\par       bmp_write8(address+x, color);
\par       bmp_unwrite_line(bmp);
\par    \}
\par }\par You will notice that Allegro provides separate functions for setting the 
read and write banks. It is important that you distinguish between these, 
because on some graphics cards the banks can be set individually, and on 
others the video memory is read and written at different addresses. Life is 
never quite as simple as we might wish it to be, though (this is true even 
when we _aren't_ talking about graphics coding :-) and so of course some 
cards only provide a single bank. On these the read and write bank functions 
will behave identically, so you shouldn't assume that you can read from one 
part of video memory and write to another at the same time. You can call 
bmp_read_line(), and read whatever you like from that line, and then call 
bmp_write_line() with the same or a different line number, and write 
whatever you like to this second line, but you mustn't call bmp_read_line() 
and bmp_write_line() together and expect to be able to read one line and 
write the other simultaneously. It would be nice if this was possible, but 
if you do it, your code won't work on single banked SVGA cards. 
\par \par And then there's mode-X. If you've never done any mode-X graphics coding, 
you probably won't understand this, but for those of you who want to know 
how Allegro sets up the mode-X screen bitmaps, here goes... 
\par \par The line pointers are still present, and they contain planar addresses, ie. 
the actual location at which you access the first pixel in the line. These 
addresses are guaranteed to be quad aligned, so you can just set the write 
plane, divide your x coordinate by four, and add it to the line pointer. For 
example, a mode-X putpixel is: 
\par {\s1 \f1\fs18 
\par    void modex_putpixel(BITMAP *b, int x, int y, int color)
\par    \{
\par       outportw(0x3C4, (0x100<<(x&3))|2);
\par       bmp_select(bmp);
\par       bmp_write8((unsigned long)bmp->line[y]+(x>>2), color);
\par    \}\par}
\par Oh yeah: the DJGPP nearptr hack. Personally I don't like this very much 
because it disables memory protection and isn't portable to other platforms, 
but a lot of people swear by it because it can give you direct access to the 
screen memory via a normal C pointer. Warning: this method will only work 
with the DJGPP library, when using VGA 13h or a linear framebuffer modes! 
\par \par In your setup code: 
\par {\s1 \f1\fs18 
\par    #include <sys/nearptr.h>
\par 
\par    unsigned char *screenmemory;
\par    unsigned long screen_base_addr;
\par 
\par    __djgpp_nearptr_enable();
\par 
\par    __dpmi_get_segment_base_address(screen->seg, &screen_base_addr);
\par 
\par    screenmemory = (unsigned char *)(screen_base_addr + 
\par                                     screen->line[0] -
\par                                     __djgpp_base_address);
\par }\par Then: 
\par {\s1 \f1\fs18 
\par    void nearptr_putpixel(int x, int y, int color)
\par    \{
\par       screenmemory[x + y*VIRTUAL_W] = color;
\par    \}
\par }\par {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v FLIC routines}FLIC routines\par }
There are two high level functions for playing FLI/FLC animations: 
play_fli(), which reads the data directly from disk, and play_memory_fli(), 
which uses data that has already been loaded into RAM. Apart from the 
different sources of the data, these two functions behave identically. They 
draw the animation onto the specified bitmap, which should normally be the 
screen. Frames will be aligned with the top left corner of the bitmap: if 
you want to position them somewhere else you will need to create a 
sub-bitmap for the FLI player to draw onto. 
\par \par If the callback function is not NULL it will be called once for each frame, 
allowing you to perform background tasks of your own. This callback should 
normally return zero: if it returns non-zero the player will terminate (this 
is the only way to stop an animation that is playing in looped mode). 
\par \par The FLI player returns FLI_OK if it reached the end of the file, FLI_ERROR 
if something went wrong, and the value returned by the callback function if 
that was what stopped it. If you need to distinguish between different return 
values, your callback should return positive integers, since FLI_OK is zero 
and FLI_ERROR is negative. 
\par \par Note that the FLI player will only work when the timer module is installed, 
and that it will alter the palette according to whatever palette data is 
present in the animation file. 
\par \par Occasionally you may need more detailed control over how an FLI is played, 
for example if you want to superimpose a text scroller on top of the 
animation, or to play it back at a different speed. You could do both of 
these with the lower level functions described below. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v play_fli}play_fli(const char *filename, BITMAP *bmp, int loop, int (*callback)());\par }
{\li400 Plays an Autodesk Animator FLI or FLC animation file on the specified 
BITMAP, reading the data from disk as it is required. If `loop' is not 
zero, the player will cycle when it reaches the end of the file, otherwise 
it will play through the animation once and then return. Read the beginning 
of chapter "FLIC routines" for a description of the callback parameter. 
Example: 
\par {\s1 \f1\fs18 
\par       /* Let users skip looped animations. */
\par       int check_escape_key(void)
\par       \{
\par          if (key[KEY_ESC])
\par             return 1;
\par          else
\par             return 0;
\par       \}
\par       ...
\par          int ret = play_fli("animlogo.fli", screen, 1,
\par                              check_escape_key);
\par          if (ret == FLI_ERROR)
\par             abort_on_error("Error playing intro!");\par}
\par The FLI player returns FLI_OK if it reached the end of the file, FLI_ERROR 
if something went wrong, and the value returned by the callback function if 
that was what stopped it. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v play_memory_fli}play_memory_fli(const void *fli_data, BITMAP *bmp, int loop, int (*callback)());\par }
{\li400 Plays an Autodesk Animator FLI or FLC animation on the specified BITMAP, 
reading the data from a copy of the file which is held in memory. You can 
obtain the `fli_data' pointer by allocating a block of memory and reading 
an FLI file into it, or by importing an FLI into a grabber datafile. If 
`loop' is not zero, the player will cycle when it reaches the end of the 
file, otherwise it will play through the animation once and then return. 
Read the beginning of chapter "FLIC routines" for a description of the 
callback parameter. 
\par \par Playing animations from memory is obviously faster than cuing them 
directly from disk, and is particularly useful with short, looped FLI's. 
Animations can easily get very large, though, so in most cases you will 
probably be better just using play_fli(). You can think of this function 
as a wrapper on top of open_memory_fli(), next_fli_frame() and close_fli(). 
Example: 
\par {\s1 \f1\fs18 
\par       int ret = play_memory_fli(anim_data, screen, 0, NULL);
\par       if (ret == FLI_ERROR)
\par          abort_on_error("Corrupted animation data?");\par}
\par The FLI player returns FLI_OK if it reached the end of the file, FLI_ERROR 
if something went wrong, and the value returned by the callback function if 
that was what stopped it. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 int {\xe\v open_fli}open_fli(const char *filename);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 int {\xe\v open_memory_fli}open_memory_fli(const void *fli_data);\par }
{\li400 Open FLI files ready for playing, reading the data from disk or memory 
respectively. Information about the current FLI is held in the global 
variables fli_bitmap and fli_palette, which you can use if this function 
succeeds. However, you can only have one animation open at a time. 
Example: 
\par {\s1 \f1\fs18 
\par       if (open_fli("intro.fli") == FLI_ERROR)
\par          abort_on_error("Error playing intro");\par}
\par Returns FLI_OK on success, FLI_ERROR if something went wrong, like trying 
to open another FLI file without closing the previous one. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v close_fli}close_fli();\par }
{\li400 Closes an FLI file when you have finished reading from it. Remember to do 
this to avoid having memory leaks in your program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v next_fli_frame}next_fli_frame(int loop);\par }
{\li400 Reads the next frame of the current animation file. If `loop' is not zero, 
the player will cycle when it reaches the end of the file, otherwise it 
will return FLI_EOF. The frame is read into the global variables 
fli_bitmap and fli_palette. Example: 
\par {\s1 \f1\fs18 
\par       while (next_fli_frame(0) == FLI_OK) \{
\par          /* Do stuff, like play audio stream
\par             or check keys to skip animation. */
\par          /* Rest some time until next frame... */
\par       \}\par}
\par Returns FLI_OK on success, FLI_ERROR or FLI_NOT_OPEN on error, and FLI_EOF 
on reaching the end of the file. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern BITMAP *{\xe\v fli_bitmap}fli_bitmap;\par }
{\li400 Contains the current frame of the FLI/FLC animation. If there is no open 
animation, its value will be NULL. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern PALETTE {\xe\v fli_palette}fli_palette;\par }
{\li400 Contains the current FLI palette. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 extern int {\xe\v fli_bmp_dirty_from}fli_bmp_dirty_from;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 extern int {\xe\v fli_bmp_dirty_to}fli_bmp_dirty_to;\par }
{\li400 These variables are set by next_fli_frame() to indicate which part of the 
fli_bitmap has changed since the last call to reset_fli_variables(). If 
fli_bmp_dirty_from is greater than fli_bmp_dirty_to, the bitmap has not 
changed, otherwise lines fli_bmp_dirty_from to fli_bmp_dirty_to 
(inclusive) have altered. You can use these when copying the fli_bitmap 
onto the screen, to avoid moving data unnecessarily. Example: 
\par {\s1 \f1\fs18 
\par       if (fli_bmp_dirty_from <= fli_bmp_dirty_to)
\par          blit(fli_bitmap, screen, 0, fli_bmp_dirty_from,
\par               0, fli_bmp_dirty_from, fli_bitmap->w,
\par               fli_bmp_dirty_to - fli_bmp_dirty_from + 1);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 extern int {\xe\v fli_pal_dirty_from}fli_pal_dirty_from;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 extern int {\xe\v fli_pal_dirty_to}fli_pal_dirty_to;\par }
{\li400 These variables are set by next_fli_frame() to indicate which part of the 
fli_palette has changed since the last call to reset_fli_variables(). If 
fli_pal_dirty_from is greater than fli_pal_dirty_to, the palette has not 
changed, otherwise colors fli_pal_dirty_from to fli_pal_dirty_to 
(inclusive) have altered. You can use these when updating the hardware 
palette, to avoid unnecessary calls to set_palette(). Example: 
\par {\s1 \f1\fs18 
\par       if (fli_pal_dirty_from <= fli_pal_dirty_to)
\par          set_palette_range(fli_palette, fli_pal_dirty_from,
\par                            fli_pal_dirty_to, 1);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v reset_fli_variables}reset_fli_variables();\par }
{\li400 Once you have done whatever you are going to do with the fli_bitmap and 
fli_palette, call this function to reset the fli_bmp_dirty_* and 
fli_pal_dirty_* variables. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v fli_frame}fli_frame;\par }
{\li400 Global variable containing the current frame number in the FLI file. This 
is useful for synchronising other events with the animation, for instance 
you could check it in a play_fli() callback function and use it to 
trigger a sample at a particular point. Example: 
\par {\s1 \f1\fs18 
\par       while (next_fli_frame(0) == FLI_OK) \{
\par          if (fli_frame == 345)
\par             play_sample(trumpet_sound, 255, 128, 1000, 0);
\par          /* Rest some time until next frame... */
\par       \}\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b extern volatile int {\xe\v fli_timer}fli_timer;\par }
{\li400 Global variable for timing FLI playback. When you open an FLI file, a 
timer interrupt is installed which increments this variable every time a 
new frame should be displayed. Calling next_fli_frame() decrements it, so 
you can test it and know that it is time to display a new frame if it is 
greater than zero. Example: 
\par {\s1 \f1\fs18 
\par       while (next_fli_frame(0) == FLI_OK) \{
\par          /* Do stuff, like play audio stream
\par             or check keys to skip animation. */
\par          /* Rest some time until next frame... */
\par          while (fli_timer <= 0)
\par             rest(0);
\par       \}\par}
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Sound init routines}Sound init routines\par }
Allegro allows you to use the sound hardware in two ways: automatic, or 
manual. Usually you should try the automatic version first. This means 
calling install_sound() with the autodetection parameters and using the rest 
of the sound functions to play samples or music. In this situation, Allegro 
will handle the sound devices and mix the samples and/or music the best way 
it can. 
\par \par However, sound hardware has a limitation on the number of samples it may 
play all at the same time (from now on, called hardware voices). When you 
exceed this limit, Allegro will cut off one of the samples being played and 
reproduce the new one. Depending on the type of sounds you are playing, how 
many of them you need at the same time and their nature (e.g: vital audio 
feedback to the user or useless "ping" when some shrapnel hits a rock in the 
scenery) you will want to specify more carefully how hardware voices are 
reserved and which samples have priority over others. 
\par \par The hardware voice reservation phase has to be done before the call to 
install_sound(), since it directly affects how Allegro talks to the sound 
drivers. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v detect_digi_driver}detect_digi_driver(int driver_id);\par }
{\li400 Detects whether the specified digital sound device is available. This 
function must be called _before_ install_sound(). 
\par \par Returns the maximum number of voices that the driver can provide, or zero 
if the hardware is not present. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v detect_midi_driver}detect_midi_driver(int driver_id);\par }
{\li400 Detects whether the specified MIDI sound device is available. This function 
must be called _before_ install_sound(). 
\par \par Returns the maximum number of voices that the driver can provide, or zero 
if the hardware is not present. 
\par \par There are two special-case return values that you should watch out for: 
if this function returns -1 it is a note-stealing driver (eg. DIGMID) that 
shares voices with the current digital sound driver, and if it returns 
0xFFFF it is an external device like an MPU-401 where there is no way to 
determine how many voices are available. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v reserve_voices}reserve_voices(int digi_voices, int midi_voices);\par }
{\li400 Call this function to specify the number of voices that are to be used by 
the digital and MIDI sound drivers respectively. This must be done 
_before_ calling install_sound(). If you reserve too many voices, 
subsequent calls to install_sound() will fail. How many voices are 
available depends on the driver, and in some cases you will actually get 
more than you reserve (eg. the FM synth drivers will always provide 9 
voices on an OPL2 and 18 on an OPL3, and the SB digital driver will round 
the number of voices up to the nearest power of two). Pass negative 
values to restore the default settings. You should be aware that the 
sound quality is usually inversely related to how many voices you use, so 
don't reserve any more than you really need. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_volume_per_voice}set_volume_per_voice(int scale);\par }
{\li400 By default, Allegro will play a centered sample at half volume on both 
the left and right channel. A sample panned to the far right or left 
will be played at maximum volume on that channel only. This is done so 
you can play a single panned sample without distortion. If you play 
multiple samples at full volume, the mixing process can result in 
clipping, a noticeable form of distortion. The more samples, the more 
likely clipping is to occur, and the more clipping, the worse the output 
will sound. 
\par \par If clipping is a problem - or if the output is too quiet - this function 
can be used to adjust the volume of each voice. You should first check 
that your speakers are at a reasonable volume, Allegro's global volume 
is at maximum (see set_volume() below), and any other mixers such as the 
Windows Volume Control are set reasonably. Once you are sure that 
Allegro's output level is unsuitable for your application, use this 
function to adjust it. 
\par \par Each time you increase the parameter by one, the volume of each voice 
will halve. For example, if you pass 4, you can play up to 16 centred 
samples at maximum volume without distortion. 
\par \par If you pass 0 to this function, each centred sample will play at the 
maximum volume possible without distortion, as will all samples played 
through a mono driver. Samples at the extreme left and right will distort 
if played at full volume. If you wish to play panned samples at full 
volume without distortion, you should pass 1 to this function. 
Note: this is different from the function's behaviour in WIPs 3.9.34, 
3.9.35 and 3.9.36. If you used this function under one of these WIPs, 
you will have to increase your parameter by one to get the same volume. 
\par \par Note: The default behaviour has changed as of Allegro 4.1.15. If you 
would like the behaviour of earlier versions of Allegro, pass -1 to this 
function. Allegro will choose a value dependent on the number of voices, 
so that if you reserve n voices, you can play up to n/2 normalised 
samples with centre panning without risking distortion. The exception is 
when you have fewer than 8 voices, where the volume remains the same as 
for 8 voices. Here are the values, dependent on the number of voices: 
\par {\s1 \f1\fs18 
\par      1-8 voices - set_volume_per_voice(2)
\par       16 voices - set_volume_per_voice(3)
\par       32 voices - set_volume_per_voice(4)
\par       64 voices - set_volume_per_voice(5)
\par }\par Of course this function does not override the volume you specify with 
play_sample() or voice_set_volume(). It simply alters the overall output 
of the program. If you play samples at lower volumes, or if they are not 
normalised, then you can play more of them without distortion. 
\par \par It is recommended that you hard-code the parameter into your program, 
rather than offering it to the user. The user can alter the volume with 
the configuration file instead, or you can provide for this with 
set_volume(). 
\par \par To restore volume per voice to its default behaviour, pass 1. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v install_sound}install_sound(int digi, int midi, const char *cfg_path);\par }
{\li400 Initialises the sound module. You should normally pass DIGI_AUTODETECT 
and MIDI_AUTODETECT as the driver parameters to this function, in which 
case Allegro will read hardware settings from the current configuration 
file. This allows the user to select different values with the setup 
utility: see the config section for details. Alternatively, see the 
platform specific documentation for a list of the available drivers. The 
cfg_path parameter is only present for compatibility with previous 
versions of Allegro, and has no effect on anything. 
\par \par Returns zero if the sound is successfully installed, and -1 on failure. 
If it fails it will store a description of the problem in allegro_error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v remove_sound}remove_sound();\par }
{\li400 Cleans up after you are finished with the sound routines. You don't 
normally need to call this, because allegro_exit() will do it for you. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_volume}set_volume(int digi_volume, int midi_volume);\par }
{\li400 Alters the global sound output volume. Specify volumes for both digital 
samples and MIDI playback, as integers from 0 to 255, or pass a negative 
value to leave one of the settings unchanged. Values bigger than 255 will 
be reduced to 255. This routine will not alter the volume of the hardware 
mixer if it exists (i.e. only your application will be affected). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_hardware_volume}set_hardware_volume(int digi_volume, int midi_volume);\par }
{\li400 Alters the hardware sound output volume. Specify volumes for both digital 
samples and MIDI playback, as integers from 0 to 255, or pass a negative 
value to leave one of the settings unchanged. Values bigger than 255 will 
be reduced to 255. This routine will use the hardware mixer to control the 
volume if it exists (i.e. the volume of all the applications on your 
machine will be affected), otherwise do nothing. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_volume}get_volume(int *digi_volume, int *midi_volume);\par }
{\li400 Retrieves the global sound output volume, both for digital samples and MIDI 
playback, as integers from 0 to 255. Parameters digi_volume and midi_volume 
must be valid pointers to int, or NULL if not interested in specific value. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_hardware_volume}get_hardware_volume(int *digi_volume, int *midi_volume);\par }
{\li400 Retrieves the hardware sound output volume, both for digital samples and MIDI 
playback, as integers from 0 to 255, or -1 if the information is not 
available. Parameters digi_volume and midi_volume must be valid pointers to 
int, or NULL if not interested in specific value. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Mixer routines}Mixer routines\par }
\par \par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_mixer_quality}set_mixer_quality(int quality);\par }
{\li400 Sets the resampling quality of the mixer. Valid values are the same as 
the `quality' config variable. Please read chapter "Standard config 
variables" for details. You can call this function at any point in your 
program, even before allegro_init(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_mixer_quality}get_mixer_quality(void);\par }
{\li400 Returns the current mixing quality, as specified by the `quality' config 
variable, or a previous call to set_mixer_quality(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_mixer_frequency}get_mixer_frequency(void);\par }
{\li400 Returns the mixer frequency, in Hz. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_mixer_bits}get_mixer_bits(void);\par }
{\li400 Returns the mixer bit depth (8 or 16). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_mixer_channels}get_mixer_channels(void);\par }
{\li400 Returns the number of output channels. 2 for stereo, 1 for mono, 0 if 
the mixer isn't active. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_mixer_voices}get_mixer_voices(void);\par }
{\li400 Returns the number of voices allocated to the mixer. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_mixer_buffer_length}get_mixer_buffer_length(void);\par }
{\li400 Returns the number of samples per channel in the mixer buffer. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Digital sample routines}Digital sample routines\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b SAMPLE *{\xe\v load_sample}load_sample(const char *filename);\par }
{\li400 Loads a sample from a file, supporting both mono and stereo WAV and mono 
VOC files, in 8 or 16-bit formats, as well as formats handled by functions 
registered using register_sample_file_type(). Example: 
\par {\s1 \f1\fs18 
\par       SAMPLE *sample = load_sample(user_input);
\par       if (!sample)
\par          abort_on_error("Couldn't load sample!");\par}
\par Returns a pointer to the SAMPLE or NULL on error. Remember to free this 
sample later to avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b SAMPLE *{\xe\v load_wav}load_wav(const char *filename);\par }
{\li400 Loads a sample from a RIFF WAV file. Example: 
\par {\s1 \f1\fs18 
\par       SAMPLE *sample = load_wav("scream.wav");
\par       if (!sample)
\par          abort_on_error("Couldn't scare user!");\par}
\par Returns a pointer to the SAMPLE or NULL on error. Remember to free this 
sample later to avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b SAMPLE *{\xe\v load_wav_pf}load_wav_pf(PACKFILE *f);\par }
{\li400 A version of load_wav() which reads from a packfile. Example: 
\par {\s1 \f1\fs18 
\par       PACKFILE *packfile;
\par       SAMPLE *sample;
\par    
\par       packfile = pack_fopen("sound.wav", F_READ);
\par       if (!packfile)
\par          abort_on_error("Couldn't open sound.wav");
\par    
\par       sample = load_wav_pf(packfile);
\par       if (!sample)
\par          abort_on_error("Error loading sound.wav");\par}
\par Returns a pointer to the SAMPLE or NULL on error. Remember to free this 
sample later to avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b SAMPLE *{\xe\v load_voc}load_voc(const char *filename);\par }
{\li400 Loads a sample from a Creative Labs VOC file. Example: 
\par {\s1 \f1\fs18 
\par       SAMPLE *sample = load_voc("alarm.voc");
\par       if (!sample)
\par          abort_on_error("Couldn't alert user!");\par}
\par Returns a pointer to the SAMPLE or NULL on error. Remember to free this 
sample later to avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b SAMPLE *{\xe\v load_voc_pf}load_voc_pf(PACKFILE *f);\par }
{\li400 A version of load_voc() which reads from a packfile. Example: 
\par {\s1 \f1\fs18 
\par       PACKFILE *packfile;
\par       SAMPLE *sample;
\par    
\par       packfile = pack_fopen("sound.wav", F_READ);
\par       if (!packfile)
\par          abort_on_error("Couldn't open sound.wav");
\par    
\par       sample = load_wav_pf(packfile);
\par       if (!sample)
\par          abort_on_error("Error loading sound.wav");\par}
\par Returns a pointer to the SAMPLE or NULL on error. Remember to free this 
sample later to avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v save_sample}save_sample(const char *filename, SAMPLE *spl);\par }
{\li400 Writes a sample into a file. The output format is determined from the 
filename extension. At present Allegro does not natively support the 
writing of any sample formats, so you must register a custom saver routine 
with register_sample_file_type(). Example: 
\par {\s1 \f1\fs18 
\par       if (save_sample("sound.wav", sample) != 0)
\par          abort_on_error("Couldn't save sample!");\par}
\par Returns zero on success, non-zero otherwise. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b SAMPLE *{\xe\v create_sample}create_sample(int bits, int stereo, int freq, int len);\par }
{\li400 Constructs a new sample structure of the specified type. Read chapter 
"Structures and types defined by Allegro" for an internal description of 
the SAMPLE structure. The `bits' parameter can be 8 or 16, `stereo' can be 
zero for mono samples and non-zero for stereo samples, `freq' is the 
frequency in hertz, and `len' is the number of samples you want to allocate 
for the full sound buffer. 
\par \par Returns a pointer to the created sample, or NULL if the sample could not 
be created. Remember to free this sample later to avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v destroy_sample}destroy_sample(SAMPLE *spl);\par }
{\li400 Destroys a sample structure when you are done with it. It is safe to call 
this even when the sample might be playing, because it checks and will 
kill it off if it is active. Use this to avoid memory leaks in your 
program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v lock_sample}lock_sample(SAMPLE *spl);\par }
{\li400 Under DOS, locks all the memory used by a sample. You don't normally need 
to call this function because load_sample() and create_sample() do it for 
you. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v register_sample_file_type}register_sample_file_type(const char *ext, SAMPLE *(*load)(const char *filename), int (*save)(const char *filename, SAMPLE *spl));\par }
{\li400 Informs the load_sample() function of a new sample file type, 
providing routines to read and write samples in this format (either 
function may be NULL). Example: 
\par {\s1 \f1\fs18 
\par       SAMPLE *load_mp3(const char *filename)
\par       \{
\par          ...
\par       \}
\par       
\par          register_sample_file_type("mp3", load_mp3, NULL);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v play_sample}play_sample(const SAMPLE *spl, int vol, int pan, int freq, int loop);\par }
{\li400 Triggers a sample at the specified volume, pan position, and frequency. 
The parameters `vol' and `pan' range from 0 (min/left) to 255 (max/right). 
Frequency is relative rather than absolute: 1000 represents the frequency 
that the sample was recorded at, 2000 is twice this, etc. If `loop' is not 
zero, the sample will repeat until you call stop_sample(), and can be 
manipulated while it is playing by calling adjust_sample(). Example: 
\par {\s1 \f1\fs18 
\par       /* Scream from the left speaker, twice the freq. */
\par       int sound = play_sample(scream, 255, 0, 2000, 0);\par}
\par Returns the voice number that was allocated for the sample or negative if 
no voices were available. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v adjust_sample}adjust_sample(const SAMPLE *spl, int vol, int pan, int freq, int loop);\par }
{\li400 Alters the parameters of a sample while it is playing (useful for 
manipulating looped sounds). You can alter the volume, pan, and frequency, 
and can also clear the loop flag, which will stop the sample when it next 
reaches the end of its loop. The values of the parameters are just like 
those of play_sample(). If there are several copies of the same sample 
playing, this will adjust the first one it comes across. If the sample is 
not playing it has no effect. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v stop_sample}stop_sample(const SAMPLE *spl);\par }
{\li400 Stop a sample from playing, which is required if you have set a sample 
going in looped mode. If there are several copies of the sample playing, 
it will stop them all. You must still destroy the sample using 
destroy_sample(). 
\par}\par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v Voice control}
If you need more detailed control over how samples are played, you can use 
the lower level voice functions rather than just calling play_sample(). This 
is rather more work, because you have to explicitly allocate and free the 
voices rather than them being automatically released when they finish 
playing, but allows far more precise specification of exactly how you want 
everything to sound. You may also want to modify a couple of fields from the 
SAMPLE structure. Read chapter "Structures and types defined by Allegro" for 
its definition. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v allocate_voice}allocate_voice(const SAMPLE *spl);\par }
{\li400 Allocates a sound card voice and prepares it for playing the specified 
sample, setting up sensible default parameters (maximum volume, centre 
pan, no change of pitch, no looping). When you are finished with the 
voice you must free it by calling deallocate_voice() or release_voice(). 
Allegro can manage up to 256 simultaneous voices, but that limit may be 
lower due to hardware reasons. 
\par \par Returns the voice number, or -1 if no voices are available. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v deallocate_voice}deallocate_voice(int voice);\par }
{\li400 Frees a sound card voice, stopping it from playing and releasing whatever 
resources it is using. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v reallocate_voice}reallocate_voice(int voice, const SAMPLE *spl);\par }
{\li400 Switches an already-allocated voice to use a different sample. Calling 
reallocate_voice(voice, sample) is equivalent to: 
\par {\s1 \f1\fs18 
\par       deallocate_voice(voice);
\par       voice = allocate_voice(sample);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v release_voice}release_voice(int voice);\par }
{\li400 Releases a sound card voice, indicating that you are no longer interested 
in manipulating it. The sound will continue to play, and any resources 
that it is using will automatically be freed when it finishes. This is 
essentially the same as deallocate_voice(), but it waits for the sound to 
stop playing before taking effect. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_start}voice_start(int voice);\par }
{\li400 Activates a voice, using whatever parameters have been set for it. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_stop}voice_stop(int voice);\par }
{\li400 Stops a voice, storing the current position and state so that it may 
later be resumed by calling voice_start(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_set_priority}voice_set_priority(int voice, int priority);\par }
{\li400 Sets the priority of a voice (range 0-255). This is used to decide which 
voices should be chopped off, if you attempt to play more than the 
sound card driver can handle. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b SAMPLE *{\xe\v voice_check}voice_check(int voice);\par }
{\li400 Checks whether a voice is currently allocated. 
\par \par Returns a pointer to the sample that the voice is using, or NULL if the 
voice is inactive (ie. it has been deallocated, or the release_voice() 
function has been called and the sample has then finished playing). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v voice_get_position}voice_get_position(int voice);\par }
{\li400 Returns the current position of a voice, in sample units, or -1 if it has 
finished playing. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_set_position}voice_set_position(int voice, int position);\par }
{\li400 Sets the position of a voice, in sample units. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_set_playmode}voice_set_playmode(int voice, int playmode);\par }
{\li400 Adjusts the loop status of the specified voice. This can be done while 
the voice is playing, so you can start a sample in looped mode (having 
set the loop start and end positions to the appropriate values), and then 
clear the loop flag when you want to end the sound, which will cause it 
to continue past the loop end, play the subsequent part of the sample, 
and finish in the normal way. The mode parameter is a bitfield containing 
the following values: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 PLAYMODE_PLAY\par \pard \li800 
Plays the sample a single time. This is the default if you don't set 
the loop flag. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 PLAYMODE_LOOP\par \pard \li800 
Loops repeatedly through the sample, jumping back to the loop start 
position upon reaching the loop end. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 PLAYMODE_FORWARD\par \pard \li800 
Plays the sample from beginning to end. This is the default if you 
don't set the backward flag. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 PLAYMODE_BACKWARD\par \pard \li800 
Reverses the direction of the sample. If you combine this with the 
loop flag, the sample jumps to the loop end position upon reaching the 
loop start (ie. you do not need to reverse the loop start and end 
values when you play the sample in reverse). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 PLAYMODE_BIDIR\par \pard \li800 
When used in combination with the loop flag, causes the sample to 
change direction each time it reaches one of the loop points, so it 
alternates between playing forwards and in reverse. 
\par}\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v voice_get_volume}voice_get_volume(int voice);\par }
{\li400 Returns the current volume of the voice, range 0-255.  Otherwise it 
returns -1 if that cannot be determined (because it has finished or 
been preempted by a different sound). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_set_volume}voice_set_volume(int voice, int volume);\par }
{\li400 Sets the volume of the voice, range 0-255. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_ramp_volume}voice_ramp_volume(int voice, int time, int endvol);\par }
{\li400 Starts a volume ramp (crescendo or diminuendo) from the current volume to 
the specified ending volume, lasting for time milliseconds. The volume is 
a value in the range 0-255. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_stop_volumeramp}voice_stop_volumeramp(int voice);\par }
{\li400 Interrupts a volume ramp operation. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v voice_get_frequency}voice_get_frequency(int voice);\par }
{\li400 Returns the current pitch of the voice, in Hz. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_set_frequency}voice_set_frequency(int voice, int frequency);\par }
{\li400 Sets the pitch of the voice, in Hz. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_sweep_frequency}voice_sweep_frequency(int voice, int time, int endfreq);\par }
{\li400 Starts a frequency sweep (glissando) from the current pitch to the 
specified ending pitch, lasting for time milliseconds. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_stop_frequency_sweep}voice_stop_frequency_sweep(int voice);\par }
{\li400 Interrupts a frequency sweep operation. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v voice_get_pan}voice_get_pan(int voice);\par }
{\li400 Returns the current pan position, from 0 (left) to 255 (right). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_set_pan}voice_set_pan(int voice, int pan);\par }
{\li400 Sets the pan position, ranging from 0 (left) to 255 (right). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_sweep_pan}voice_sweep_pan(int voice, int time, int endpan);\par }
{\li400 Starts a pan sweep (left <-> right movement) from the current position to 
the specified ending position, lasting for time milliseconds. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_stop_pan_sweep}voice_stop_pan_sweep(int voice);\par }
{\li400 Interrupts a pan sweep operation. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_set_echo}voice_set_echo(int voice, int strength, int delay);\par }
{\li400 Sets the echo parameters for a voice (not currently implemented). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_set_tremolo}voice_set_tremolo(int voice, int rate, int depth);\par }
{\li400 Sets the tremolo parameters for a voice (not currently implemented). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v voice_set_vibrato}voice_set_vibrato(int voice, int rate, int depth);\par }
{\li400 Sets the vibrato parameters for a voice (not currently implemented). 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Music routines (MIDI)}Music routines (MIDI)\par }
Allegro allows you to play MIDI files. MIDI files basically contain notes and 
the type of instrument that is meant to play them, so they are usually very 
small in size. However, it's up to the sound card of the end user to play the 
notes, and sound cards have been historically known to have poor MIDI 
performance (at least those oriented to the consumer market). Few consumer 
cards feature decent MIDI playback. Still, as a game creator you can never be 
sure if the music of your game will be played as you meant it, because it 
totally depends on the hardware of the user. 
\par \par For this reason Allegro also provides a DIGMID driver. This is a software 
implementation of the so called Wavetable synthesis. Sound cards featuring this 
store digital samples of real instruments at different pitches, interpolating 
those that are not recorded, thus achieving a high sound quality. Implementing 
this in software makes you sure that the quality you hear on your computer is 
that which will be heard by end users using the same driver. 
\par \par The disadvantage of the DIGMID driver is that it uses more CPU than simple 
MIDI playback, and it steals some hardware voices from the sound card, which 
might be more critical for the end user experience than the background music. 
At the Allegro homepage (http://alleg.sourceforge.net/) you can find more 
information about DIGMID and where to download digital samples for your MIDI 
files. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b MIDI *{\xe\v load_midi}load_midi(const char *filename);\par }
{\li400 Loads a MIDI file (handles both format 0 and format 1). Example: 
\par {\s1 \f1\fs18 
\par       MIDI *music;
\par       music = load_midi("backmus.mid");
\par       if (!music)
\par          abort_on_error("Couldn't load background music!");\par}
\par Returns a pointer to a MIDI structure, or NULL on error. Remember to free 
this MIDI file later to avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v destroy_midi}destroy_midi(MIDI *midi);\par }
{\li400 Destroys a MIDI structure when you are done with it. It is safe to call 
this even when the MIDI file might be playing, because it checks and will 
kill it off if it is active. Use this to avoid memory leaks in your 
program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v lock_midi}lock_midi(MIDI *midi);\par }
{\li400 Under DOS, locks all the memory used by a MIDI file. You don't normally 
need to call this function because load_midi() does it for you. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v play_midi}play_midi(MIDI *midi, int loop);\par }
{\li400 Starts playing the specified MIDI file, first stopping whatever music was 
previously playing. If the loop flag is set to non-zero, the data will be 
repeated until replaced with something else, otherwise it will stop at the 
end of the file. Passing a NULL pointer will stop whatever music is 
currently playing. 
\par \par Returns non-zero if an error occurs (this may happen if a patch-caching 
wavetable driver is unable to load the required samples, or at least it 
might in the future when somebody writes some patch-caching wavetable 
drivers :-) 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v play_looped_midi}play_looped_midi(MIDI *midi, int loop_start, int loop_end);\par }
{\li400 Starts playing a MIDI file with a user-defined loop position. When the 
player reaches the loop end position or the end of the file (loop_end may 
be -1 to only loop at EOF), it will wind back to the loop start point. 
Both positions are specified in the same beat number format as the 
midi_pos variable. 
\par \par The return value has the same meaning as that of play_midi(): non-zero if 
an error occurs, zero otherwise. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v stop_midi}stop_midi();\par }
{\li400 Stops whatever music is currently playing. This is the same thing as 
calling play_midi(NULL, FALSE). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v midi_pause}midi_pause();\par }
{\li400 Pauses the MIDI player. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v midi_resume}midi_resume();\par }
{\li400 Resumes playback of a paused MIDI file. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v midi_seek}midi_seek(int target);\par }
{\li400 Seeks to the given midi_pos in the current MIDI file. If the target is 
earlier in the file than the current midi_pos it seeks from the 
beginning; otherwise it seeks from the current position. 
\par \par Returns zero if it could successfully seek to the requested position. 
Otherwise, a return value of 1 means it stopped playing, and midi_pos is 
set to the negative length of the MIDI file (so you can use this function 
to determine the length of a MIDI file). A return value of 2 means the 
MIDI file looped back to the start. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_midi_length}get_midi_length(MIDI *midi);\par }
{\li400 This function will simulate playing the given MIDI, from start to end, to 
determine how long it takes to play. After calling this function, midi_pos 
will contain the negative number of beats, and midi_time the length of the 
midi, in seconds. 
\par \par Note that any currently playing midi is stopped when you call this function. 
Usually you would call it before play_midi, to get the length of the midi to 
be played, like in this example: 
\par {\s1 \f1\fs18 
\par       length = get_midi_length(my_midi);
\par       play_midi(my_midi);
\par       do \{
\par          pos = midi_time;
\par          textprintf_ex(screen, font, 0, 0, c, -1, "%d:%02d / %d:%02d\\n",
\par             pos / 60, pos % 60, length / 60, length % 60);
\par          rest(100);
\par       \} while(pos <= length);\par}
\par Returns the value of midi_time, the length of the midi. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v midi_out}midi_out(unsigned char *data, int length);\par }
{\li400 Streams a block of MIDI commands into the player in real-time, allowing 
you to trigger notes, jingles, etc, over the top of whatever MIDI file is 
currently playing. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v load_midi_patches}load_midi_patches();\par }
{\li400 Forces the MIDI driver to load the entire set of patches ready for use. 
You will not normally need to call this, because Allegro automatically 
loads whatever data is required for the current MIDI file, but you must 
call it before sending any program change messages via the midi_out() 
command. 
\par \par Returns non-zero if an error occurred. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern volatile long {\xe\v midi_pos}midi_pos;\par }
{\li400 Stores the current position (beat number) in the MIDI file, or contains 
a negative number if no music is currently playing. Useful for 
synchronising animations with the music, and for checking whether a MIDI 
file has finished playing. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern volatile long {\xe\v midi_time}midi_time;\par }
{\li400 Contains the position in seconds in the currently playing midi. This is 
useful if you want to display the current song position in seconds, not as 
beat number. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 extern long {\xe\v midi_loop_start}midi_loop_start;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 extern long {\xe\v midi_loop_end}midi_loop_end;\par }
{\li400 The loop start and end points, set by the play_looped_midi() function. 
These may safely be altered while the music is playing, but you should be 
sure they are always set to sensible values (start < end). If you are 
changing them both at the same time, make sure to alter them in the right 
order in case a MIDI interrupt happens to occur in between your two 
writes! Setting these values to -1 represents the start and end of the 
file respectively. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 extern void (*{\xe\v midi_msg_callback}midi_msg_callback)(int msg, int byte1, int byte2);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 extern void (*{\xe\v midi_meta_callback}midi_meta_callback)(int type, const unsigned char *data, int length);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 extern void (*{\xe\v midi_sysex_callback}midi_sysex_callback)(const unsigned char *data, int length);\par }
{\li400 Hook functions allowing you to intercept MIDI player events. If set to 
anything other than NULL, these routines will be called for each MIDI 
message, meta-event, and system exclusive data block respectively. They 
will execute in an interrupt handler context, so all the code and data 
they use should be locked, and they must not call any operating system 
functions. In general you just use these routines to set some flags and 
respond to them later in your mainline code. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v load_ibk}load_ibk(char *filename, int drums);\par }
{\li400 Reads in a .IBK patch definition file for use by the Adlib driver. If 
drums is set, it will load it as a percussion patch set, otherwise it 
will use it as a replacement set of General MIDI instruments. You may 
call this before or after initialising the sound code, or can simply set 
the ibk_file and ibk_drum_file variables in the configuration file to 
have the data loaded automatically. Note that this function has no effect 
on any drivers other than the Adlib one! 
\par \par Returns non-zero on error. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Audio stream routines}Audio stream routines\par }
The audio stream functions are for playing digital sounds that are too big 
to fit in a regular SAMPLE structure, either because they are huge files 
that you want to load in pieces as the data is required, or because you are 
doing something clever like generating the waveform on the fly. 
\par \par You can think of an AUDIOSTREAM structure as a wrapper around two audio 
buffers. The first thing you do is fill both buffers with sound data and let 
Allegro play them. Once the first buffer has been played, the second starts, 
and Allegro lets you know you have to fill the other one (i.e. graphics 
double buffering applied to sounds too big to fit into memory). 
\par \par The implementation of the sound buffers uses normal SAMPLE structures, so you 
can use all the voice_*() functions to modify the audio streams. Read chapter 
"Digital sample routines", section "Voice control" for a list of additional 
functions you can use. Read chapter "Structures and types defined by Allegro" 
for the internals of the AUDIOSTREAM structure. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b AUDIOSTREAM *{\xe\v play_audio_stream}play_audio_stream(int len, int bits, int stereo, int freq, int vol, int pan);\par }
{\li400 This function creates a new audio stream and starts playing it. The 
length is the size of each transfer buffer in sample frames (not bytes), 
where a sample frame is a single sample value for mono data or a pair of 
interleaved sample values (left first) for stereo data. The length should 
normally be (but doesn't have to be) a power of 2 somewhere around 1k in 
size. Larger buffers are more efficient and require fewer updates, but 
result in more latency between you providing the data and it actually 
being played. 
\par \par The `bits' parameter must be 8 or 16. `freq' is the sample rate of the 
data in Hertz. The `vol' and `pan' values use the same 0-255 ranges as the 
regular sample playing functions. The `stereo' parameter should be set to 
1 for stereo streams, or 0 otherwise. 
\par \par If you want to adjust the pitch, volume, or panning of a stream once it is 
playing, you can use the regular voice_*() functions with stream->voice 
as a parameter. The format of the sample data is described in the SAMPLE 
entry of the "Structures and types defined by Allegro" chapter. The formula 
to get the size of the buffers in bytes could be: 
\par {\s1 \f1\fs18 
\par       bytes = length * (bits / 8) * (stereo ? 2 : 1)\par}
\par Example: 
\par {\s1 \f1\fs18 
\par       /* Create a 22KHz 8bit mono audio stream. */
\par       stream = play_audio_stream(1024, 8, FALSE, 22050, 255, 128);
\par       if (!stream)
\par          abort_on_error("Error creating audio stream!\\n");\par}
\par This function returns a pointer to the audio stream or NULL if it could 
not be created. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v stop_audio_stream}stop_audio_stream(AUDIOSTREAM *stream);\par }
{\li400 Destroys an audio stream when it is no longer required. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void *{\xe\v get_audio_stream_buffer}get_audio_stream_buffer(AUDIOSTREAM *stream);\par }
{\li400 You must call this function at regular intervals while an audio stream is 
playing, to provide the next buffer of sample data (the smaller the 
stream buffer size, the more often it must be called). This function should 
not be called from a timer handler. Example: 
\par {\s1 \f1\fs18 
\par       void *mem_chunk;
\par       ...
\par       while (TRUE) \{
\par          ...
\par          mem_chunk = get_audio_stream_buffer(buffer);
\par          if (mem_chunk != NULL) \{
\par             /* Refill the stream buffer. */
\par          \}
\par       \}\par}
\par If it returns NULL, the stream is still playing the previous lot of data, 
so you don't need to do anything. If it returns a value, that is the 
location of the next buffer to be played, and you should load the 
appropriate number of samples (however many you specified when creating the 
stream) to that address, for example using an fread() from a disk file. 
After filling the buffer with data, call free_audio_stream_buffer() to 
indicate that the new data is now valid. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v free_audio_stream_buffer}free_audio_stream_buffer(AUDIOSTREAM *stream);\par }
{\li400 Call this function after get_audio_stream_buffer() returns a non-NULL 
address, to indicate that you have loaded a new block of samples to that 
location and the data is now ready to be played. Example: 
\par {\s1 \f1\fs18 
\par       mem_chunk = get_audio_stream_buffer(buffer);
\par       if (mem_chunk != NULL) \{
\par          /* Refill the stream buffer. */
\par          ...
\par          free_audio_stream_buffer(buffer);
\par       \}\par}
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Recording routines}Recording routines\par }
Allegro provides routines to capture sound from the sound card, be it digital 
samples or MIDI notes. Ideally this would allow you to create games where 
basic speech recognition could be implemented, or voice messages in 
multiplayer games over a network. However, many old sound cards are not full 
duplex. This means, that the sound device can only be playing or recording, 
but not both at the same time. 
\par \par Any Windows 2000 or better machine comes with a full duplex sound card and 
updated drivers. All MacOS X machines allow full duplex recording. Under Unix 
your mileage may vary: you can have the right hardware for the task, but the 
drivers might not support this feature. Under DOS you should forget about full 
duplex altogether. 
\par \par To find out if your system allows this feature, use the akaitest program, 
distributed along with Allegro, in the `tests' directory. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v install_sound_input}install_sound_input(int digi, int midi);\par }
{\li400 Initialises the sound recorder module. You must install the normal sound 
playback system before calling this routine. The two card parameters should 
use the same constants as install_sound(), including DIGI_NONE and 
MIDI_NONE to disable parts of the module, or DIGI_AUTODETECT and 
MIDI_AUTODETECT to guess the hardware. 
\par \par This function returns zero on success, and any other value if the machine 
or driver doesn't support sound recording. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v remove_sound_input}remove_sound_input();\par }
{\li400 Cleans up after you are finished with the sound input routines. You don't 
normally need to call this, because remove_sound() and/or allegro_exit() 
will do it for you. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_sound_input_cap_bits}get_sound_input_cap_bits();\par }
{\li400 Checks which sample formats are supported by the current audio input 
driver, returning one of the bitfield values: 
\par {\s1 \f1\fs18 
\par       0 = audio input not supported
\par       8 = eight bit audio input is supported
\par       16 = sixteen bit audio input is supported
\par       24 = both eight and sixteen bit audio input are supported\par}
\par Example: 
\par {\s1 \f1\fs18 
\par       cap = get_sound_input_cap_bits();
\par       if (cap == 0) \{
\par          /* Ugh, no audio input supported? */
\par       \} else \{
\par          if (cap & 8) \{
\par             /* We have eight bit audio input. */
\par          \}
\par          if (cap & 16) \{
\par             /* We have sixteen bit audio input. */
\par          \}
\par       \}\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_sound_input_cap_stereo}get_sound_input_cap_stereo();\par }
{\li400 Checks whether the current audio input driver is capable of stereo 
recording. 
\par \par Returns non-zero if the driver is capable of stereo recording. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_sound_input_cap_rate}get_sound_input_cap_rate(int bits, int stereo);\par }
{\li400 Returns the maximum possible sample frequency for recording in the 
specified format, or zero if these settings are not supported. The bits 
parameter is the number of bits of the audio, and stereo is a boolean 
parameter. Pass zero for mono, non-zero for stereo input. Example: 
\par {\s1 \f1\fs18 
\par       int max_freq;
\par       ...
\par       /* What frequency can we record 8 bits mono at? */
\par       max_freq = get_sound_input_cap_rate(8, 0);
\par       if (max_freq > 22000) \{
\par          /* Ok, 22KHz and above is good enough. */
\par       \}\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_sound_input_cap_parm}get_sound_input_cap_parm(int rate, int bits, int stereo);\par }
{\li400 Checks whether the specified recording frequency, number of bits, and 
mono/stereo mode are supported (and how) by the current audio driver. 
\par \par The function returns one of the following possible values: 
\par {\s1 \f1\fs18 
\par       0  = It is impossible to record in this format.
\par       1  = Recording is possible, but audio output
\par            will be suspended.
\par       2  = Recording is possible at the same time as
\par            playing other sounds (full duplex sound card).
\par       -n = Sampling rate not supported, but rate 'n'
\par            would work instead.\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v set_sound_input_source}set_sound_input_source(int source);\par }
{\li400 Selects the audio input source. The parameter should be one of the values: 
\par {\s1 \f1\fs18 
\par       SOUND_INPUT_MIC
\par       SOUND_INPUT_LINE
\par       SOUND_INPUT_CD\par}
\par The function returns zero on success, or -1 if the hardware does not 
provide an input select register (ie. you have no control over the input 
source). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v start_sound_input}start_sound_input(int rate, int bits, int stereo);\par }
{\li400 Starts recording in the specified format, suspending audio playback as 
necessary if the card is not full duplex. 
\par \par Returns the buffer size in bytes if successful, or zero on error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v stop_sound_input}stop_sound_input();\par }
{\li400 Stops audio recording, switching the card back into the normal playback 
mode. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v read_sound_input}read_sound_input(void *buffer);\par }
{\li400 Retrieves the most recently recorded audio buffer into the specified 
location. The buffer size can be obtained by checking the return value 
from start_sound_input(). You must be sure to call this 
function at regular intervals during the recording (typically around 100 
times a second), or some data will be lost. If you are unable to do this 
often enough from the mainline code, use the digi_recorder() callback to 
store the waveform into a larger buffer of your own. 
\par \par Note: many cards produce a click or popping sound when switching between 
record and playback modes, so it is often a good idea to discard the 
first buffer after you start a recording. The waveform is always stored 
in unsigned format, with stereo data consisting of alternate left/right 
samples. 
\par \par The function will return non-zero if a buffer has been copied or zero if 
no new data is yet available (you were too fast checking the input). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern void (*{\xe\v digi_recorder}digi_recorder)();\par }
{\li400 If set, this function is called by the input driver whenever a new sample 
buffer becomes available, at which point you can use read_sound_input() 
to copy the data into a more permanent location. It runs in an interrupt 
context, so it must execute very quickly, the code and all memory that it 
touches must be locked, and you cannot call any operating system routines 
or access disk files. This currently works only under DOS. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern void (*{\xe\v midi_recorder}midi_recorder)(unsigned char data);\par }
{\li400 If set, this function is called by the MIDI input driver whenever a new 
byte of MIDI data becomes available. It runs in an interrupt context, so 
it must execute very quickly and all the code/data must be locked. This 
currently works only under DOS and Windows. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v File and compression routines}File and compression routines\par }
The following routines implement a fast buffered file I/O system, which 
supports the reading and writing of compressed files using a ring buffer 
algorithm based on the LZSS compressor by Haruhiko Okumura. This does not 
achieve quite such good compression as programs like zip and lha, but 
unpacking is very fast and it does not require much memory. Packed files 
always begin with the 32-bit value F_PACK_MAGIC, and autodetect files with 
the value F_NOPACK_MAGIC. 
\par \par The following FA_* flags are guaranteed to work: 
\par {\s1 \f1\fs18 
\par       FA_NONE           - Exclude files that have any attribute set
\par       FA_RDONLY         - Directory entries that are unwritable for current user
\par       FA_HIDDEN         - Hidden flag
\par       FA_DIREC          - Directories
\par       FA_SYSTEM         - Files with system flag set (DOS/Windows only)
\par       FA_LABEL          - Files with volume label flag set (DOS/Windows only)
\par       FA_ARCH           - Files with archive flag set (DOS/Windows only)
\par       FA_ALL            - Match all attributes\par}
\par Do not use any other flags from DOS/Windows or your code will not compile on 
another platform. 
FA_RDONLY is for directory entries with read-only flag on DOS-like systems or 
unwritable by current user on Unix-like systems. Hidden files are directory 
entries that have the hidden flag set (DOS/Windows) or have names starting with 
'.' (UNIX, excluding '.' and '..'). 
Flags can be combined using '|' (binary OR operator). 
\par \par When passed to the functions as the 'attrib' parameter, these flags 
represent an upper set in which the actual flag set of a matching file must 
be included. That is, in order for a file to be matching, its attributes 
may contain any of the specified flags but must not contain any of the 
unspecified flags. In other words, you explicitly {\i exclude\par}\par  the flags that you 
do {\i not\par}\par  specify. Thus if you pass 'FA_DIREC | FA_RDONLY', normal files 
and directories will be included as well as read-only files and 
directories, but not hidden files and directories. Similarly, if you pass 
'FA_ARCH' then both archived and non-archived files will be included. If 
FA_NONE is passed all attributes are excluded and only files with no attributes 
are returned. Conversely, if you pass FA_ALL, no attributes are excluded so all 
files are returned (which is what you would usually want). 
\par \par Functions which accept wildcards as file names support the meta characters 
`*' (which means, zero or any quantity of characters) and `?' (which means 
any character, but only one). 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_executable_name}get_executable_name(char *buf, int size);\par }
{\li400 Fills `buf' with the full path to the current executable, writing at most 
`size' bytes.  This generally comes from `argv[0]' but on Unix systems it 
tries to get the information from the `/proc' filesystem first, searching 
the directories specified in `$PATH' if necessary. If this fails too, it 
tries to find the executable name from the output of the `ps' command, 
using `argv[0]' only as a last resort if all other options fail. Example: 
\par {\s1 \f1\fs18 
\par       char name[200];
\par       ...
\par       get_executable_name(name, sizeof(name));
\par       allegro_message("Running `%s'\\n", name);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v fix_filename_case}fix_filename_case(char *path);\par }
{\li400 Converts the filename stored in `path' to a standardised case. On DOS 
platforms, they will be entirely uppercase. On other platforms this 
function doesn't do anything. Example: 
\par {\s1 \f1\fs18 
\par       get_executable_name(name, sizeof(name));
\par       fix_filename_case(name);
\par       allegro_message("Running `%s'\\n", name);\par}
\par Returns a copy of the `path' parameter. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v fix_filename_slashes}fix_filename_slashes(char *path);\par }
{\li400 Converts all the directory separators in the filename stored in `path' to 
a standard character. On DOS and Windows platforms, this is a backslash. 
On most other platforms this is a slash. Example: 
\par {\s1 \f1\fs18 
\par       char buf[200] = "c:/dos\\\\backup/weirdo\\\\test";
\par       ...
\par       fix_filename_slashes(buf);
\par       /* Under DOS we would have c:\\dos\\backup\\weirdo\\test.
\par          Under Unix we would have c:/dos/backup/weirdo/test. */\par}
\par Returns a copy of the `path' parameter. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v canonicalize_filename}canonicalize_filename(char *dest, const char *filename, int size);\par }
{\li400 Converts any filename into its canonical form, i.e. the minimal absolute 
filename describing the same file and fixing incorrect forward/backward 
slashes for the current platform, storing at most `size' bytes into the 
`dest' buffer. You can use the same buffer both as input and output 
because Allegro internally works on a copy of the input before touching 
`dest'. Example: 
\par {\s1 \f1\fs18 
\par       char buf[256];
\par       ...
\par       canonicalize_filename(buf, "~/../s22/..\\\\t3st///hi.c",
\par                             sizeof(buf));
\par       /* Running this under Unix would
\par          return: /home/t3st/hi.c */
\par }\par Note that this function won't work as expected if the path to canonicalize 
comes from another platform (eg. a "c:\\something" path will canonicalize 
into something really wrong under Unix: "/current/path/c:/something"). 
\par \par Returns a copy of the `dest' parameter. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v make_absolute_filename}make_absolute_filename(char *dest, const char *path, const char *filename, int size);\par }
{\li400 Makes an absolute filename from an absolute path and a relative filename, 
storing at most `size' bytes into the `dest' buffer. This is like calling 
replace_filename() and then canonicalize_filename(). Example: 
\par {\s1 \f1\fs18 
\par       char buf[256];
\par       ...
\par       make_absolute_filename(buf, "/usr/games/",
\par                              "../temp.txt", sizeof(buf));
\par       /* This would create /usr/temp.txt */\par}
\par Returns a copy of the `dest' parameter. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v make_relative_filename}make_relative_filename(char *dest, const char *path, const char *filename, int size);\par }
{\li400 Attempts to make a relative filename from an absolute path and an absolute 
filename, storing at most `size' bytes into the `dest' buffer. This 
function won't work if the paths are not canonical under the current 
platform (see canonicalize_filename()). Also, `dest' cannot be used as 
input value for `path' or `filename'. Example: 
\par {\s1 \f1\fs18 
\par       char base[] = "/long/absolute/path/program.exe";
\par       char user_input[] = "/nice/and/short.txt";
\par       ...
\par       make_relative_filename(buf, base, user_input, sizeof(buf));
\par       /* Under Unix buf would contain:
\par          ../../../nice/and/short.txt */\par}
\par Returns a copy of the `dest' parameter if it succeeds or NULL if it fails 
(eg. under DOS, one path starts with "C:\\" and another with "A:\\"). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v is_relative_filename}is_relative_filename(const char *filename);\par }
{\li400 Returns TRUE if the filename is relative or FALSE if it is absolute. Note 
that an absolute filename under DOS (with a device separator) will be 
considered as relative under Unix, because there absolute paths always 
start with a slash. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v replace_filename}replace_filename(char *dest, const char *path,  const char *filename, int size);\par }
{\li400 Replaces the specified path+filename with a new filename tail, storing 
at most `size' bytes into the `dest' buffer. You can use the same buffer 
both as input and output because Allegro internally works on a copy of 
the input before touching `dest'. Example: 
\par {\s1 \f1\fs18 
\par       char name[200];
\par       ...
\par       get_executable_name(name, sizeof(name));
\par       replace_filename(name, name, "sound.dat", sizeof(name));\par}
\par Returns a copy of the `dest' parameter. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v replace_extension}replace_extension(char *dest, const char *filename,  const char *ext, int size);\par }
{\li400 Replaces the specified filename+extension with a new extension tail, 
storing at most `size' bytes into the `dest' buffer. If the filename 
doesn't have any extension at all, `ext' will be appended to it, adding 
a dot character if needed. You can use the same buffer both as input and 
output because Allegro internally works on a copy of the input before 
touching `dest'. Example: 
\par {\s1 \f1\fs18 
\par       replace_extension(buf, "C:\\\\game\\\\prog.exe",
\par                         "dat", sizeof(buf));\par}
\par Returns a copy of the `dest' parameter. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v append_filename}append_filename(char *dest, const char *path,  const char *filename, int size);\par }
{\li400 Concatenates the specified filename onto the end of the specified path, 
storing at most `size' bytes into the `dest' buffer. If `path' doesn't 
have a trailing path separator, the function will append one if needed. 
You can use the same buffer both as input and output because Allegro 
internally works on a copy of the input before touching `dest'. Example: 
\par {\s1 \f1\fs18 
\par       append_filename(buf, "/home/user",
\par                       "prog.bin", sizeof(buf));\par}
\par Returns a copy of the `dest' parameter. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v get_filename}get_filename(const char *path);\par }
{\li400 Finds out the filename portion of a completely specified file path. Both 
`\\' and `/' are recognized as directory separators under DOS and Windows. 
However, only `/' is recognized as directory separator under other 
platforms. Example: 
\par {\s1 \f1\fs18 
\par       get_executable_name(name, sizeof(name));
\par       allegro_message("Running `%s'\\n", get_filename(name));
\par }\par Note that Allegro won't perform any IO operations during the verification. 
This means that if you have `/a/path/like/this/', which doesn't have a 
filename, the function will return a pointer to the trailing null 
character. However, if you have `/a/path/like/this', Allegro will return 
a pointer to `this', even if it is a valid directory. 
\par \par Returns a pointer to the portion of `path' where the filename starts, or 
the beginning of `path' if no valid filename is found (eg. you are 
processing a path with backslashes under Unix). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v get_extension}get_extension(const char *filename);\par }
{\li400 Finds out the extension of the filename (with or without path 
information). Example: 
\par {\s1 \f1\fs18 
\par       get_executable_name(name, sizeof(name));
\par       allegro_message("The binary has the extension `%s'\\n",
\par                       get_extension(name));\par}
\par Returns a pointer to the portion of `filename' where the extension starts, 
or a pointer to the trailing null character if there is no filename or it 
doesn't have extension. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v put_backslash}put_backslash(char *filename);\par }
{\li400 If the last character of the filename is not a `\\', `/', `#' or a device 
separator (ie. `:' under DOS), this routine will concatenate either a `\\' 
or `/' on to it (depending on the platform). Note: ignore the function 
name, it's out of date. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_filename_encoding}set_filename_encoding(int encoding)\par }
{\li400 Sets the encoding to use for filenames. By default, UTF-8 is assumed. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v get_filename_encoding}get_filename_encoding(void)\par }
{\li400 Returns the encoding currently assumed for filenames. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v file_exists}file_exists(const char *filename, int attrib, int *aret);\par }
{\li400 Checks whether a file matching the given name and attributes (see 
beginning of this chapter) exists. If `aret' is not NULL, it will be set 
to the attributes of the matching file. Example: 
\par {\s1 \f1\fs18 
\par       /* Check for a normal file. */
\par       if (file_exists("franken.dat", 0, NULL))
\par          allegro_message("It is alive!\\n");\par}
\par Returns non-zero if the file exists, or zero if it doesn't or the 
specified attributes mask it out. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v exists}exists(const char *filename);\par }
{\li400 Shortcut version of file_exists(), which checks for normal files, which 
may have the archive or read-only bits set, but are not hidden, 
directories, system files, etc. 
\par \par Returns non-zero if the file exists, or zero if it doesn't. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b uint64_t {\xe\v file_size_ex}file_size_ex(const char *filename);\par }
{\li400 Returns the size of a file, in bytes. If the file does not exist or an 
error occurs, it will return zero and store the system error code in 
errno. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b time_t {\xe\v file_time}file_time(const char *filename);\par }
{\li400 Returns the modification time (number of seconds since 00:00:00 GMT 
1/1/1970) of a file. If the file does not exist or an error occurs, it 
will return zero and store the system error code in errno. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v delete_file}delete_file(const char *filename);\par }
{\li400 Removes a file from the disk. You can't delete directories, though. 
\par \par Returns zero on success, non-zero on failure. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v for_each_file_ex}for_each_file_ex(const char *name, int in_attrib, int out_attrib, int (*callback)(const char *filename, int attrib, void *param), void *param);\par }
{\li400 Finds all the files on disk which match the given wildcard specification 
and file attributes, and executes callback() once for each. Basically, this 
is a convenient wrapper around al_findfirst(), al_findnext() and 
al_findclose(). `in_attrib' is a bitmask specifying the attributes the 
files must carry, `out_attrib' is a bitmask specifying the attributes the 
files must not carry; attributes which are not specified in either bitmasks 
are not taken into account for deciding whether callback() is invoked or 
not. 
\par \par The callback function will be passed three arguments: the first is a string 
which contains the completed filename (exactly the same string you passed 
to for_each_file_ex() but with meta characters), the second is the actual 
attributes of the file, and the third is a void pointer which is simply a 
copy of `param' (you can use this for whatever you like). The callback must 
return zero to let the enumeration proceed, or any non-zero value to stop 
it. If an error occurs, the error code will be stored in `errno' but the 
enumeration won't stop. Example: 
\par {\s1 \f1\fs18 
\par       int show_name(const char *filename, int attrib, void *param)
\par       \{
\par          allegro_message("Caught `%s', attribs %d\\n",
\par                          filename, attrib);
\par          return 0;
\par       \}
\par       ...
\par          count = for_each_file_ex("data/level*", FA_DIREC,
\par                                   0, show_name, 0);
\par          allegro_message("%d game directories\\n", count);\par}
\par Returns the number of successful calls made to callback(), that is, the 
number of times callback() was called and returned 0. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v al_findfirst}al_findfirst(const char *pattern, struct al_ffblk *info, int attrib);\par }
{\li400 Low-level function for searching files. This function finds the first 
file which matches the given wildcard specification and file attributes 
(see above). The information about the file (if any) will be put in the 
al_ffblk structure which you have to provide. The al_ffblk structure 
looks like: 
\par {\s1 \f1\fs18 
\par       struct al_ffblk
\par       \{
\par          int attrib;       - actual attributes of the file found
\par          time_t time;      - modification time of file
\par          char name[512];   - name of file
\par       \};
\par }\par There is some other stuff in the structure as well, but it is there for 
internal use only. Example: 
\par {\s1 \f1\fs18 
\par       struct al_ffblk info;
\par 
\par       if (al_findfirst("*.pcx", &info, FA_ALL) != 0) \{
\par          /* Tell user there are no PCX files. */
\par          return;
\par       \}\par}
\par The function returns non-zero if no match is found or if an error occurred 
and, in the latter case, sets `errno' accordingly. It returns zero if a 
match is found, allocating some memory for internal use in the structure. 
Therefore you have to close your search when you are finished to avoid 
memory leaks in your program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v al_findnext}al_findnext(struct al_ffblk *info);\par }
{\li400 This finds the next file in a search started by al_findfirst(). Example: 
\par {\s1 \f1\fs18 
\par       if (al_findfirst("*.pcx", &info, 0) != 0)
\par          return;
\par 
\par       do \{
\par          /* Do something useful here with info.name. */
\par       \} while (al_findnext(&info) == 0);
\par 
\par       al_findclose(&info);\par}
\par Returns zero if a match is found, non-zero if none is found or if an 
error occurred and, in the latter case, sets errno accordingly. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v al_findclose}al_findclose(struct al_ffblk *info);\par }
{\li400 This closes a previously opened search with al_findfirst(). You need to 
call this on all successfully opened searches to avoid memory leaks in 
your program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b uint64_t {\xe\v al_ffblk_get_size}al_ffblk_get_size(struct al_ffblk *info);\par }
{\li400 This returns the size of the file returned by al_findfirst or al_findnext. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v find_allegro_resource}find_allegro_resource(char *dest, const char *resource,  const char *ext, const char *datafile,  const char *objectname, const char *envvar,  const char *subdir, int size);\par }
{\li400 Searches for a support file, eg. `allegro.cfg' or `language.dat'. Passed a 
resource string describing what you are looking for, along with extra 
optional information such as the default extension, what datafile to look 
inside, what the datafile object name is likely to be, any special 
environment variable to check, and any subdirectory that you would like 
to check as well as the default location, this function looks in a hell 
of a lot of different places :-). Pass NULL for the parameters you are not 
using. 
\par \par Check the documentation chapter specific to your platform for information 
on additional paths this function might search for. Also, don't forget 
about set_allegro_resource_path() to extend the searches. Example: 
\par {\s1 \f1\fs18 
\par       char path[256];
\par       int ret;
\par       ret = find_allegro_resource(path, "scores.cfg", NULL, NULL,
\par                                   NULL, NULL, NULL, sizeof(path));
\par       if (ret == 0) \{
\par          /* Found system wide scores file. */
\par       \} else \{
\par          /* No previous scores, create our own file. */
\par       \}\par}
\par Returns zero on success, and stores a full path to the file (at most size 
bytes) into the dest buffer. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v set_allegro_resource_path}set_allegro_resource_path(int priority, const char *path);\par }
{\li400 Sometimes Allegro doesn't look in enough places to find a resource. For 
those special cases, you can call this function before loading your 
resource with additional paths to search for. You set up the priorities, 
higher numbers are searched for first. To modify an already setup path, 
call this function with the same priority and the new path. To remove an 
already setup path, call this function with the priority of the path and 
NULL as the path parameter. Example: 
\par {\s1 \f1\fs18 
\par       set_allegro_resource_path(10, "my_game/configs");
\par       set_allegro_resource_path(0, "users/configs/");
\par       set_allegro_resource_path(-45, "temp");
\par }\par These custom paths will be valid until you call allegro_exit(). You can 
call this function before install_allegro(), but after set_uformat() if 
you want to use a text encoding format other than the default. 
\par \par Returns non-zero on success, zero if the path could not be added or you 
wanted to remove a path and the priority used didn't have any associated 
path. Modification of existing paths always succeeds. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v packfile_password}packfile_password(const char *password);\par }
{\li400 Sets the encryption password to be used for all read/write operations 
on files opened in future using Allegro's packfile functions (whether 
they are compressed or not), including all the save, load and config 
routines. Files written with an encryption password cannot be read 
unless the same password is selected, so be careful: if you forget the 
key, nobody can make your data come back again! Pass NULL or an empty 
string to return to the normal, non-encrypted mode. If you are using 
this function to prevent people getting access to your datafiles, be 
careful not to store an obvious copy of the password in your executable: 
if there are any strings like "I'm the password for the datafile", it 
would be fairly easy to get access to your data :-) 
\par \par Note #1: when writing a packfile, you can change the password to whatever 
you want after opening the file, without affecting the write operation. 
On the contrary, when writing a sub-chunk of a packfile, you must make 
sure that the password that was active at the time the sub-chunk was 
opened is still active before closing the sub-chunk. This is guaranteed 
to be true if you didn't call the packfile_password() routine in the 
meantime. Read operations, either on packfiles or sub-chunks, have no 
such restriction. 
\par \par Note #2: as explained above, the password is used for all read/write 
operations on files, including for several functions of the library that 
operate on files without explicitly using packfiles (e.g. load_bitmap()). 
The unencrypted mode is mandatory in order for those functions to work. 
Therefore remember to call packfile_password(NULL) before using them if 
you previously changed the password. As a rule of thumb, always call 
packfile_password(NULL) when you are done with operations on packfiles. 
The only exception to this is custom packfiles created with 
pack_fopen_vtable(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b PACKFILE *{\xe\v pack_fopen}pack_fopen(const char *filename, const char *mode);\par }
{\li400 Opens a file according to mode, which may contain any of the flags: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 `r' - open file for reading. 
\par \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 `w' - open file for writing, overwriting any existing data. 
\par \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 `p' - open file in packed mode. Data will be compressed as it is 
written to the file, and automatically uncompressed during read 
operations. Files created in this mode will produce garbage if 
they are read without this flag being set. 
\par \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 `!' - open file for writing in normal, unpacked mode, but add the 
value F_NOPACK_MAGIC to the start of the file, so that it can 
later be opened in packed mode and Allegro will automatically 
detect that the data does not need to be decompressed. 
\par}\pard \li400 \par Instead of these flags, one of the constants F_READ, F_WRITE, 
F_READ_PACKED, F_WRITE_PACKED or F_WRITE_NOPACK may be used as the mode 
parameter. 
\par \par The packfile functions also understand several "magic" filenames that are 
used for special purposes. These are: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 `#' - read data that has been appended to your executable file with 
the exedat utility, as if it was a regular independent disk file. 
\par \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 `filename.dat#object_name' - open a specific object from a datafile, 
and read from it as if it was a regular file. You can treat nested 
datafiles exactly like a normal directory structure, for example 
you could open `filename.dat#graphics/level1/mapdata'. 
\par \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 `#object_name' - combination of the above, reading an object from a 
datafile that has been appended onto your executable. 
\par}\pard \li400 \par With these special filenames, the contents of a datafile object or 
appended file can be read in an identical way to a normal disk file, so 
any of the file access functions in Allegro (eg. load_pcx() and 
set_config_file()) can be used to read from them. Note that you can't 
write to these special files, though: the fake file is read only. Also, 
you must save your datafile uncompressed or with per-object compression 
if you are planning on loading individual objects from it (otherwise 
there will be an excessive amount of seeking when it is read). 
\par \par Finally, be aware that the special Allegro object types aren't the same 
format as the files you import the data from. When you import data like 
bitmaps or samples into the grabber, they are converted into a special 
Allegro-specific format, but the `#' marker file syntax reads the objects 
as raw binary chunks. This means that if, for example, you want to use 
load_pcx() to read an image from a datafile, you should import it as a 
binary block rather than as a BITMAP object. 
\par \par Example: 
\par {\s1 \f1\fs18 
\par       PACKFILE *input_file;
\par 
\par       input_file = pack_fopen("scores.dat", "rp");
\par       if (!input_file)
\par          abort_on_error("Couldn't read `scores.dat'!");\par}
\par On success, pack_fopen() returns a pointer to a PACKFILE structure, and on 
error it returns NULL and stores an error code in `errno'. An attempt to 
read a normal file in packed mode will cause `errno' to be set to EDOM. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b PACKFILE *{\xe\v pack_fopen_vtable}pack_fopen_vtable(const PACKFILE_VTABLE *vtable, void *userdata);\par }
{\li400 Creates a new packfile structure that uses the functions specified in 
the vtable instead of the standard functions. The data pointer by `vtable' 
and `userdata' must remain available for the lifetime of the created 
packfile. 
\par \par While the created packfile structure can be used with other Allegro 
functions, there are two limitations. First, opening chunks using 
pack_fopen_chunk() on top of the returned packfile is not possible at this 
time. And packfile_password() does not have any effect on packfiles opened 
with pack_fopen_vtable(). 
\par \par On success, it returns a pointer to a PACKFILE structure, and on error it 
returns NULL and stores an error code in `errno'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v pack_fclose}pack_fclose(PACKFILE *f);\par }
{\li400 Closes the stream `f' previously opened with pack_fopen() or 
pack_fopen_vtable(). After you have closed the stream, performing 
operations on it will yield errors in your application (e.g. crash it) or 
even block your OS. 
\par \par Returns zero on success. On error, returns an error code which is also 
stored in `errno'. This function can fail only when writing to files: if 
the file was opened in read mode, it will always succeed. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v pack_fseek}pack_fseek(PACKFILE *f, int offset);\par }
{\li400 Moves the position indicator of the stream `f'. Unlike the standard fseek() 
function, this only supports forward movements relative to the current 
position and in read-only streams, so don't use negative offsets. Note that 
seeking is very slow when reading compressed files, and so should be 
avoided unless you are sure that the file is not compressed. Example: 
\par {\s1 \f1\fs18 
\par       input_file = pack_fopen("data.bin", "r");
\par       if (!input_file)
\par          abort_on_error("Couldn't open binary data!");
\par       /* Skip some useless header before reading data. */
\par       pack_fseek(input_file, 32);\par}
\par Returns zero on success or a negative number on error, storing the error 
code in `errno'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v pack_feof}pack_feof(PACKFILE *f);\par }
{\li400 Finds out if you have reached the end of the file. It does not wait for you 
to attempt to read beyond the end of the file, contrary to the ISO C feof() 
function. The only way to know whether you have read beyond the end of the 
file is to check the return value of the read operation you use (and be 
wary of pack_*getl() as EOF is also a valid return value with these 
functions). 
\par \par Returns non-zero if you are at the end of the file, zero otherwise. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v pack_ferror}pack_ferror(PACKFILE *f);\par }
{\li400 Since EOF is used to report errors by some functions, it's often better to 
use the pack_feof() function to check explicitly for end of file and 
pack_ferror() to check for errors. Both functions check indicators that 
are part of the internal state of the stream to detect correctly the 
different situations. 
\par \par Returns nonzero if the error indicator for the stream is set, meaning 
that an error has occurred during a previous operation on the stream. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v pack_getc}pack_getc(PACKFILE *f);\par }
{\li400 Returns the next character from the stream `f', or EOF if the end of the 
file has been reached. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v pack_ungetc}pack_ungetc(int c, PACKFILE *f);\par }
{\li400 Puts a character back to the file's input buffer. Like with ungetc from 
libc, only a single push back is guaranteed. 
\par \par Note: pack_fgets internally uses pack_ungetc, so never use pack_ungetc 
directly after using pack_fgets on a PACKFILE. 
\par \par Returns c on success, or EOF on error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v pack_putc}pack_putc(int c, PACKFILE *f);\par }
{\li400 Puts a character in the stream f. 
\par \par Returns the character written on success, or EOF on error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v pack_igetw}pack_igetw(PACKFILE *f);\par }
{\li400 Like pack_getc, but reads a 16-bit word from a file, using Intel byte 
ordering (least significant byte first, a.k.a. little-endian). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v pack_iputw}pack_iputw(int c, PACKFILE *f);\par }
{\li400 Like pack_putc, but writes a 16-bit word to a file, using Intel byte 
ordering (least significant byte first, a.k.a. little-endian). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b long {\xe\v pack_igetl}pack_igetl(PACKFILE *f);\par }
{\li400 Like pack_getc, but reads a 32-bit long from a file, using Intel byte 
ordering (least significant byte first, a.k.a. little-endian). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b long {\xe\v pack_iputl}pack_iputl(long c, PACKFILE *f);\par }
{\li400 Like pack_putc, but writes a 32-bit long to a file, using Intel byte 
ordering (least significant byte first, a.k.a. little-endian). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v pack_mgetw}pack_mgetw(PACKFILE *f);\par }
{\li400 Like pack_getc, but reads a 16-bit word from a file, using Motorola byte 
ordering (most significant byte first, a.k.a. big-endian). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v pack_mputw}pack_mputw(int c, PACKFILE *f);\par }
{\li400 Like pack_putc, but writes a 16-bit word to a file, using Motorola byte 
ordering (most significant byte first, a.k.a. big-endian). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b long {\xe\v pack_mgetl}pack_mgetl(PACKFILE *f);\par }
{\li400 Like pack_getc, but reads a 32-bit long from a file, using Motorola byte 
ordering (most significant byte first, a.k.a. big-endian). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b long {\xe\v pack_mputl}pack_mputl(long c, PACKFILE *f);\par }
{\li400 Like pack_putc, but writes a 32-bit long to a file, using Motorola byte 
ordering (most significant byte first, a.k.a. big-endian). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b long {\xe\v pack_fread}pack_fread(void *p, long n, PACKFILE *f);\par }
{\li400 Reads `n' bytes from the stream `f', storing them at the memory location 
pointed to by `p'. Example: 
\par {\s1 \f1\fs18 
\par       unsigned char buf[256];
\par       ...
\par       if (pack_fread(buf, 256, input_file) != 256)
\par          abort_on_error("Truncated input file!");\par}
\par Returns the number of bytes read, which will be less than `n' if EOF is 
reached or an error occurs. Error codes are stored in errno. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b long {\xe\v pack_fwrite}pack_fwrite(const void *p, long n, PACKFILE *f);\par }
{\li400 Writes `n' bytes to the stream `f' from memory location pointed to by `p'. 
\par \par Returns the number of bytes written, which will be less than n if an 
error occurs. Error codes are stored in errno. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b char *{\xe\v pack_fgets}pack_fgets(char *p, int max, PACKFILE *f);\par }
{\li400 Reads a line from the stream `f', storing it at location pointed to by 
`p'. Stops when a linefeed is encountered, or `max' bytes have been read. 
The end of line is handled by detecting the right combination of characters 
for the platform. This supports CR-LF (DOS/Windows), LF (Unix), and CR 
(Mac) formats. However, the trailing carriage return is not included in the 
returned string, in order to provide easy code portability across 
platforms. If you need the carriage return, use pack_fread() and/or 
pack_getc() instead. 
\par \par Note: This function internally may make calls to pack_ungetc, so you cannot 
use pack_ungetc directly afterwards. 
\par \par Example: 
\par {\s1 \f1\fs18 
\par       char buf[256];
\par       ...
\par       while (pack_fgets(buf, sizeof(buf), input_file)) \{
\par          /* Process input line. */
\par       \}
\par       fclose(input_file);\par}
\par Returns the pointer `p' on success, or NULL on error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v pack_fputs}pack_fputs(const char *p, PACKFILE *f);\par }
{\li400 Writes a string to the stream `f'. The input string is converted from the 
current text encoding format to UTF-8 before writing. Newline characters 
are written as `\\r\\n' on DOS and Windows platforms. If you don't want this 
behaviour, use pack_fwrite() and/or pack_putc() instead. 
\par \par Returns zero on success or a negative number on error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b PACKFILE *{\xe\v pack_fopen_chunk}pack_fopen_chunk(PACKFILE *f, int pack);\par }
{\li400 Opens a sub-chunk of a file. Chunks are primarily intended for use by the 
datafile code, but they may also be useful for your own file routines. A 
chunk provides a logical view of part of a file, which can be compressed 
as an individual entity and will automatically insert and check length 
counts to prevent reading past the end of the chunk. The PACKFILE 
parameter is a previously opened file, and `pack' is a boolean parameter 
which will turn compression on for the sub-chunk if it is non-zero. 
Example: 
\par {\s1 \f1\fs18 
\par       PACKFILE *output = pack_fopen("out.raw", "w!");
\par       ...
\par       /* Create a sub-chunk with compression. */
\par       output = pack_fopen(chunk(output, 1);
\par       if (!output)
\par          abort_on_error("Error saving data!");
\par       /* Write some data to the sub-chunk. */
\par       ...
\par       /* Close the sub-chunk, recovering parent file. */
\par       output = pack_fclose_chunk(output);
\par }\par The data written to the chunk will be prefixed with two length counts 
(32-bit, a.k.a. big-endian). For uncompressed chunks these will both be 
set to the size of the data in the chunk. For compressed chunks (created 
by setting the `pack' flag), the first length will be the raw size of the 
chunk, and the second will be the negative size of the uncompressed data. 
\par \par To read the chunk, use the following code: 
\par {\s1 \f1\fs18 
\par       PACKFILE *input = pack_fopen("out.raw", "rp");
\par       ...
\par       input = pack_fopen_chunk(input, 1);
\par       /* Read data from the sub-chunk and close it. */
\par       ...
\par       input = pack_fclose_chunk(input);
\par }\par This sequence will read the length counts created when the chunk was 
written, and automatically decompress the contents of the chunk if it 
was compressed. The length will also be used to prevent reading past the 
end of the chunk (Allegro will return EOF if you attempt this), and to 
automatically skip past any unread chunk data when you call 
pack_fclose_chunk(). 
\par \par Chunks can be nested inside each other by making repeated calls to 
pack_fopen_chunk(). When writing a file, the compression status is 
inherited from the parent file, so you only need to set the pack flag if 
the parent is not compressed but you want to pack the chunk data. If the 
parent file is already open in packed mode, setting the pack flag will 
result in data being compressed twice: once as it is written to the 
chunk, and again as the chunk passes it on to the parent file. 
\par \par Returns a pointer to the sub-chunked PACKFILE, or NULL if there was some 
error (eg. you are using a custom PACKFILE vtable). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b PACKFILE *{\xe\v pack_fclose_chunk}pack_fclose_chunk(PACKFILE *f);\par }
{\li400 Closes a sub-chunk of a file, previously obtained by calling 
pack_fopen_chunk(). 
\par \par Returns a pointer to the parent of the sub-chunk you just closed. Returns 
NULL if there was some error (eg. you tried to close a PACKFILE which 
wasn't sub-chunked). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b LZSS_PACK_DATA *{\xe\v create_lzss_pack_data}create_lzss_pack_data(void);\par }
{\li400 Creates an LZSS_PACK_DATA structure, which can be used for LZSS 
compression with PACKFILEs. 
\par \par Returns a pointer to the structure, or NULL if there was an error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v free_lzss_pack_data}free_lzss_pack_data(LZSS_PACK_DATA *dat);\par }
{\li400 Frees an LZSS_PACK_DATA structure created with create_lzss_pack_data(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v lzss_write}lzss_write(PACKFILE *file, LZSS_PACK_DATA *dat, int size, unsigned char *buf, int last);\par }
{\li400 Packs `size' bytes from `buf', using the pack information contained in 
`dat'. The compressed bytes will be stored in `file'. 
\par \par Returns 0 on success, or EOF if there was an error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b LZSS_UNPACK_DATA *{\xe\v create_lzss_unpack_data}create_lzss_unpack_data(void);\par }
{\li400 Creates an LZSS_UNPACK_DATA structure, which can be used for LZSS 
decompression reading PACKFILEs. 
\par \par Returns a pointer to the structure, or NULL if there was an error. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v free_lzss_unpack_data}free_lzss_unpack_data(LZSS_UNPACK_DATA *dat);\par }
{\li400 Frees an LZSS_UNPACK_DATA structure created with create_lzss_pack_data. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v lzss_read}lzss_read(PACKFILE *file, LZSS_UNPACK_DATA *dat, int s, unsigned char *buf);\par }
{\li400 Unpacks from `dat' into `buf', until either EOF is reached or `s' bytes 
have been extracted from `file'. 
\par \par Returns the number of bytes added to the buffer `buf'. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Datafile routines}Datafile routines\par }
Datafiles are created by the grabber utility (see grabber.txt for more 
information), and have a `.dat' extension. They can contain bitmaps, palettes, 
fonts, samples, MIDI music, FLI/FLC animations, and any other binary data that 
you import. You could distribute your bitmaps and samples in a myriad of 
separate files, but packing them in a few `.dat' binaries has a few 
advantages: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 On some platforms loading a single big datafile at once is faster than 
loading individual resources one by one. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Instead of several loops for your resources, you can write a single line of 
code with just a single point of failure to take care of. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 You can potentially reduce the size of your data by enabling compression 
on your datafiles. Less download time for your end users, less wait during 
loading screens! 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 If you don't need to load the whole datafile at once, you can still enable 
individual file compression. It is slightly worse than global compression, 
but it is very fast with loading times because Allegro can easily seek 
inside the datafile to find a specific object. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Even without encryption, most end users of your application won't be able 
to look at or modify the resources for your game. A missing sound file or 
a modified bitmap could potentially crash the game if you haven't 
considered this in your loading code! 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 It looks much more professional and convenient to distribute levels! For 
example, if you found a bug in a level of your game, just distribute your 
new `level4.dat' and tell users to overwrite their old version. 
\par}\pard \li0 \par Allegro allows you to load datafiles once and forget about them. But if you 
have many levels it can be wise to load only the resources required for the 
current level. You can accomplish the later by separating levels in different 
datafiles, or using functions like load_datafile_object() to avoid loading 
everything at once. You can even read directly from a specific datafile object 
with the pack_fopen() function. 
\par \par On some platforms you can attach datafiles to your binary, potentially 
reducing your game distribution down to a single executable file. Try the 
example exexedat on your platform to see if this is possible. However, this 
is not recommended for big programs: a single update to your code or binary 
data would force end users to download again a potentially big file, no matter 
how small your change is. The same warning goes for the tools dat2s or dat2c, 
which convert datafiles into assembler and C code respectively, prepared to be 
included directly in your binary. 
\par \par Remember that with Allegro truecolor images can only be loaded after you have 
set a graphics mode. This is true for datafiles too. Load all your data after 
you have set the graphics mode, otherwise the pixel format (RGB or BGR) will 
not be known and the datafile may be converted wrongly. Oh, and read carefully 
the warning of fixup_datafile() if you plan on switching resolutions during 
runtime. 
\par \par Note: even though Allegro datafiles provide encryption, you should consider 
it weak, so don't plan on hiding there the plans for a Death Star or 
something. Determinate knowledgeable users will be able to rip your resources 
no matter how hard you try to hide them! Use the encryption only as a slight 
deterrent towards unwanted tampering of your data. How to crack an encrypted 
datafile is left as an exercise to the reader, though. 
\par \par Using datafiles once they are loaded is quite simple: you access the elements 
of the DATAFILE as a normal array. Read below the section "Using datafiles" 
below for several examples on how to access their data. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b DATAFILE *{\xe\v load_datafile}load_datafile(const char *filename);\par }
{\li400 Loads a datafile into memory in one go. If the datafile has been encrypted, 
you must first call packfile_password() to set the appropriate key. If the 
datafile contains truecolor graphics, you must set the video mode or call 
set_color_conversion() before loading it. Example: 
\par {\s1 \f1\fs18 
\par       /* Load the resources for our game. */
\par       DATAFILE *dat = load_datafile("game.dat");
\par       if (!dat)
\par          abort_on_error("Couldn't load sound resources!");
\par       /* Use resources. */
\par       ...
\par       /* Destroy them when we don't need them any more. */
\par       unload_datafile(dat);\par}
\par Returns a pointer to the DATAFILE, or NULL on error. Remember to free this 
DATAFILE later to avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b DATAFILE *{\xe\v load_datafile_callback}load_datafile_callback(const char *filename, void (*callback)(DATAFILE *d));\par }
{\li400 Loads a datafile into memory, calling the specified hook function once for 
each object in the file, passing it a pointer to the object just read. You 
can use this to implement very simple loading screens where every time the 
hook is called, the screen is updated to let the user know your program is 
still loading from disk: 
\par {\s1 \f1\fs18 
\par       void load_callback(DATAFILE *dat_obj)
\par       \{
\par          static const char indicator[] = "-\\\\|/-.oOXOo.";
\par          static int current = 0;
\par           
\par          /* Show a different character every time. */
\par          textprintf_ex(screen, font, 0, 0, makecol(0, 0, 0),
\par                        makecol(255, 255, 255), "%c Loading %c",
\par                        indicator[current], indicator[current]);
\par          /* Increase index and check if we need to reset it. */
\par          current++;
\par          if (!indicator[current])
\par             current = 0;
\par       \}
\par          ...
\par          dat = load_datafile_callback("data.dat", load_callback);\par}
\par Returns a pointer to the DATAFILE or NULL on error. Remember to free this 
DATAFILE later to avoid memory leaks. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v unload_datafile}unload_datafile(DATAFILE *dat);\par }
{\li400 Frees all the objects in a datafile. Use this to avoid memory leaks in 
your program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b DATAFILE *{\xe\v load_datafile_object}load_datafile_object(const char *filename,  const char *objectname);\par }
{\li400 Loads a specific object from a datafile. This won't work if you strip the 
object names from the file, and it will be very slow if you save the file 
with global compression. Example: 
\par {\s1 \f1\fs18 
\par       /* Load only the music from the datafile. */
\par       music_object = load_datafile_object("datafile.dat",
\par                                           "MUSIC");
\par       /* Play it and wait a moment for it. */
\par       play_midi(music_object->dat);
\par       ...
\par       /* Destroy unneeded music. */
\par       unload_datafile_object(music_object);\par}
\par Returns a pointer to a single DATAFILE element whose `dat' member points to 
the object, or NULL if there was an error or there was no object with the 
requested name. Remember to free this DATAFILE later to avoid memory leaks, 
but use the correct unloading function! 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v unload_datafile_object}unload_datafile_object(DATAFILE *dat);\par }
{\li400 Frees an object previously loaded by load_datafile_object(). Use this to 
avoid memory leaks in your program. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b DATAFILE *{\xe\v find_datafile_object}find_datafile_object(const DATAFILE *dat, const char *objectname);\par }
{\li400 Searches an already loaded datafile for an object with the specified 
name. In the name you can use `/' and `#' separators for nested datafile 
paths. Example: 
\par {\s1 \f1\fs18 
\par       char level_name[10];
\par       DATAFILE *dat, *level;
\par       ...
\par       uszprintf(level_name, sizeof(buffer),
\par                 "LEVEL_%02d", level_number);
\par       level = find_datafile_object(dat, level_name);
\par       if (!level)
\par          abort_on_error("That level doesn't exist!");\par}
\par Returns a pointer to a single DATAFILE element whose `dat' member points to 
the object, or NULL if the object could not be found. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b DATAFILE_INDEX *{\xe\v create_datafile_index}create_datafile_index(const char *filename);\par }
{\li400 Creates an index for a datafile, to speed up loading single objects out of 
it. This is mostly useful for big datafiles, which you don't want to load as 
a whole. The index will store the offset of all objects inside the datafile, 
and then you can load it quickly with "load_datafile_object_indexed" later. 
Use destroy_datafile_index to free the memory used by it again. 
\par \par Note: If the datafile uses global compression, there is no performance gain 
from using an index, because seeking to the offset still requires to 
uncompress the whole datafile up to that offset. 
Example: 
\par {\s1 \f1\fs18 
\par    DATAFILE_INDEX *index = create_datafile_index("huge.dat");
\par    DATAFILE *object = load_datafile_object_indexed(index, 1234);
\par    ...
\par    unload_datafile_object(object);
\par    destroy_datafile_index(index);\par}
\par A pointer value which you can pass to load_datafile_object_indexed. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b DATAFILE *{\xe\v load_datafile_object_indexed}load_datafile_object_indexed(const DATAFILE_INDEX *index, int item)\par }
{\li400 This loads a single object, using the index created previously with 
create_datafile_index. See create_datafile_index for an example. 
\par \par Returns a pointer to a single DATAFILE element whose "dat" member points to 
the object, or NULL if the object could not be loaded. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v destroy_datafile_index}destroy_datafile_index(DATAFILE_INDEX *index)\par }
{\li400 This function frees the memory used by a datafile index created with 
create_datafile_index earlier. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b const char *{\xe\v get_datafile_property}get_datafile_property(const DATAFILE *dat, int type);\par }
{\li400 Finds the property type of a DATAFILE object. The type parameter must be a 
value created with the DAT_ID() macro. Example: 
\par {\s1 \f1\fs18 
\par       const char *name;
\par       ...
\par       name = get_datafile_property(game_data,
\par                                    DAT_ID('N','A','M','E'));
\par       if (name == empty_string)
\par          abort_on_error("Object doesn't have a name!");\par}
\par Returns a pointer to the text string for the object, or a pointer to the 
variable empty_string if the property isn't present. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v register_datafile_object}register_datafile_object(int id, void *(*load)(PACKFILE *f, long size), void (*destroy)(void *data));\par }
{\li400 Used to add custom object types, specifying functions to load and destroy 
objects of this type. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v fixup_datafile}fixup_datafile(DATAFILE *data);\par }
{\li400 If you are using compiled datafiles (produced by the dat2s and dat2c 
utilities) on a platform that doesn't support constructors (currently any 
non GCC-based platform), or if the datafiles contain truecolor images, you 
must call this function once after your set the video mode that you will 
be using. This will ensure the datafiles are properly initialised in the 
first case and convert the color values into the appropriate format in 
the second case. It handles flipping between RGB and BGR formats, and 
converting between different color depths whenever that can be done 
without changing the size of the image (ie. changing 15<->16-bit 
hicolor for both bitmaps and RLE sprites, and 24<->32-bit truecolor 
for RLE sprites). 
\par \par Note that you can only call this once and expect it to work correctly, 
because after the call the DATAFILE you fixed up is permanently converted 
to whatever is the current component ordering for your screen mode. If you 
call fixup_datafile again, the function assumes you have a freshly loaded 
datafile. It cannot "undo" the previous conversion. 
\par \par If your program supports changing resolution and/or color depth during 
runtime, you have two choices: either call fixup_datafile() just once and 
hope that the component ordering and bit depth doesn't change when the 
screen mode changes (unlikely). Or, you can reload your datafiles when the 
screen mode changes. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Macro {\xe\v DAT_ID}DAT_ID(a, b, c, d);\par }
{\li400 Every object or property in a datafile is identified by a 4 letter ID, 
which can be created with this macro. For example, to access the NAME 
property of a datafile object, you could use: 
\par {\s1 \f1\fs18 
\par       get_datafile_property(datob, DAT_ID('N','A','M','E'));
\par \par}}\par \par \par \par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v Using datafiles}
\par \par In order to access the contents of a datafile, you will need to know where 
each object is located. The easiest way to do this is by integer index, 
using an automatically generated header file. With the grabber, type a name 
into the "Header:" field, and the object indexes will be written to this 
file whenever the datafile is saved. With the dat utility, use the '-h' 
option, eg. "dat filename.dat -h filename.h". The header will define C 
preprocessor symbols for each object in the datafile, for example: 
\par {\s1 \f1\fs18 
\par    #define SOME_DATA                        0        /* DATA */
\par    #define SOME_MORE_DATA                   1        /* DATA */
\par }\par To prevent name conflicts, you can specify a prefix string for these 
definitions by typing it into the "Prefix:" field in the grabber or using 
the '-p' option to dat. 
\par \par To load a datafile into memory, call the function: 
\par {\s1 \f1\fs18 
\par    DATAFILE *load_datafile(char *filename);
\par }\par This will load the entire file, returning a pointer to it, or NULL on error. 
When the data is no longer required, the entire thing can be destroyed by 
calling: 
\par {\s1 \f1\fs18 
\par    void unload_datafile(DATAFILE *dat);
\par }\par When you load a datafile, you will obtain a pointer to an array of DATAFILE 
structures: 
\par {\s1 \f1\fs18 
\par    typedef struct DATAFILE
\par    \{
\par       void *dat;                    - pointer to the actual data
\par       int type;                     - object type ID
\par       long size;                    - size of the data, in bytes
\par       DATAFILE_PROPERTY *prop;      - list of object properties
\par    \} DATAFILE;\par}
\par The only really important piece of information here is the `dat' field, which 
points to the contents of the object. What type of data this is will depend 
on the type of object: for bitmaps it will be an Allegro BITMAP structure, 
for RLE sprites an RLE_SPRITE, for fonts a FONT structure, etc. If you are 
programming in C you can pass this pointer directly to the relevant Allegro 
library functions, but if you are using C++ you will need to cast it to the 
appropriate type to prevent the compiler giving a warning. 
\par \par For example, if you have a datafile called `myfile.dat', which contains a 
bitmap called COOL_PICTURE, and you have used it to produce a header called 
`myfile.h', you could display the bitmap with the code: 
\par {\s1 \f1\fs18 
\par    #include "myfile.h"
\par 
\par    void show_the_bitmap()
\par    \{
\par       DATAFILE *dat;
\par       BITMAP *bmp;
\par 
\par       dat = load_datafile("myfile.dat");
\par       if (!dat) \{
\par          /* report an error! */
\par          return;
\par       \}
\par 
\par       bmp = (BITMAP *)dat[COOL_PICTURE].dat;
\par       blit(bmp, screen, 0, 0, 0, 0, bmp->w, bmp->h);
\par       unload_datafile(dat);
\par    \}\par}
\par If a datafile contains nested child datafiles, the header will prefix the 
names of objects in the sub-files with the name of their parent datafile. It 
will also define a count of the number of objects in the child file, which 
may be useful if for example the child datafile contains several bitmaps 
which form a 'run' animation, and you want your code to automatically 
adjust to the number of frames in the datafile. 
\par \par For example, the following datafile: 
\par {\s1 \f1\fs18 
\par    "FILE" - NESTED_FILE
\par             |- "BMP" - A_BITMAP
\par             |- "FONT" - A_FONT
\par    "DATA" - SOME_DATA
\par    "DATA" - SOME_MORE_DATA
\par }\par Will produce the header: 
\par {\s1 \f1\fs18 
\par    #define NESTED_FILE                      0        /* FILE */
\par 
\par    #define NESTED_FILE_A_BITMAP             0        /* BMP  */
\par    #define NESTED_FILE_A_FONT               1        /* FONT */
\par    #define NESTED_FILE_COUNT                2
\par 
\par    #define SOME_DATA                        1        /* DATA */
\par    #define SOME_MORE_DATA                   2        /* DATA */
\par }\par The main datafile contains three objects (NESTED_FILE, SOME_DATA, and 
SOME_MORE_DATA) with consecutive indexes, while the child datafile contains 
the two objects A_BITMAP and A_FONT. To access these objects you need to 
reference both the parent and child datafiles, eg: 
\par {\s1 \f1\fs18 
\par    DATAFILE *dat = load_datafile("whatever.dat");
\par    DATAFILE *nested = (DATAFILE *)dat[NESTED_FILE].dat;
\par    FONT *thefont = (FONT *)nested[NESTED_FILE_A_FONT].dat;
\par }\par If you need to access object property strings from within your program, you 
can use the function: 
\par {\s1 \f1\fs18 
\par    char *get_datafile_property(DATAFILE *dat, int type);
\par }\par This will return a pointer to the property string if it can be found, and an 
empty string (not null!) if it does not exist. One possible use of this 
function is to locate objects by name, rather than using the indexes from a 
header file. The datafile array is ended by an object of type DAT_END, so to 
search the datafile dat for the object "my_object" you could use the code: 
\par {\s1 \f1\fs18 
\par    const int name_type = DAT_ID('N','A','M','E');
\par    for (i=0; dat[i].type != DAT_END; i++) \{
\par       if (stricmp(get_datafile_property(dat+i, name_type),
\par                   "my_object") == 0) \{
\par          /* found the object at index i */
\par       \}
\par    \}
\par    /* not found... */
\par }\par If you prefer to access objects by name rather than index number, you can 
use the function: 
\par {\s1 \f1\fs18 
\par    DATAFILE *find_datafile_object(DATAFILE *dat, char *objectname);
\par }\par This will search an already loaded datafile for an object with the specified 
name, returning a pointer to it, or NULL if the object cannot be found. It 
understands '/' and '#' separators for nested datafile paths. 
\par \par It is also possible to selectively load individual objects from a datafile, 
with the function: 
\par {\s1 \f1\fs18 
\par    DATAFILE *load_datafile_object(char *filename, char *objectname);
\par }\par This searches the datafile for an object with the specified name, so 
obviously it won't work if you strip the name properties out of the file. 
Because this function needs to seek through the data, it will be extremely 
slow if you have saved the file with global compression. If you are planning 
to load objects individually, you should save the file uncompressed or with 
individual compression per-object. Because the returned datafile points to a 
single object rather than an array of objects, you should access it with the 
syntax datafile->dat, rather than datafile[index].dat, and when you are done 
you should free the object with the function: 
\par {\s1 \f1\fs18 
\par    void unload_datafile_object(DATAFILE *dat);
\par }\par Example: 
\par {\s1 \f1\fs18 
\par    music_object = load_datafile_object("datafile.dat", "MUSIC");
\par    play_midi(music_object->dat);
\par    ...
\par    unload_datafile_object(music_object);
\par }\par Alternatively, the packfile functions can open and read directly from the 
contents of a datafile object. You do this by calling pack_fopen() with a 
fake filename in the form "filename.dat#object_name". The contents of the 
object can then be read in an identical way to a normal disk file, so any of 
the file access functions in Allegro (eg. load_pcx() and set_config_file()) 
can be used to read from datafile objects. Note that you can't write to 
datafiles in this way: the fake file is read only. Also, you should save the 
file uncompressed or with per-object compression if you are planning on 
using this feature. Finally, be aware that the special Allegro object types 
aren't the same format as the files you import the data from, so if for 
example you want to use load_pcx to read an image from a datafile, you 
should import it as a binary data chunk rather than as a BITMAP object. 
\par \par If you have appended a datafile to the end of your executable with the 
exedat utility, use load_datafile("#") to read the entire thing into memory, 
load_datafile_object("#", "object_name") to load a specific object, and 
pack_fopen("#object_name", F_READ) to read one of the objects directly with 
your own code. Note that unless you use the previous functions to load the 
appended data, the OS will not load it into memory just because you are 
running the program, so you shouldn't have problems attaching datafiles to 
your binary larger than the available system memory. 
\par \par By default, all graphic objects loaded from a datafile will be converted 
into the current color depth. This conversion may be both lossy and very 
slow, particularly when reducing from truecolor to 256 color formats, so you 
may wish to disable it by calling set_color_conversion(COLORCONV_NONE) or 
set_color_conversion(COLORCONV_PARTIAL) before your call to load_datafile(). 
\par \par \par \par \par \par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v Custom datafile objects}
\par \par Some of the objects in a datafile, for example palettes and FLI animations, 
are simply treated as blocks of binary data, but others are loaded into 
special formats such as bitmap structures or compiled sprites. It is 
possible to extend the datafile system to support your own custom object 
types, eg. map objects for a tile based engine, or level data for a platform 
game. Obviously the grabber has no way of understanding this data, but it 
will allow you to import binary data from external files, so you can grab 
information produced by your own utilities. If you are happy with the data 
being loaded as a simple binary block, that is all you need to do, but if 
you need to load it into a specific structure, read on... 
\par \par Your custom objects must be given a unique type ID, which is formed from 
four ASCII characters (by convention all uppercase A-Z). If you don't use 
all four characters, the string should be padded with spaces (ASCII 32). You 
should use this ID when creating the objects in the grabber (select 
New/Other and type in the ID string), and in your code you should define an 
identifier for the type, eg: 
\par {\s1 \f1\fs18 
\par    #define DAT_MAPDATA  DAT_ID('M','A','P','D')
\par }\par You then need to write functions for loading and destroying objects of this 
type, in the form: 
\par {\s1 \f1\fs18 
\par    void *load_mapdata(PACKFILE *f, long size)
\par    \{
\par       /* Allegro will call this function whenever an object of your custom 
\par        * type needs to be loaded from a datafile. It will be passed a 
\par        * pointer to the file from which the data is to be read, and the size 
\par        * of the object in bytes. It should return a pointer to the loaded 
\par        * data, which will be stored in the dat field of the datafile object 
\par        * structure, or NULL if an error occurs. The file will have been 
\par        * opened as a sub-chunk of the main datafile, so it is safe to read 
\par        * past the end of the object (if you attempt this, Allegro will 
\par        * return EOF), and it is also safe to return before reading all the 
\par        * data in the chunk (if you do this, Allegro will skip any unused 
\par        * bytes before starting to read the next object). You should _not_ 
\par        * close the file when you are done: this will be handled by the 
\par        * calling function. To clarify how all this works, here's an example 
\par        * implementation of a null-terminated string object:
\par        */
\par 
\par       #define MAX_LEN  256
\par 
\par       char buf[MAX_LEN];
\par       char *p;
\par       int i, c;
\par 
\par       for (i=0; i<;MAX_LEN-1; i++) \{
\par          if ((c = pack_getc(f)) == EOF)
\par             break;
\par 
\par          buf[i] = c;
\par       \}
\par 
\par       buf[i] = 0;
\par 
\par       p = malloc(i+1);
\par       strcpy(p, buf);
\par 
\par       return p;
\par    \}
\par 
\par    void destroy_mapdata(void *data)
\par    \{
\par       /* Allegro will call this function whenever an object of your custom 
\par        * type needs to be destroyed. It will be passed a pointer to the 
\par        * object (as returned by the load function), and should free whatever 
\par        * memory the object is using. For example, the simple string object 
\par        * returned by the above loader could be destroyed with the code:
\par        */
\par 
\par       if (data)
\par          free(data);
\par    \}
\par }\par Finally, before you load your datafile you must tell Allegro about the 
custom format, by calling: 
\par {\s1 \f1\fs18 
\par    register_datafile_object(DAT_MAPDATA, load_mapdata, destroy_mapdata);
\par }\par It is also possible to integrate support for custom object types directly 
into the grabber and dat utilities, by copying some special files into the 
tools/plugins directory. This can be used to add whole new object types and 
menu commands, or to provide additional import/export routines for the 
existing formats. See `tools/plugins/plugins.txt' for an overview of how to 
write your own grabber plugins. 
\par {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Fixed point math routines}Fixed point math routines\par }
Allegro provides some routines for working with fixed point numbers, and 
defines the type `fixed' to be a signed 32-bit integer. The high word is 
used for the integer part and the low word for the fraction, giving a range 
of -32768 to 32767 and an accuracy of about four or five decimal places. 
Fixed point numbers can be assigned, compared, added, subtracted, negated and 
shifted (for multiplying or dividing by powers of two) using the normal 
integer operators, but you should take care to use the appropriate conversion 
routines when mixing fixed point with integer or floating point values. 
Writing `fixed_point_1 + fixed_point_2' is OK, but `fixed_point + integer' is 
not. 
\par \par Unfortunately the only advantage of fixed point math routines is that you 
don't require a floating point coprocessor to use them. This was great in the 
time period of i386 and i486 machines, but stopped being so useful with the 
coming of the Pentium class of processors. From Pentium onwards, CPUs have 
increased their strength in floating point operations, equaling or even 
surpassing integer math performance. 
\par \par Depending on the type of operations your program may need, using floating 
point types may be faster than fixed types if you are targeting a specific 
machine class. Allegro comes with a test program in the `allegro/tests' 
directory. Its `Misc' menu contains a basic profile test which can give you 
an idea of the speed difference between fixed and float types for a few basic 
operations on your machine. However, don't forget to profile your program in 
real life conditions, tight loop benchmarks are after all artificial. 
\par \par Fixed point math is considered "add-on" material and is kept only for 
backwards compatibility. Whenever a future release of Allegro breaks backwards 
compatibility, fixed point math will likely be moved to a separate add-on 
package for the very few users who still find it convenient and useful, and 
Allegro functions using fixed point math will use other types. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v itofix}itofix(int x);\par }
{\li400 Converts an integer to fixed point. This is the same thing as x<<16. 
Remember that overflows (trying to convert an integer greater than 32767) 
and underflows (trying to convert an integer lesser than -32768) are not 
detected even in debug builds! The values simply "wrap around". Example: 
\par {\s1 \f1\fs18 
\par       fixed number;
\par       /* This conversion is OK. */
\par       number = itofix(100);
\par       ASSERT(fixtoi(number) == 100);
\par       number = itofix(64000);
\par       /* This check will fail in debug builds. */
\par       ASSERT(fixtoi(number) == 64000);\par}
\par Returns the value of the integer converted to fixed point ignoring 
overflows. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v fixtoi}fixtoi(fixed x);\par }
{\li400 Converts fixed point to integer, rounding as required to the nearest 
integer. Example: 
\par {\s1 \f1\fs18 
\par       int result;
\par       /* This will put 33 into `result'. */
\par       result = fixtoi(itofix(100) / 3);
\par       /* But this will round up to 17. */
\par       result = fixtoi(itofix(100) / 6);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v fixfloor}fixfloor(fixed x);\par }
{\li400 Returns the greatest integer not greater than x. That is, it rounds 
towards negative infinity. Example: 
\par {\s1 \f1\fs18 
\par       int result;
\par       /* This will put 33 into `result'. */
\par       result = fixfloor(itofix(100) / 3);
\par       /* And this will round down to 16. */
\par       result = fixfloor(itofix(100) / 6);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v fixceil}fixceil(fixed x);\par }
{\li400 Returns the smallest integer not less than x. That is, it rounds towards 
positive infinity. Example: 
\par {\s1 \f1\fs18 
\par       int result;
\par       /* This will put 34 into `result'. */
\par       result = fixceil(itofix(100) / 3);
\par       /* This will round up to 17. */
\par       result = fixceil(itofix(100) / 6);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v ftofix}ftofix(double x);\par }
{\li400 Converts a floating point value to fixed point. Unlike itofix(), this 
function clamps values which could overflow the type conversion, setting 
`errno' to ERANGE in the process if this happens. Example: 
\par {\s1 \f1\fs18 
\par       fixed number;
\par       number = itofix(-40000);
\par       ASSERT(fixfloor(number) == -32768);
\par       number = itofix(64000);
\par       ASSERT(fixfloor(number) == 32767);
\par       ASSERT(!errno); /* This will fail. */\par}
\par Returns the value of the floating point value converted to fixed point 
clamping overflows (and setting `errno'). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b double {\xe\v fixtof}fixtof(fixed x);\par }
{\li400 Converts fixed point to floating point. Example: 
\par {\s1 \f1\fs18 
\par       float result;
\par       
\par       /* This will put 33.33333 into `result'. */
\par       result = fixtof(itofix(100) / 3);
\par       /* This will put 16.66666 into `result'. */
\par       result = fixtof(itofix(100) / 6);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v fixmul}fixmul(fixed x, fixed y);\par }
{\li400 A fixed point value can be multiplied or divided by an integer with the 
normal `*' and `/' operators. To multiply two fixed point values, though, 
you must use this function. 
\par \par If an overflow occurs, `errno' will be set and the maximum possible value 
will be returned, but `errno' is not cleared if the operation is 
successful. This means that if you are going to test for overflow you 
should set `errno=0' before calling fixmul(). Example: 
\par {\s1 \f1\fs18 
\par       fixed result;
\par 
\par       /* This will put 30000 into `result'. */
\par       result = fixmul(itofix(10), itofix(3000));
\par       /* But this overflows, and sets `errno'. */
\par       result = fixmul(itofix(100), itofix(3000));
\par       ASSERT(!errno);\par}
\par Returns the clamped result of multiplying `x' by `y', setting `errno' to 
ERANGE if there was an overflow. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v fixdiv}fixdiv(fixed x, fixed y);\par }
{\li400 A fixed point value can be divided by an integer with the normal `/' 
operator. To divide two fixed point values, though, you must use this 
function. If a division by zero occurs, `errno' will be set and the 
maximum possible value will be returned, but `errno' is not cleared if the 
operation is successful. This means that if you are going to test for 
division by zero you should set `errno=0' before calling fixdiv(). Example: 
\par {\s1 \f1\fs18 
\par       fixed result;
\par       /* This will put 0.06060 `result'. */
\par       result = fixdiv(itofix(2), itofix(33));
\par       /* This will put 0 into `result'. */
\par       result = fixdiv(0, itofix(-30));
\par       /* Sets `errno' and puts -32768 into `result'. */
\par       result = fixdiv(itofix(-100), itofix(0));
\par       ASSERT(!errno); /* This will fail. */\par}
\par Returns the result of dividing `x' by `y'. If `y' is zero, returns the 
maximum possible fixed point value and sets `errno' to ERANGE. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v fixadd}fixadd(fixed x, fixed y);\par }
{\li400 Although fixed point numbers can be added with the normal '+' integer 
operator, that doesn't provide any protection against overflow. If overflow 
is a problem, you should use this function instead. It is slower than using 
integer operators, but if an overflow occurs it will set `errno' and clamp 
the result, rather than just letting it wrap. Example: 
\par {\s1 \f1\fs18 
\par       fixed result;
\par       /* This will put 5035 into `result'. */
\par       result = fixadd(itofix(5000), itofix(35));
\par       /* Sets `errno' and puts -32768 into `result'. */
\par       result = fixadd(itofix(-31000), itofix(-3000));
\par       ASSERT(!errno); /* This will fail. */\par}
\par Returns the clamped result of adding `x' to `y', setting `errno' to ERANGE 
if there was an overflow. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v fixsub}fixsub(fixed x, fixed y);\par }
{\li400 Although fixed point numbers can be subtracted with the normal '-' integer 
operator, that doesn't provide any protection against overflow. If overflow 
is a problem, you should use this function instead. It is slower than using 
integer operators, but if an overflow occurs it will set `errno' and clamp 
the result, rather than just letting it wrap. Example: 
\par {\s1 \f1\fs18 
\par       fixed result;
\par       /* This will put 4965 into `result'. */
\par       result = fixsub(itofix(5000), itofix(35));
\par       /* Sets `errno' and puts -32768 into `result'. */
\par       result = fixsub(itofix(-31000), itofix(3000));
\par       ASSERT(!errno); /* This will fail. */\par}
\par Returns the clamped result of subtracting `y' from `x', setting `errno' to 
ERANGE if there was an overflow. 
\par}\par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v Fixed point trig}
The fixed point square root, sin, cos, tan, inverse sin, and inverse cos 
functions are implemented using lookup tables, which are very fast but not 
particularly accurate. At the moment the inverse tan uses an iterative 
search on the tan table, so it is a lot slower than the others. Note that on 
machines with very good floating point processors using these functions could 
be slower in real life code due to cache misses: it may be faster to wait 
a few extra cycles for a floating point sine result rather than wait for the 
CPU to fetch the precalculated table from main memory. Always profile your 
code. 
\par \par Angles are represented in a binary format with 256 equal to a full circle, 
64 being a right angle and so on. This has the advantage that a simple 
bitwise 'and' can be used to keep the angle within the range zero to a full 
circle, eliminating all those tiresome 'if (angle >= 360)' checks. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b extern const fixed {\xe\v fixtorad_r}fixtorad_r;\par }
{\li400 This constant gives a ratio which can be used to convert a fixed point 
number in binary angle format to a fixed point number in radians. Example: 
\par {\s1 \f1\fs18 
\par       fixed rad_angle, binary_angle;
\par       /* Set the binary angle to 90 degrees. */
\par       binary_angle = 64;
\par       /* Now convert to radians (about 1.57). */
\par       rad_angle = fixmul(binary_angle, fixtorad_r);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b extern const fixed {\xe\v radtofix_r}radtofix_r;\par }
{\li400 This constant gives a ratio which can be used to convert a fixed point 
number in radians to a fixed point number in binary angle format. Example: 
\par {\s1 \f1\fs18 
\par       fixed rad_angle, binary_angle;
\par       ...
\par       binary_angle = fixmul(rad_angle, radtofix_r);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v fixsin}fixsin(fixed x);\par }
{\li400 This function finds the sine of a value using a lookup table. The input 
value must be a fixed point binary angle. Example: 
\par {\s1 \f1\fs18 
\par       fixed angle;
\par       int result;
\par 
\par       /* Set the binary angle to 90 degrees. */
\par       angle = itofix(64);
\par       /* The sine of 90 degrees is one. */
\par       result = fixtoi(fixsin(angle));
\par       ASSERT(result == 1);\par}
\par Returns the sine of a fixed point binary format angle. The return value 
will be in radians. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v fixcos}fixcos(fixed x);\par }
{\li400 This function finds the cosine of a value using a lookup table. The input 
value must be a fixed point binary angle. Example: 
\par {\s1 \f1\fs18 
\par       fixed angle;
\par       float result;
\par 
\par       /* Set the binary angle to 45 degrees. */
\par       angle = itofix(32);
\par       /* The cosine of 45 degrees is about 0.7071. */
\par       result = fixtof(fixcos(angle));
\par       ASSERT(result > 0.7 && result < 0.71);\par}
\par Returns the cosine of a fixed point binary format angle. The return value 
will be in radians. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v fixtan}fixtan(fixed x);\par }
{\li400 This function finds the tangent of a value using a lookup table. The input 
value must be a fixed point binary angle. Example: 
\par {\s1 \f1\fs18 
\par       fixed angle, res_a, res_b;
\par       float dif;
\par       
\par       angle = itofix(37);
\par       /* Prove that tan(angle) == sin(angle) / cos(angle). */
\par       res_a = fixdiv(fixsin(angle), fixcos(angle));
\par       res_b = fixtan(angle);
\par       dif = fixtof(fixsub(res_a, res_b));
\par       allegro_message("Precision error: %f\\n", dif);\par}
\par Returns the tangent of a fixed point binary format angle. The return value 
will be in radians. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v fixasin}fixasin(fixed x);\par }
{\li400 This function finds the inverse sine of a value using a lookup table. The 
input value must be a fixed point value. The inverse sine is defined only 
in the domain from `-1' to `1'. Outside of this input range, the function 
will set `errno' to EDOM and return zero. Example: 
\par {\s1 \f1\fs18 
\par       float angle;
\par       fixed val;
\par 
\par       /* Sets `val' to a right binary angle (`64'). */
\par       val = fixasin(itofix(1));
\par       /* Sets `angle' to 0.2405. */
\par       angle = fixtof(fixmul(fixasin(ftofix(0.238)), fixtorad_r));
\par       /* This will trigger the assert. */
\par       val = fixasin(ftofix(-1.09));
\par       ASSERT(!errno);\par}
\par Returns the inverse sine of a fixed point value, measured as fixed point 
binary format angle, or zero if the input was out of the range. All return 
values of this function will be in the range `-64' to `64'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v fixacos}fixacos(fixed x);\par }
{\li400 This function finds the inverse cosine of a value using a lookup table. The 
input value must be a fixed point radian. The inverse cosine is defined 
only in the domain from `-1' to `1'. Outside of this input range, the 
function will set `errno' to EDOM and return zero. Example: 
\par {\s1 \f1\fs18 
\par       fixed result;
\par 
\par       /* Sets `result' to binary angle 128. */
\par       result = fixacos(itofix(-1));\par}
\par Returns the inverse sine of a fixed point value, measured as fixed point 
binary format angle, or zero if the input was out of range. All return 
values of this function will be in the range `0' to `128'. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v fixatan}fixatan(fixed x);\par }
{\li400 This function finds the inverse tangent of a value using a lookup table. 
The input value must be a fixed point radian. The inverse tangent is the 
value whose tangent is `x'. Example: 
\par {\s1 \f1\fs18 
\par       fixed result;
\par 
\par       /* Sets `result' to binary angle 13. */
\par       result = fixatan(ftofix(0.326));\par}
\par Returns the inverse tangent of a fixed point value, measured as a fixed 
point binary format angle. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v fixatan2}fixatan2(fixed y, fixed x);\par }
{\li400 This is a fixed point version of the libc atan2() routine. It computes the 
arc tangent of `y / x', but the signs of both arguments are used to 
determine the quadrant of the result, and `x' is permitted to be zero. This 
function is useful to convert Cartesian coordinates to polar coordinates. 
Example: 
\par {\s1 \f1\fs18 
\par       fixed result;
\par       
\par       /* Sets `result' to binary angle 64. */
\par       result = fixatan2(itofix(1), 0);
\par       /* Sets `result' to binary angle -109. */
\par       result = fixatan2(itofix(-1), itofix(-2));
\par       /* Fails the assert. */
\par       result = fixatan2(0, 0);
\par       ASSERT(!errno);\par}
\par Returns the arc tangent of `y / x' in fixed point binary format angle, 
from `-128' to `128'. If both `x' and `y' are zero, returns zero and sets 
`errno' to EDOM. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v fixsqrt}fixsqrt(fixed x);\par }
{\li400 This finds out the non negative square root of `x'. If `x' is negative, 
`errno' is set to EDOM and the function returns zero. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b fixed {\xe\v fixhypot}fixhypot(fixed x, fixed y);\par }
{\li400 Fixed point hypotenuse (returns the square root of `x*x + y*y'). This 
should be better than calculating the formula yourself manually, since 
the error is much smaller. 
\par}\par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v Fix class}
If you are programming in C++ you can ignore all the above and use the fix 
class instead, which overloads a lot of operators to provide automatic 
conversion to and from integer and floating point values, and calls the 
above routines as they are required. You should not mix the fix class with 
the fixed typedef though, because the compiler will mistake the fixed values 
for regular integers and insert unnecessary conversions. For example, if x 
is an object of class fix, calling fixsqrt(x) will return the wrong result. 
You should use the overloaded sqrt(x) or x.sqrt() instead. 
\par \par On top of that, the Fix class may be slower than using directly the C 
functions because of implicit internal conversions from one type to another 
which you otherwise could avoid or minimise. Finally, this is the only bit 
of C++ in the whole Allegro library, and the developers are certainly going 
to move it into add-on space in the next version of Allegro which breaks 
source backwards compatibility. 
\par {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v 3D math routines}3D math routines\par }
Allegro contains some 3d helper functions for manipulating vectors, 
constructing and using transformation matrices, and doing perspective 
projections from 3d space onto the screen. It is not, and never will be, a 
fully fledged 3d library (the goal is to supply generic support routines, 
not shrink-wrapped graphics code :-) but these functions may be useful for 
developing your own 3d code. 
\par \par Allegro uses a right-handed coordinate system, i.e. if you point the thumb 
of your right hand along the x axis, and the index finger along the y axis, 
your middle finger points in the direction of the z axis. 
\par \par Allegro's world coordinate system typically has the positive x axis right, 
the positive y axis up, and the positive z axis out of the screen.  What 
all this means is this: Assume, the viewer is located at the origin (0/0/0) 
in world space, looks along the negative z axis (0/0/-1), and is oriented 
so up is along the positive y axis (0/1/0). Then something located at 
(100/200/-300) will be 100 to the right, 200 above, and 300 in front of the 
viewer. Just like in OpenGL. (Of course, both OpenGL and Allegro allow to 
use a different system.) Here's a short piece of code demonstrating the 
transformation pipeline of a point from world space to the screen. 
\par \par \par {\s1 \f1\fs18 
\par    /* First, set up the projection viewport. */
\par    set_projection_viewport (0, 0, SCREEN_W, SCREEN_H);
\par   
\par    /* Next, get a camera matrix, depending on the
\par     * current viewer position and orientation.
\par     */
\par    get_camera_matrix_f (&m,
\par       0, 0, 0,  /* Viewer position, in this case, 0/0/0. */
\par       0, 0, -1, /* Viewer direction, in this case along negative z. */
\par       0, 1, 0,  /* Up vector, in this case positive y. */
\par       32,       /* The FOV, here 45. */
\par       (float)SCREEN_W / (float)SCREEN_H)); /* Aspect ratio. */
\par   
\par    /* Applying the matrix transforms the point 100/200/-300
\par     * from world space into camera space. The transformation
\par     * moves and rotates the point so it is relative to the
\par     * camera, scales it according to the FOV and aspect
\par     * parameters, and also flips up and front direction -
\par     * ready to project the point to the viewport.
\par     */
\par    apply_matrix_f (&m, 100, 200, -300, &x, &y, &z);
\par   
\par    /* Finally, the point is projected from
\par     * camera space to the screen.
\par     */
\par    persp_project_f (cx, cy, cz, &sx, &sy);\par}
\par For more details, look at the function descriptions of 
set_projection_viewport(), get_camera_matrix(), and persp_project(), as well 
as the relevant example programs. 
\par \par All the 3d math functions are available in two versions: one which uses 
fixed point arithmetic, and another which uses floating point. The syntax 
for these is identical, but the floating point functions and structures are 
postfixed with '_f', eg. the fixed point function cross_product() has a 
floating point equivalent cross_product_f(). If you are programming in C++, 
Allegro also overloads these functions for use with the 'fix' class. 
\par \par 3d transformations are accomplished by the use of a modelling matrix. This 
is a 4x4 array of numbers that can be multiplied with a 3d point to produce 
a different 3d point. By putting the right values into the matrix, it can be 
made to do various operations like translation, rotation, and scaling. The 
clever bit is that you can multiply two matrices together to produce a third 
matrix, and this will have the same effect on points as applying the 
original two matrices one after the other. For example, if you have one 
matrix that rotates a point and another that shifts it sideways, you can 
combine them to produce a matrix that will do the rotation and the shift in 
a single step. You can build up extremely complex transformations in this 
way, while only ever having to multiply each point by a single matrix. 
\par \par Allegro actually cheats in the way it implements the matrix structure. 
Rotation and scaling of a 3d point can be done with a simple 3x3 matrix, but 
in order to translate it and project it onto the screen, the matrix must be 
extended to 4x4, and the point extended into 4d space by the addition of an 
extra coordinate, w=1. This is a bad thing in terms of efficiency, but 
fortunately an optimisation is possible. Given the 4x4 matrix: 
\par {\s1 \f1\fs18 
\par    ( a, b, c, d )
\par    ( e, f, g, h )
\par    ( i, j, k, l )
\par    ( m, n, o, p )
\par }\par a pattern can be observed in which parts of it do what. The top left 3x3 
grid implements rotation and scaling. The three values in the top right 
column (d, h, and l) implement translation, and as long as the matrix is 
only used for affine transformations, m, n and o will always be zero and p 
will always be 1. If you don't know what affine means, read Foley & Van 
Damme: basically it covers scaling, translation, and rotation, but not 
projection. Since Allegro uses a separate function for projection, the 
matrix functions only need to support affine transformations, which means 
that there is no need to store the bottom row of the matrix. Allegro 
implicitly assumes that it contains (0,0,0,1), and optimises the matrix 
manipulation functions accordingly. Read chapter "Structures and types 
defined by Allegro" for an internal view of the MATRIX/_f structures. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 extern MATRIX {\xe\v identity_matrix}identity_matrix;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 extern MATRIX_f {\xe\v identity_matrix_f}identity_matrix_f;\par }
{\li400 Global variables containing the 'do nothing' identity matrix. Multiplying 
by the identity matrix has no effect. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v get_translation_matrix}get_translation_matrix(MATRIX *m, fixed x, fixed y, fixed z);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v get_translation_matrix_f}get_translation_matrix_f(MATRIX_f *m, float x, float y, float z);\par }
{\li400 Constructs a translation matrix, storing it in m. When applied to the 
point (px, py, pz), this matrix will produce the point (px+x, py+y, 
pz+z). In other words, it moves things sideways. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v get_scaling_matrix}get_scaling_matrix(MATRIX *m, fixed x, fixed y, fixed z);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v get_scaling_matrix_f}get_scaling_matrix_f(MATRIX_f *m, float x, float y, float z);\par }
{\li400 Constructs a scaling matrix, storing it in m. When applied to the point 
(px, py, pz), this matrix will produce the point (px*x, py*y, pz*z). In 
other words, it stretches or shrinks things. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v get_x_rotate_matrix}get_x_rotate_matrix(MATRIX *m, fixed r);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v get_x_rotate_matrix_f}get_x_rotate_matrix_f(MATRIX_f *m, float r);\par }
{\li400 Construct X axis rotation matrices, storing them in m. When applied to a 
point, these matrices will rotate it about the X axis by the specified 
angle (given in binary, 256 degrees to a circle format). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v get_y_rotate_matrix}get_y_rotate_matrix(MATRIX *m, fixed r);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v get_y_rotate_matrix_f}get_y_rotate_matrix_f(MATRIX_f *m, float r);\par }
{\li400 Construct Y axis rotation matrices, storing them in m. When applied to a 
point, these matrices will rotate it about the Y axis by the specified 
angle (given in binary, 256 degrees to a circle format). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v get_z_rotate_matrix}get_z_rotate_matrix(MATRIX *m, fixed r);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v get_z_rotate_matrix_f}get_z_rotate_matrix_f(MATRIX_f *m, float r);\par }
{\li400 Construct Z axis rotation matrices, storing them in m. When applied to a 
point, these matrices will rotate it about the Z axis by the specified 
angle (given in binary, 256 degrees to a circle format). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v get_rotation_matrix}get_rotation_matrix(MATRIX *m, fixed x, fixed y, fixed z);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v get_rotation_matrix_f}get_rotation_matrix_f(MATRIX_f *m, float x, float y, float z);\par }
{\li400 Constructs a transformation matrix which will rotate points around all 
three axes by the specified amounts (given in binary, 256 degrees to a 
circle format). The direction of rotation can simply be found out with 
the right-hand rule: Point the dumb of your right hand towards the 
origin along the axis of rotation, and the fingers will curl in the 
positive direction of rotation. E.g. if you rotate around the y axis, 
and look at the scene from above, a positive angle will rotate in 
clockwise direction. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_align_matrix}get_align_matrix(MATRIX *m, fixed xfront, yfront, zfront,  fixed xup, fixed yup, fixed zup);\par }
{\li400 Rotates a matrix so that it is aligned along the specified coordinate 
vectors (they need not be normalized or perpendicular, but the up and 
front must not be equal). A front vector of 0,0,-1 and up vector of 0,1,0 
will return the identity matrix. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_align_matrix_f}get_align_matrix_f(MATRIX *m, float xfront, yfront, zfront,  float xup, yup, zup);\par }
{\li400 Floating point version of get_align_matrix(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v get_vector_rotation_matrix}get_vector_rotation_matrix(MATRIX *m, fixed x, y, z, fixed a);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v get_vector_rotation_matrix_f}get_vector_rotation_matrix_f(MATRIX_f *m, float x, y, z, float a);\par }
{\li400 Constructs a transformation matrix which will rotate points around the 
specified x,y,z vector by the specified angle (given in binary, 256 
degrees to a circle format). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_transformation_matrix}get_transformation_matrix(MATRIX *m, fixed scale, fixed xrot, yrot, zrot, x, y, z);\par }
{\li400 Constructs a transformation matrix which will rotate points around all 
three axes by the specified amounts (given in binary, 256 degrees to a 
circle format), scale the result by the specified amount (pass 1 for no 
change of scale), and then translate to the requested x, y, z position. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_transformation_matrix_f}get_transformation_matrix_f(MATRIX_f *m, float scale, float xrot, yrot, zrot, x, y, z);\par }
{\li400 Floating point version of get_transformation_matrix(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_camera_matrix}get_camera_matrix(MATRIX *m, fixed x, y, z, xfront, yfront, zfront, fixed xup, yup, zup, fov, aspect);\par }
{\li400 Constructs a camera matrix for translating world-space objects into a 
normalised view space, ready for the perspective projection. The x, y, 
and z parameters specify the camera position, xfront, yfront, and zfront 
are the 'in front' vector specifying which way the camera is facing 
(this can be any length: normalisation is not required), and xup, yup, 
and zup are the 'up' direction vector. 
\par \par The fov parameter specifies the field of view (ie. width of the camera 
focus) in binary, 256 degrees to the circle format. For typical 
projections, a field of view in the region 32-48 will work well. 64 
(90) applies no extra scaling - so something which is one unit away 
from the viewer will be directly scaled to the viewport. A bigger FOV 
moves you closer to the viewing plane, so more objects will appear. A 
smaller FOV moves you away from the viewing plane, which means you see a 
smaller part of the world. 
\par \par Finally, the aspect ratio is used to scale the Y dimensions of the image 
relative to the X axis, so you can use it to adjust the proportions of 
the output image (set it to 1 for no scaling - but keep in mind that the 
projection also performs scaling according to the viewport size). 
Typically, you will pass (float)w/(float)h, where w and h are the 
parameters you passed to set_projection_viewport. 
\par \par Note that versions prior to 4.1.0 multiplied this aspect ratio by 4/3. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_camera_matrix_f}get_camera_matrix_f(MATRIX_f *m, float x, y, z, xfront, yfront, zfront, float xup, yup, zup, fov, aspect);\par }
{\li400 Floating point version of get_camera_matrix(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v qtranslate_matrix}qtranslate_matrix(MATRIX *m, fixed x, fixed y, fixed z);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v qtranslate_matrix_f}qtranslate_matrix_f(MATRIX_f *m, float x, float y, float z);\par }
{\li400 Optimised routine for translating an already generated matrix: this 
simply adds in the translation offset, so there is no need to build two 
temporary matrices and then multiply them together. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v qscale_matrix}qscale_matrix(MATRIX *m, fixed scale);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v qscale_matrix_f}qscale_matrix_f(MATRIX_f *m, float scale);\par }
{\li400 Optimised routine for scaling an already generated matrix: this simply 
adds in the scale factor, so there is no need to build two temporary 
matrices and then multiply them together. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v matrix_mul}matrix_mul(const MATRIX *m1, const MATRIX *m2, MATRIX *out);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v matrix_mul_f}matrix_mul_f(const MATRIX_f *m1, const MATRIX_f *m2, MATRIX_f *out);\par }
{\li400 Multiplies two matrices, storing the result in out (this may be a 
duplicate of one of the input matrices, but it is faster when the inputs 
and output are all different). The resulting matrix will have the same 
effect as the combination of m1 and m2, ie. when applied to a point p, (p 
* out) = ((p * m1) * m2). Any number of transformations can be 
concatenated in this way. Note that matrix multiplication is not 
commutative, ie. matrix_mul(m1, m2) != matrix_mul(m2, m1). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 fixed {\xe\v vector_length}vector_length(fixed x, fixed y, fixed z);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 float {\xe\v vector_length_f}vector_length_f(float x, float y, float z);\par }
{\li400 Calculates the length of the vector (x, y, z), using that good 'ole 
Pythagoras theorem. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v normalize_vector}normalize_vector(fixed *x, fixed *y, fixed *z);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v normalize_vector_f}normalize_vector_f(float *x, float *y, float *z);\par }
{\li400 Converts the vector (*x, *y, *z) to a unit vector. This points in the 
same direction as the original vector, but has a length of one. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 fixed {\xe\v dot_product}dot_product(fixed x1, y1, z1, x2, y2, z2);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 float {\xe\v dot_product_f}dot_product_f(float x1, y1, z1, x2, y2, z2);\par }
{\li400 Calculates the dot product (x1, y1, z1) . (x2, y2, z2), returning the 
result. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v cross_product}cross_product(fixed x1, y1, z1, x2, y2, z2, *xout, *yout, *zout);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v cross_product_f}cross_product_f(float x1, y1, z1, x2, y2, z2, *xout, *yout, *zout);\par }
{\li400 Calculates the cross product (x1, y1, z1) x (x2, y2, z2), storing the 
result in (*xout, *yout, *zout). The cross product is perpendicular to 
both of the input vectors, so it can be used to generate polygon normals. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 fixed {\xe\v polygon_z_normal}polygon_z_normal(const V3D *v1, const V3D *v2, const V3D *v3);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 float {\xe\v polygon_z_normal_f}polygon_z_normal_f(const V3D_f *v1, const V3D_f *v2, const V3D_f *v3);\par }
{\li400 Finds the Z component of the normal vector to the specified three 
vertices (which must be part of a convex polygon). This is used mainly in 
back-face culling. The back-faces of closed polyhedra are never visible 
to the viewer, therefore they never need to be drawn. This can cull on 
average half the polygons from a scene. If the normal is negative the 
polygon can safely be culled. If it is zero, the polygon is perpendicular 
to the screen. 
\par \par However, this method of culling back-faces must only be used once the X and 
Y coordinates have been projected into screen space using persp_project() 
(or if an orthographic (isometric) projection is being used). Note that 
this function will fail if the three vertices are co-linear (they lie on 
the same line) in 3D space. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v apply_matrix}apply_matrix(const MATRIX *m, fixed x, y, z, *xout, *yout, *zout);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v apply_matrix_f}apply_matrix_f(const MATRIX_f *m, float x, y, z, *xout, *yout, *zout);\par }
{\li400 Multiplies the point (x, y, z) by the transformation matrix m, storing 
the result in (*xout, *yout, *zout). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_projection_viewport}set_projection_viewport(int x, int y, int w, int h);\par }
{\li400 Sets the viewport used to scale the output of the persp_project() 
function. Pass the dimensions of the screen area you want to draw onto, 
which will typically be 0, 0, SCREEN_W, and SCREEN_H. Also don't forget 
to pass an appropriate aspect ratio to get_camera_matrix later. The 
width and height you specify here will determine how big your viewport 
is in 3d space. So if an object in your 3D space is w units wide, it 
will fill the complete screen when you run into it (i.e., if it has a 
distance of 1.0 after the camera matrix was applied. The fov and 
aspect-ratio parameters to get_camera_matrix also apply some scaling 
though, so this isn't always completely true). If you pass -1/-1/2/2 as 
parameters, no extra scaling will be performed by the projection. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v persp_project}persp_project(fixed x, fixed y, fixed z, fixed *xout, fixed *yout);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v persp_project_f}persp_project_f(float x, float y, float z, float *xout, float *yout);\par }
{\li400 Projects the 3d point (x, y, z) into 2d screen space, storing the result 
in (*xout, *yout) and using the scaling parameters previously set by 
calling set_projection_viewport(). This function projects from the 
normalized viewing pyramid, which has a camera at the origin and facing 
along the positive z axis. The x axis runs left/right, y runs up/down, 
and z increases with depth into the screen. The camera has a 90 degree 
field of view, ie. points on the planes x=z and -x=z will map onto the 
left and right edges of the screen, and the planes y=z and -y=z map to 
the top and bottom of the screen. If you want a different field of view 
or camera location, you should transform all your objects with an 
appropriate viewing matrix, eg. to get the effect of panning the camera 
10 degrees to the left, rotate all your objects 10 degrees to the right. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Quaternion math routines}Quaternion math routines\par }
Quaternions are an alternate way to represent the rotation part of a 
transformation, and can be easier to manipulate than matrices. As with a 
matrix, you can encode a geometric transformations in one, concatenate 
several of them to merge multiple transformations, and apply them to a 
vector, but they can only store pure rotations. The big advantage is that 
you can accurately interpolate between two quaternions to get a part-way 
rotation, avoiding the gimbal problems of the more conventional Euler angle 
interpolation. 
\par \par Quaternions only have floating point versions, without any _f suffix. Other 
than that, most of the quaternion functions correspond with a matrix 
function that performs a similar operation. 
\par \par Quaternion means 'of four parts', and that's exactly what it is. Here is the 
structure: 
\par {\s1 \f1\fs18 
\par    typedef struct QUAT
\par    \{
\par       float w, x, y, z;
\par    \}
\par }\par You will have lots of fun figuring out what these numbers actually mean, but 
that is beyond the scope of this documentation. Quaternions do work -- trust 
me. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b extern QUAT {\xe\v identity_quat}identity_quat;\par }
{\li400 Global variable containing the 'do nothing' identity quaternion. 
Multiplying by the identity quaternion has no effect. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 void {\xe\v get_x_rotate_quat}get_x_rotate_quat(QUAT *q, float r);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 void {\xe\v get_y_rotate_quat}get_y_rotate_quat(QUAT *q, float r);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 void {\xe\v get_z_rotate_quat}get_z_rotate_quat(QUAT *q, float r);\par }
{\li400 Construct axis rotation quaternions, storing them in q. When applied to a 
point, these quaternions will rotate it about the relevant axis by the 
specified angle (given in binary, 256 degrees to a circle format). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_rotation_quat}get_rotation_quat(QUAT *q, float x, float y, float z);\par }
{\li400 Constructs a quaternion that will rotate points around all three axes by 
the specified amounts (given in binary, 256 degrees to a circle format). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v get_vector_rotation_quat}get_vector_rotation_quat(QUAT *q, float x, y, z, float a);\par }
{\li400 Constructs a quaternion that will rotate points around the specified 
x,y,z vector by the specified angle (given in binary, 256 degrees to a 
circle format). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v quat_to_matrix}quat_to_matrix(const QUAT *q, MATRIX_f *m);\par }
{\li400 Constructs a rotation matrix from a quaternion. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v matrix_to_quat}matrix_to_quat(const MATRIX_f *m, QUAT *q);\par }
{\li400 Constructs a quaternion from a rotation matrix. Translation is discarded 
during the conversion. Use get_align_matrix_f() if the matrix is not 
orthonormalized, because strange things may happen otherwise. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v quat_mul}quat_mul(const QUAT *p, const QUAT *q, QUAT *out);\par }
{\li400 Multiplies two quaternions, storing the result in out. The resulting 
quaternion will have the same effect as the combination of p and q, ie. 
when applied to a point, (point * out) = ((point * p) * q). Any number of 
rotations can be concatenated in this way. Note that quaternion 
multiplication is not commutative, ie. quat_mul(p, q) != quat_mul(q, p). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v apply_quat}apply_quat(const QUAT *q, float x, y, z, *xout, *yout, *zout);\par }
{\li400 Multiplies the point (x, y, z) by the quaternion q, storing the result in 
(*xout, *yout, *zout). This is quite a bit slower than apply_matrix_f(), 
so only use it to translate a few points. If you have many points, it is 
much more efficient to call quat_to_matrix() and then use 
apply_matrix_f(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v quat_interpolate}quat_interpolate(const QUAT *from, const QUAT *to, float t, QUAT *out);\par }
{\li400 Constructs a quaternion that represents a rotation between from and to. 
The argument t can be anything between 0 and 1 and represents where 
between from and to the result will be. 0 returns from, 1 returns to, and 
0.5 will return a rotation exactly in between. The result is copied to 
out. This function will create the short rotation (less than 180 degrees) 
between from and to. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v quat_slerp}quat_slerp(const QUAT *from, const QUAT *to, float t, QUAT *out, int how);\par }
{\li400 The same as quat_interpolate(), but allows more control over how the 
rotation is done. The how parameter can be any one of the values: 
\par {\s1 \f1\fs18 
\par       QUAT_SHORT  - like quat_interpolate(), use shortest path
\par       QUAT_LONG   - rotation will be greater than 180 degrees
\par       QUAT_CW     - rotate clockwise when viewed from above
\par       QUAT_CCW    - rotate counterclockwise when viewed from above
\par       QUAT_USER   - the quaternions are interpolated exactly as
\par                     given
\par \par}}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v GUI routines}GUI routines\par }
Allegro contains an object-oriented dialog manager, which was originally 
based on the Atari GEM system (form_do(), objc_draw(), etc: old ST 
programmers will know what we are talking about :-) You can use the GUI as-is 
to knock out simple interfaces for things like the test program and grabber 
utility, or you can use it as a basis for more complicated systems of your 
own. Allegro lets you define your own object types by writing new dialog 
procedures, so you can take complete control over the visual aspects of the 
interface while still using Allegro to handle input from the mouse, 
keyboard, joystick, etc. 
\par \par A GUI dialog is stored as an array of DIALOG objects, read chapter 
"Structures and types defined by Allegro" for an internal description of the 
DIALOG structure. The array should end with an object which has the proc 
pointer set to NULL. Each object has a flags field which may contain any 
combination of the bit flags: 
\par {\s1 \f1\fs18 
\par    D_EXIT          - this object should close the dialog when it is
\par                      clicked
\par    D_SELECTED      - this object is selected
\par    D_GOTFOCUS      - this object has got the input focus
\par    D_GOTMOUSE      - the mouse is currently on top of this object
\par    D_HIDDEN        - this object is hidden and inactive
\par    D_DISABLED      - this object is greyed-out and inactive
\par    D_DIRTY         - this object needs to be redrawn
\par    D_INTERNAL      - don't use this! It is for internal use by the
\par                      library...
\par    D_USER          - any powers of two above this are free for your
\par                      own use
\par }\par Each object is controlled by a dialog procedure, which is stored in the proc 
pointer. This will be called by the dialog manager whenever any action 
concerning the object is required, or you can call it directly with the 
object_message() function. The dialog procedure should follow the form: 
\par {\s1 \f1\fs18 
\par    int foo(int msg, DIALOG *d, int c);
\par }\par It will be passed a flag (msg) indicating what action it should perform, a 
pointer to the object concerned (d), and if msg is MSG_CHAR or MSG_XCHAR, 
the key that was pressed (c). Note that d is a pointer to a specific object, 
and not to the entire dialog. 
\par \par The dialog procedure should return one of the values: 
\par {\s1 \f1\fs18 
\par    D_O_K          - normal return status
\par    D_CLOSE        - tells the dialog manager to close the dialog
\par    D_REDRAW       - tells the dialog manager to redraw the entire
\par                     dialog
\par    D_REDRAWME     - tells the dialog manager to redraw the current
\par                     object
\par    D_WANTFOCUS    - requests that the input focus be given to this
\par                     object
\par    D_USED_CHAR    - MSG_CHAR and MSG_XCHAR return this if they used
\par                     the key
\par }\par Dialog procedures may be called with any of the messages: 
\par \par {\b MSG_START:\par}
Tells the object to initialise itself. The dialog manager sends this to 
all the objects in a dialog just before it displays the dialog. 
\par \par {\b MSG_END:\par}
Sent to all objects when closing a dialog, allowing them to perform 
whatever cleanup operations they require. 
\par \par {\b MSG_DRAW:\par}
Tells the object to draw itself onto the screen. The mouse pointer will 
be turned off when this message is sent, so the drawing code does not 
need to worry about it. 
\par \par {\b MSG_CLICK:\par}
Informs the object that a mouse button has been clicked while the mouse 
was on top of the object. Typically an object will perform its own mouse 
tracking as long as the button is held down, and only return from this 
message handler when it is released. 
\par \par If you process this message, use the functions gui_mouse_*() to read the 
state of the mouse. 
\par \par {\b MSG_DCLICK:\par}
Sent when the user double-clicks on an object. A MSG_CLICK will be sent 
when the button is first pressed, then MSG_DCLICK if it is released and 
pressed again within a short space of time. 
\par \par If you process this message, use the functions gui_mouse_*() to read the 
state of the mouse. 
\par \par {\b MSG_KEY:\par}
Sent when the keyboard shortcut for the object is pressed, or if enter, 
space, or a joystick button is pressed while it has the input focus. 
\par \par {\b MSG_CHAR:\par}
When a key is pressed, this message is sent to the object that has the 
input focus, with a readkey() format character code (ASCII value in the 
low byte, scancode in the high byte) as the c parameter. If the object 
deals with the keypress it should return D_USED_CHAR, otherwise it should 
return D_O_K to allow the default keyboard interface to operate. If you 
need to access Unicode character input, you should use MSG_UCHAR instead 
of MSG_CHAR. 
\par \par {\b MSG_UCHAR:\par}
If an object ignores the MSG_CHAR input, this message will be sent 
immediately after it, passed the full Unicode key value as the c 
parameter. This enables you to read character codes greater than 255, but 
cannot tell you anything about the scancode: if you need to know that, 
use MSG_CHAR instead. This handler should return D_USED_CHAR if it 
processed the input, or D_O_K otherwise. 
\par \par {\b MSG_XCHAR:\par}
When a key is pressed, Allegro will send a MSG_CHAR and MSG_UCHAR to the 
object with the input focus. If this object doesn't process the key (ie. 
it returns D_O_K rather than D_USED_CHAR), the dialog manager will look 
for an object with a matching keyboard shortcut in the key field, and 
send it a MSG_KEY. If this fails, it broadcasts a MSG_XCHAR to all 
objects in the dialog, allowing them to respond to special keypresses 
even when they don't have the input focus. Normally you should ignore 
this message (return D_O_K rather than D_USED_CHAR), in which case 
Allegro will perform default actions such as moving the focus in response 
to the arrow keys and closing the dialog if ESC is pressed. 
\par \par {\b MSG_WANTFOCUS:\par}
Queries whether an object is willing to accept the input focus. It should 
return D_WANTFOCUS if it does, or D_O_K if it isn't interested in getting 
user input. 
\par \par {\b MSG_GOTFOCUS:\par}
{\b MSG_LOSTFOCUS:\par}
Sent whenever an object gains or loses the input focus. These messages 
will always be followed by a MSG_DRAW, to let objects display themselves 
differently when they have the input focus. If you return D_WANTFOCUS in 
response to a MSG_LOSTFOCUS event, this will prevent your object from 
losing the focus when the mouse moves off it onto the screen background 
or some inert object, so it will only lose the input focus when some 
other object is ready to take over the focus (this trick is used by the 
d_edit_proc() object). 
\par \par {\b MSG_GOTMOUSE:\par}
{\b MSG_LOSTMOUSE:\par}
Sent when the mouse moves on top of or away from an object. Unlike the 
focus messages, these are not followed by a MSG_DRAW, so if the object is 
displayed differently when the mouse is on top of it, it is responsible 
for redrawing itself in response to these messages. 
\par \par {\b MSG_IDLE:\par}
Sent whenever the dialog manager has nothing better to do. 
\par \par {\b MSG_RADIO:\par}
Sent by radio button objects to deselect other buttons in the same group 
when they are clicked. The group number is passed in the c message 
parameter. 
\par \par {\b MSG_WHEEL:\par}
Sent to the focused object whenever the mouse wheel moves. The c message 
parameter contains the number of clicks. 
\par \par {\b MSG_LPRESS, MSG_MPRESS, MSG_RPRESS:\par}
Sent when the corresponding mouse button is pressed. 
\par \par {\b MSG_LRELEASE, MSG_MRELEASE, MSG_RRELEASE:\par}
Sent when the corresponding mouse button is released. 
\par \par {\b MSG_USER:\par}
The first free message value. Any numbers from here on (MSG_USER, 
MSG_USER+1, MSG_USER+2, ... MSG_USER+n) are free to use for whatever you 
like. 
\par \par Allegro provides several standard dialog procedures. You can use these as 
they are to provide simple user interface objects, or you can call them from 
within your own dialog procedures, resulting in a kind of OOP inheritance. 
For instance, you could make an object which calls d_button_proc to draw 
itself, but handles the click message in a different way, or an object which 
calls d_button_proc for everything except drawing itself, so it would behave 
like a normal button but could look completely different. 
\par \par Since the release of Allegro version 3.9.33 (CVS), some GUI objects and 
menus are being drawn differently unlike in previous Allegro versions. The 
changes are the following: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Shadows under d_shadow_box_proc and d_button_proc are always black. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 The most important (and immediately visible) change is, that some objects 
are being drawn smaller. The difference is exactly one pixel in both 
height and width, when comparing to previous versions. The reason is, 
that in previous versions these objects were too large on the screen - 
their size was d->w+1 and d->h+1 pixels (and not d->w and d->h, as it 
should be). This change affects the following objects : 
\par {\s1 \f1\fs18 \pard \li400 
\par       d_box_proc,
\par       d_shadow_box_proc,
\par       d_button_proc,
\par       d_check_proc,
\par       d_radio_proc,
\par       d_list_proc,
\par       d_text_list_proc and
\par       d_textbox_proc.
\par }\pard \li400 \par When you want to convert old dialogs to look equally when compiling with 
the new Allegro version, just increase the size of the mentioned objects 
by one pixel in both width and height fields. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 When a GUI menu item (not in a bar menu) has a child menu, there is a 
small arrow next to the child menu name, pointing to the right - so the 
user can immediately see that this menu item has a child menu - and 
there is no need to use such menu item names as for example "New...", 
to show that it has a child menu. The submenu will be drawn to the right 
of the parent menu, trying not to overlap it. 
\par}\pard \li0 \par \par \par \par Menus had been forgotten during the changes for 3.9.33 (CVS), so they were 
still drawn too large until version 4.1.0. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v d_clear_proc}d_clear_proc(int msg, DIALOG *d, int c);\par }
{\li400 This just clears the screen when it is drawn. Useful as the first object 
in a dialog. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 int {\xe\v d_box_proc}d_box_proc(int msg, DIALOG *d, int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 int {\xe\v d_shadow_box_proc}d_shadow_box_proc(int msg, DIALOG *d, int c);\par }
{\li400 These draw boxes onto the screen, with or without a shadow. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v d_bitmap_proc}d_bitmap_proc(int msg, DIALOG *d, int c);\par }
{\li400 This draws a bitmap onto the screen, which should be pointed to by the 
dp field. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 int {\xe\v d_text_proc}d_text_proc(int msg, DIALOG *d, int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 int {\xe\v d_ctext_proc}d_ctext_proc(int msg, DIALOG *d, int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 int {\xe\v d_rtext_proc}d_rtext_proc(int msg, DIALOG *d, int c);\par }
{\li400 These draw text onto the screen. The dp field should point to the string 
to display. d_ctext_proc() centers the string horizontally, and 
d_rtext_proc() right aligns it. Any '&' characters in the string will 
be replaced with lines underneath the following character, for displaying 
keyboard shortcuts (as in MS Windows). To display a single ampersand, put 
"&&". To draw the text in something other than the default font, set the 
dp2 field to point to your custom font data. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v d_button_proc}d_button_proc(int msg, DIALOG *d, int c);\par }
{\li400 A button object (the dp field points to the text string). This object can 
be selected by clicking on it with the mouse or by pressing its keyboard 
shortcut. If the D_EXIT flag is set, selecting it will close the dialog, 
otherwise it will toggle on and off. Like d_text_proc(), ampersands can 
be used to display the keyboard shortcut of the button. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v d_check_proc}d_check_proc(int msg, DIALOG *d, int c);\par }
{\li400 This is an example of how you can derive objects from other objects. Most 
of the functionality comes from d_button_proc(), but it displays itself 
as a check box. If the d1 field is non-zero, the text will be printed to 
the right of the check, otherwise it will be on the left. 
\par \par Note: the object width should allow space for the text as well as the 
check box (which is square, with sides equal to the object height). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v d_radio_proc}d_radio_proc(int msg, DIALOG *d, int c);\par }
{\li400 A radio button object. A dialog can contain any number of radio button 
groups: selecting a radio button causes other buttons within the same 
group to be deselected. The dp field points to the text string, d1 
specifies the group number, and d2 is the button style (0=circle, 
1=square). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v d_icon_proc}d_icon_proc(int msg, DIALOG *d, int c);\par }
{\li400 A bitmap button. The fg color is used for the dotted line showing focus, 
and the bg color for the shadow used to fill in the top and left sides of 
the button when "pressed". d1 is the "push depth", ie. the number of 
pixels the icon will be shifted to the right and down when selected 
(default 2) if there is no "selected" image. d2 is the distance by which 
the dotted line showing focus is indented (default 2). dp points to a 
bitmap for the icon, while dp2 and dp3 are the selected and disabled 
images respectively (optional, may be NULL). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v d_keyboard_proc}d_keyboard_proc(int msg, DIALOG *d, int c);\par }
{\li400 This is an invisible object for implementing keyboard shortcuts. You can 
put an ASCII code in the key field of the dialog object (a character such 
as 'a' to respond to a simple keypress, or a number 1-26 to respond to a 
control key a-z), or you can put a keyboard scancode in the d1 and/or d2 
fields. When one of these keys is pressed, the object will call the 
function pointed to by dp. This should return an int, which will be 
passed back to the dialog manager, so it can return D_O_K, D_REDRAW, 
D_CLOSE, etc. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v d_edit_proc}d_edit_proc(int msg, DIALOG *d, int c);\par }
{\li400 An editable text object (the dp field points to the string). When it has 
the input focus (obtained by clicking on it with the mouse), text can be 
typed into this object. The d1 field specifies the maximum number of 
characters that it will accept, and d2 is the text cursor position within 
the string. 
\par \par Note: dp must point to a buffer at least (d1 + 1) * 4 bytes long because, 
depending on the encoding format in use, a single character can occupy 
up to 4 bytes and room must be reserved for the terminating null character. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v d_list_proc}d_list_proc(int msg, DIALOG *d, int c);\par }
{\li400 A list box object. This will allow the user to scroll through a list of 
items and to select one by clicking or with the arrow keys. If the D_EXIT 
flag is set, double clicking on a list item will close the dialog. The 
index of the selected item is held in the d1 field, and d2 is used to 
store how far it has scrolled through the list. The dp field points to a 
function which will be called to obtain information about the contents of 
the list. This should follow the form: 
\par {\s1 \f1\fs18 
\par       char *foobar(int index, int *list_size);
\par }\par If index is zero or positive, the function should return a pointer to the 
string which is to be displayed at position index in the list. If index 
is negative, it should return NULL and list_size should be set to the 
number of items in the list. 
\par \par To create a multiple selection listbox, set the dp2 field to an array of 
byte flags indicating the selection state of each list item (non-zero for 
selected entries). This table must be at least as big as the number of 
objects in the list! 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v d_text_list_proc}d_text_list_proc(int msg, DIALOG *d, int c);\par }
{\li400 Like d_list_proc, but allows the user to type in the first few characters 
of a listbox entry in order to select it. Uses dp3 internally, so you 
mustn't store anything important there yourself. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v d_textbox_proc}d_textbox_proc(int msg, DIALOG *d, int c);\par }
{\li400 A text box object. The dp field points to the text which is to be 
displayed in the box. If the text is long, there will be a vertical 
scrollbar on the right hand side of the object which can be used to 
scroll through the text. The default is to print the text with word 
wrapping, but if the D_SELECTED flag is set, the text will be printed 
with character wrapping. The d1 field is used internally to store the 
number of lines of text, and d2 is used to store how far it has scrolled 
through the text. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v d_slider_proc}d_slider_proc(int msg, DIALOG *d, int c);\par }
{\li400 A slider control object. This object holds a value in d2, in the range 
from 0 to d1. It will display as a vertical slider if h is greater than 
or equal to w, otherwise it will display as a horizontal slider. The dp 
field can contain an optional bitmap to use for the slider handle, and 
dp2 can contain an optional callback function, which is called each time 
d2 changes. The callback function should have the following prototype: 
\par {\s1 \f1\fs18 
\par       int function(void *dp3, int d2);
\par }\par The d_slider_proc object will return the value of the callback function. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v d_menu_proc}d_menu_proc(int msg, DIALOG *d, int c);\par }
{\li400 This object is a menu bar which will drop down child menus when it is 
clicked or if an alt+key corresponding to one of the shortcuts in the 
menu is pressed. It ignores a lot of the fields in the dialog structure, 
in particular the color is taken from the gui_*_color variables, and the 
width and height are calculated automatically (the w and h fields from 
the DIALOG are only used as a minimum size.) The dp field points to an 
array of menu structures: see do_menu() for more information. The top 
level menu will be displayed as a horizontal bar, but when child menus 
drop down from it they will be in the normal vertical format used by 
do_menu(). When a menu item is selected, the return value from the menu 
callback function is passed back to the dialog manager, so your callbacks 
should return D_O_K, D_REDRAW, or D_CLOSE. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v d_yield_proc}d_yield_proc(int msg, DIALOG *d, int c);\par }
{\li400 An invisible helper object that yields time slices for the scheduler (if 
the system supports it) when the GUI has nothing to do but waiting for 
user actions. You should put one instance of this object in each dialog 
array because it may be needed on systems with an unusual scheduling 
algorithm (for instance QNX) in order to make the GUI fully responsive. 
\par}\par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v GUI variables}
The behaviour of the dialog manager can be controlled by the following 
global variables. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v gui_mouse_focus}gui_mouse_focus;\par }
{\li400 If set, the input focus follows the mouse pointer around the dialog, 
otherwise a click is required to move it. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 extern int {\xe\v gui_fg_color}gui_fg_color;\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 extern int {\xe\v gui_bg_color}gui_bg_color;\par }
{\li400 The foreground and background colors for the standard dialogs (alerts, 
menus, and the file selector). They default to 255 and 0. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v gui_mg_color}gui_mg_color;\par }
{\li400 The color used for displaying greyed-out dialog objects (with the 
D_DISABLED flag set). Defaults to 8. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v gui_font_baseline}gui_font_baseline;\par }
{\li400 If set to a non-zero value, adjusts the keyboard shortcut underscores to 
account for the height of the descenders in your font. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 extern int (*{\xe\v gui_mouse_x}gui_mouse_x)();\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 extern int (*{\xe\v gui_mouse_y}gui_mouse_y)();\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 extern int (*{\xe\v gui_mouse_z}gui_mouse_z)();\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 extern int (*{\xe\v gui_mouse_b}gui_mouse_b)();\par }
{\li400 Hook functions, used by the GUI routines whenever they need to access the 
mouse state. By default these just return copies of the mouse_x, mouse_y, 
mouse_z, and mouse_b variables, but they could be used to offset or scale 
the mouse position, or read input from a different source entirely. 
\par}\par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v GUI font}
You can change the global 'font' pointer to make the GUI objects use 
something other than the standard 8x8 font. The standard dialog procedures, 
menus, and alert boxes, will work with fonts of any size, but the 
gfx_mode_select() dialog will look wrong with anything other than 8x8 fonts. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v gui_textout_ex}gui_textout_ex(BITMAP *bmp, const char *s, int x, y, color, bg, centre);\par }
{\li400 Helper function for use by the GUI routines. Draws a text string onto the 
screen, interpreting the '&' character as an underbar for displaying 
keyboard shortcuts. Returns the width of the output string in pixels. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v gui_strlen}gui_strlen(const char *s);\par }
{\li400 Helper function for use by the GUI routines. Returns the length of a 
string in pixels, ignoring '&' characters. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v gui_set_screen}gui_set_screen(BITMAP *bmp);\par }
{\li400 This function can be used to change the bitmap surface the GUI routines 
draw to. This can be useful if you are using a double buffering or page 
flipping system. Passing NULL will cause the default surface (screen) to 
be used again. Example: 
\par {\s1 \f1\fs18 
\par       BITMAP *page[2];
\par       
\par       /* Allocate two pages of video memory */
\par       page[0] = create_video_bitmap(SCREEN_W, SCREEN_H);
\par       page[1] = create_video_bitmap(SCREEN_W, SCREEN_H);
\par       
\par       /* Page flip */
\par       show_video_bitmap(page[0]);
\par       gui_set_screen(page[0]);
\par \par}}\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v gui_get_screen}gui_get_screen(void);\par }
{\li400 This function returns the current bitmap surface the GUI routines will 
use for drawing. Note that this function will return screen if you have 
called gui_set_screen(NULL) previously, and will never return NULL. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v position_dialog}position_dialog(DIALOG *dialog, int x, int y);\par }
{\li400 Moves an array of dialog objects to the specified screen position 
(specified as the top left corner of the dialog). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v centre_dialog}centre_dialog(DIALOG *dialog);\par }
{\li400 Moves an array of dialog objects so that it is centered in the screen. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_dialog_color}set_dialog_color(DIALOG *dialog, int fg, int bg);\par }
{\li400 Sets the foreground and background colors of an array of dialog objects. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v find_dialog_focus}find_dialog_focus(DIALOG *dialog);\par }
{\li400 Searches the dialog for the object which has the input focus, returning 
an index or -1 if the focus is not set. This is useful if you are calling 
do_dialog() several times in a row and want to leave the focus in the 
same place it was when the dialog was last displayed, as you can call 
do_dialog(dlg, find_dialog_focus(dlg)); 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v offer_focus}offer_focus(DIALOG *dialog, int obj, int *focus_obj, int force);\par }
{\li400 Offers the input focus to a particular object. Normally the function sends 
the MSG_WANTFOCUS message to query whether the object is willing to accept 
the focus. However, passing any non-zero value as force argument instructs 
the function to authoritatively set the focus to the object. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v object_message}object_message(DIALOG *dialog, int msg, int c);\par }
{\li400 Sends a message to an object and returns the answer it has generated. 
Remember that the first parameter is the dialog object (not a whole 
array) that you wish to send the message to. For example, to make the 
second object in a dialog draw itself, you might write: 
\par {\s1 \f1\fs18 
\par       object_message(&dialog[1], MSG_DRAW, 0);
\par }\par The function will take care of scaring and unscaring the mouse if the 
message is MSG_DRAW. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v dialog_message}dialog_message(DIALOG *dialog, int msg, int c, int *obj);\par }
{\li400 Sends a message to all the objects in an array. If any of the dialog 
procedures return values other than D_O_K, it returns the value and sets 
obj to the index of the object which produced it. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v broadcast_dialog_message}broadcast_dialog_message(int msg, int c);\par }
{\li400 Broadcasts a message to all the objects in the active dialog. If any of 
the dialog procedures return values other than D_O_K, it returns that 
value. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v do_dialog}do_dialog(DIALOG *dialog, int focus_obj);\par }
{\li400 The basic dialog manager function. This displays a dialog (an array of 
dialog objects, terminated by one with a NULL dialog procedure), and sets 
the input focus to the focus_obj (-1 if you don't want anything to have 
the focus). It interprets user input and dispatches messages as they are 
required, until one of the dialog procedures tells it to close the 
dialog, at which point it returns the index of the object that caused it 
to exit, or until ESC is pressed, at which point it returns -1. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v popup_dialog}popup_dialog(DIALOG *dialog, int focus_obj);\par }
{\li400 Like do_dialog(), but it stores the data on the screen before drawing the 
dialog and restores it when the dialog is closed. The screen area to be 
stored is calculated from the dimensions of the first object in the 
dialog, so all the other objects should lie within this one. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b DIALOG_PLAYER *{\xe\v init_dialog}init_dialog(DIALOG *dialog, int focus_obj);\par }
{\li400 This function provides lower level access to the same functionality as 
do_dialog(), but allows you to combine a dialog box with your own program 
control structures. It initialises a dialog, returning a pointer to a 
player object that can be used with update_dialog() and 
shutdown_dialog(). With these functions, you could implement your own 
version of do_dialog() with the lines: 
\par {\s1 \f1\fs18 
\par       DIALOG_PLAYER *player = init_dialog(dialog, focus_obj);
\par 
\par       while (update_dialog(player))
\par          ;
\par 
\par       return shutdown_dialog(player);\par}
\par Note that you are responsible for showing and hiding the mouse cursor, which 
do_dialog would otherwise do for you, or saving and restoring the screen 
contents, as popup_dialog would do for you. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v update_dialog}update_dialog(DIALOG_PLAYER *player);\par }
{\li400 Updates the status of a dialog object returned by init_dialog(). Returns 
TRUE if the dialog is still active, or FALSE if it has terminated. Upon a 
return value of FALSE, it is up to you whether to call shutdown_dialog() 
or to continue execution. The object that requested the exit can be 
determined from the player->obj field. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v shutdown_dialog}shutdown_dialog(DIALOG_PLAYER *player);\par }
{\li400 Destroys a dialog player object returned by init_dialog(), returning the 
object that caused it to exit (this is the same as the return value from 
do_dialog()). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern DIALOG *{\xe\v active_dialog}active_dialog;\par }
{\li400 Global pointer to the most recent activated dialog. This may be useful if 
an object needs to iterate through a list of all its siblings. 
\par}\par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v GUI menus}
Popup or pulldown menus are created as an array of MENU structures. Read 
chapter "Structures and types defined by Allegro" for an internal description 
of the MENU structure. 
\par \par Each menu item contains a text string. This can use the '&' character to 
indicate keyboard shortcuts, or can be an zero-length string to display the 
item as a non-selectable splitter bar. If the string contains a "\\t" tab 
character, any text after this will be right-justified, eg. for displaying 
keyboard shortcut information. The proc pointer is a function which will be 
called when the menu item is selected, and child points to another menu, 
allowing you to create nested menus. Both proc and child may be NULL. The 
proc function returns an integer which is ignored if the menu was brought up 
by calling do_menu(), but which is passed back to the dialog manager if it 
was created by a d_menu_proc() object. The array of menu items is terminated 
by an entry with a NULL text pointer. 
\par \par Menu items can be disabled (greyed-out) by setting the D_DISABLED bit in the 
flags field, and a check mark can be displayed next to them by setting the 
D_SELECTED bit. With the default alignment and font this will usually 
overlap the menu text, so if you are going to use checked menu items it 
would be a good idea to prefix all your options with a space or two, to 
ensure there is room for the check. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v do_menu}do_menu(MENU *menu, int x, int y);\par }
{\li400 Displays and animates a popup menu at the specified screen coordinates 
(these will be adjusted if the menu does not entirely fit on the screen). 
Returns the index of the menu item that was selected, or -1 if the menu 
was cancelled. Note that the return value cannot indicate selection from 
child menus, so you will have to use the callback functions if you want 
multi-level menus. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b MENU_PLAYER *{\xe\v init_menu}init_menu(MENU *menu, int x, int y);\par }
{\li400 This function provides lower level access to the same functionality as 
do_menu(), but allows you to combine a popup menu with your own program 
control structures. It initialises a menu, returning a pointer to a menu 
player object that can be used with update_menu() and shutdown_menu(). 
With these functions, you could implement your own version of do_menu() 
with the lines: 
\par {\s1 \f1\fs18 
\par       MENU_PLAYER *player = init_menu(menu, x, y);
\par 
\par       while (update_menu(player))
\par          ;
\par 
\par       return shutdown_menu(player);\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v update_menu}update_menu(MENU_PLAYER *player);\par }
{\li400 Updates the status of a menu object returned by init_menu(). Returns TRUE 
if the menu is still active, or FALSE if it has terminated. Upon a return 
value of FALSE, it is up to you to call shutdown_menu() or to continue 
execution. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v shutdown_menu}shutdown_menu(MENU_PLAYER *player);\par }
{\li400 Destroys a menu player object returned by init_menu(), returning the index 
of the menu item that was selected, or -1 if the menu was cancelled (this 
is the same as the return value from do_menu()). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern MENU *{\xe\v active_menu}active_menu;\par }
{\li400 When a menu callback procedure is triggered, this will be set to the menu 
item that was selected, so your routine can determine where it was called 
from. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 extern void (*{\xe\v gui_menu_draw_menu}gui_menu_draw_menu)(int x, int y, int w, int h);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 extern void (*{\xe\v gui_menu_draw_menu_item}gui_menu_draw_menu_item)(MENU *m, int x, int y, int w, int h, int bar, int sel);\par }
{\li400 If set, these functions will be called whenever a menu needs to be 
drawn, so you can change how menus look. 
\par \par gui_menu_draw_menu() is passed the position and size of the 
menu. It should draw the background of the menu onto screen. 
\par \par gui_menu_draw_menu_item() is called once for each menu item that is 
to be drawn. bar will be set if the item is part of a top-level 
horizontal menu bar, and sel will be set if the menu item is 
selected. It should also draw onto screen. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v alert}alert(const char *s1, *s2, *s3, const char *b1, *b2, int c1, c2);\par }
{\li400 Displays a popup alert box, containing three lines of text (s1-s3), and 
with either one or two buttons. The text for these buttons is passed in 
`b1' and `b2' (`b2' may be NULL), and the keyboard shortcuts in `c1' and 
`c2' as ASCII value. Example: 
\par {\s1 \f1\fs18 
\par       if (!exists(CONFIG_FILE))
\par          alert(CONFIG_FILE, "not found.", "Using defaults.",
\par                "&Continue", NULL, 'c', 0);\par}
\par Returns 1 or 2 depending on which button was clicked. If the alert is 
dismissed by pressing ESC when ESC is not one of the keyboard shortcuts, 
it treats it as a click on the second button (this is consistent with the 
common "Ok", "Cancel" alert). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v alert3}alert3(const char *s1, *s2, *s3, const char *b1, *b2, *b3, int c1, c2, c3);\par }
{\li400 Like alert(), but with three buttons. Returns 1, 2, or 3. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v file_select_ex}file_select_ex(const char *message, char *path, const char *ext, int size, int w, int h);\par }
{\li400 Displays the Allegro file selector, with the message as caption. The path 
parameter contains the initial filename to display (this can be used to 
set the starting directory, or to provide a default filename for a 
save-as operation). The user selection is returned by altering the path 
buffer, whose maximum capacity in bytes is specified by the size parameter. 
Note that it should have room for at least 80 characters (not bytes), 
so you should reserve 6x that amount, just to be sure. The list of files 
is filtered according to the file extensions in the ext parameter. 
Passing NULL includes all files; "PCX;BMP" includes only files with 
.PCX or .BMP extensions. If you wish to control files by their attributes, 
one of the fields in the extension list can begin with a slash, followed 
by a set of attribute characters. Any attribute written on its own, or 
with a '+' before it, indicates to include only files which have that 
attribute set. Any attribute with a '-' before it indicates to leave out 
any files with that attribute. The flag characters are 'r' (read-only), 
'h' (hidden), 's' (system), 'd' (directory) and 'a' (archive). For 
example, an extension string of "PCX;BMP;/+r-h" will display only PCX or 
BMP files that are read-only and not hidden. The directories are not 
affected in the same way as the other files by the extension string: the 
extensions are never taken into account for them and the other attributes 
are taken into account only when 'd' is mentioned in the string; in other 
words, all directories are included when 'd' is not mentioned in the 
string. The file selector is stretched to the width and height specified 
in the w and h parameters, and to the size of the standard Allegro font. 
If either the width or height argument is set to zero, it is stretched 
to the corresponding screen dimension. This function returns zero if it 
was closed with the Cancel button or non-zero if it was OK'd. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v gfx_mode_select}gfx_mode_select(int *card, int *w, int *h);\par }
{\li400 Displays the Allegro graphics mode selection dialog, which allows the 
user to select a screen mode and graphics card. Stores the selection in 
the three variables, and returns zero if it was closed with the Cancel 
button or non-zero if it was OK'd. 
\par \par The initial values of card, w, h are not used. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v gfx_mode_select_ex}gfx_mode_select_ex(int *card, int *w, int *h, int *color_depth);\par }
{\li400 Extended version of the graphics mode selection dialog, which allows the 
user to select the color depth as well as the resolution and hardware 
driver. 
\par \par This version of the function reads the initial values from the 
parameters when it activates so you can specify the default values. 
In fact, you should be sure not to pass in uninitialised values. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b int {\xe\v gfx_mode_select_filter}gfx_mode_select_filter(int *card, int *w, int *h, int *color_depth, int (*filter)(int, int, int, int));\par }
{\li400 Even more extended version of the graphics mode selection dialog, which 
allows the programmer to customize the contents of the dialog and the user 
to select the color depth as well as the resolution and hardware driver. 
`filter' will be passed (card, w, h, color_depth) quadruplets and must 
return 0 to let the specified quadruplet be added to the list of displayed 
modes. 
\par \par This version of the function reads the initial values from the 
parameters when it activates so you can specify the default values. 
In fact, you should be sure not to pass in uninitialised values. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b \sa0 extern int (*{\xe\v gui_shadow_box_proc}gui_shadow_box_proc)(int msg, struct DIALOG *d, int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 extern int (*{\xe\v gui_ctext_proc}gui_ctext_proc)(int msg, struct DIALOG *d, int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 extern int (*{\xe\v gui_button_proc}gui_button_proc)(int msg, struct DIALOG *d, int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 extern int (*{\xe\v gui_edit_proc}gui_edit_proc)(int msg, struct DIALOG *d, int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 \sa0 extern int (*{\xe\v gui_list_proc}gui_list_proc)(int msg, struct DIALOG *d, int c);\par }
{\s3 \f0\fs24\sb200\keepn\sa200\b \sb0 extern int (*{\xe\v gui_text_list_proc}gui_text_list_proc)(int msg, struct DIALOG *d, int c);\par }
{\li400 If set, these functions will be used by the standard Allegro dialogs. 
This allows you to customise the look and feel, much like gui_fg_color 
and gui_bg_color, but much more flexibly. 
\par \par \par \par \par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v DOS specifics}DOS specifics\par }
There are four Allegro files which you should redistribute along your program. 
These are the files `keyboard.dat', `language.dat', `allegro.cfg' and 
`setup.exe'. 
\par \par The first two contain internationalisation information for keyboard mappings 
and system messages to show up localised on the user's computer. The 
`setup.exe' program, which comes in Allegro's `setup' directory, is a 
standalone tool which you can graphically customise and even embed into your 
main binary. The user can generate a configuration file with this tool, to 
store special settings or avoid Allegro's autodetection failing on specific 
hardware. Even if you distribute `setup.exe', you are recommended to copy too 
the empty `allegro.cfg' file, in case the setup program itself is unable to 
run and the user has to edit manually the configuration with a text editor. 
\par \par If you are using get_config_text() in your program to localise text strings, 
merge your xxtext.cfg files with the ones provided by Allegro in the 
`resource' directory before creating `language.dat', and redistribute this 
with your program. This file will contain then both Allegro's system 
messages and the strings of your program. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v JOY_TYPE_*/DOS}JOY_TYPE_*/DOS\par }
{\li400 The DOS library supports the following type parameters for the 
install_joystick() function: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_AUTODETECT\par \pard \li800 
Attempts to autodetect your joystick hardware. It isn't possible to 
reliably distinguish between all the possible input setups, so this 
routine can only ever choose the standard joystick, Sidewider, GamePad 
Pro, or GrIP drivers, but it will use information from the 
configuration file if one is available (this can be created using the 
setup utility or by calling the save_joystick_data() function), so you 
can always use JOY_TYPE_AUTODETECT in your code and then select the 
exact hardware type from the setup program. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_NONE\par \pard \li800 
Dummy driver for machines without any joystick. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_STANDARD\par \pard \li800 
A normal two button stick. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_2PADS\par \pard \li800 
Dual joystick mode (two sticks, each with two buttons). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_4BUTTON\par \pard \li800 
Enable the extra buttons on a 4-button joystick. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_6BUTTON\par \pard \li800 
Enable the extra buttons on a 6-button joystick. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_8BUTTON\par \pard \li800 
Enable the extra buttons on an 8-button joystick. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_FSPRO\par \pard \li800 
CH Flightstick Pro or compatible stick, which provides four buttons, 
an analogue throttle control, and a 4-direction coolie hat. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_WINGEX\par \pard \li800 
A Logitech Wingman Extreme, which should also work with any 
Thrustmaster Mk.I compatible joystick. It provides support for four 
buttons and a coolie hat. This also works with the Wingman Warrior, if 
you plug in the 15 pin plug (remember to unplug the 9-pin plug!) and 
set the tiny switch in front to the "H" position (you will not be able 
to use the throttle or the spinner though). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_SIDEWINDER\par \pard \li800 
The Microsoft Sidewinder digital pad (supports up to four controllers, 
each with ten buttons and a digital direction control). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_SIDEWINDER_AG\par \pard \li800 
An alternative driver to JOY_TYPE_SIDEWINDER. 
Try this if your Sidewinder isn't recognized with JOY_TYPE_SIDEWINDER. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_SIDEWINDER_PP\par \pard \li800 
The Microsoft Sidewinder 3D/Precision/Force Feedback Pro joysticks. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_GAMEPAD_PRO\par \pard \li800 
The Gravis GamePad Pro (supports up to two controllers, each with ten 
buttons and a digital direction control). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_GRIP\par \pard \li800 
Gravis GrIP driver, using the grip.gll driver file. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_GRIP4\par \pard \li800 
Version of the Gravis GrIP driver that is constrained to only move 
along the four main axes. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_SNESPAD_LPT1\par \pard \li800 
JOY_TYPE_SNESPAD_LPT2\par 
JOY_TYPE_SNESPAD_LPT3\par 
SNES joypads connected to LPT1, LPT2, and LPT3 respectively. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_PSXPAD_LPT1\par \pard \li800 
JOY_TYPE_PSXPAD_LPT2\par 
JOY_TYPE_PSXPAD_LPT3\par 
PSX joypads connected to LPT1, LPT2, and LPT3 respectively. See 
http://www.ziplabel.com/dpadpro/index.html for information 
about the parallel cable required. The driver automagically detects 
which types of PSX pads are connected out of digital, analog (red or 
green mode), NegCon, multi taps, Namco light guns, Jogcons (force 
feedback steering wheel) and the mouse. If the controller isn't 
recognised it is treated as an analog controller, meaning the driver 
should work with just about anything. You can connect controllers in 
any way you see fit, but only the first 8 will be used. 
\par \par The Sony Dual Shock or Namco Jogcon will reset themselves (to digital 
mode) after not being polled for 5 seconds. This is normal, the same 
thing happens on a Playstation, it's designed to stop any vibration in 
case the host machine crashes. Other mode switching controllers may 
have similar quirks. However, if this happens to a Jogcon controller 
the mode button is disabled. To reenable the mode button on the Jogcon 
you need to hold down the Start and Select buttons at the same time. 
\par \par The G-con45 needs to be connected to (and pointed at) a TV type monitor 
connected to your computer. The composite video out on my video card 
works fine for this (a Hercules Stingray 128/3D 8Mb). The TV video 
modes in Mame should work too. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_N64PAD_LPT1\par \pard \li800 
JOY_TYPE_N64PAD_LPT2\par 
JOY_TYPE_N64PAD_LPT3\par 
N64 joypads connected to LPT1, LPT2, and LPT3 respectively. See 
http://www.st-hans.de/N64.htm for information about the 
necessary hardware adapter. It supports up to four controllers on a 
single parallel port. There is no need to calibrate the analog stick, 
as this is done by the controller itself when powered up. This means 
that the stick has to be centred when the controller is initialised. 
One possible issue people may have with this driver is that it is 
physically impossible to move the analog stick fully diagonal, but I 
can't see this causing any major problems. This is because of the 
shape of the rim that the analog stick rests against. Like the Gravis 
Game Pad Pro, this driver briefly needs to disable hardware interrupts 
while polling. This causes a noticeable performance hit on my machine 
in both drivers, but there is no way around it. At a (very) rough 
guess I'd say it slows down Mame 5% - 10%. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_DB9_LPT1\par \pard \li800 
JOY_TYPE_DB9_LPT2\par 
JOY_TYPE_DB9_LPT3\par 
A pair of two-button joysticks connected to LPT1, LPT2, and LPT3 
respectively. Port 1 is compatible with Linux joy-db9 driver 
(multisystem 2-button), and port 2 is compatible with Atari interface 
for DirectPad Pro. See the source file (src/dos/multijoy.c) for pinout 
information. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_TURBOGRAFIX_LPT1\par \pard \li800 
JOY_TYPE_TURBOGRAFIX_LPT2\par 
JOY_TYPE_TURBOGRAFIX_LPT3\par 
These drivers support up to 7 joysticks, each one with up to 5 
buttons, connected to LPT1, LPT2, and LPT3 respectively. They use the 
TurboGraFX interface by Steffen Schwenke: see 
http://www.burg-halle.de/~schwenke/parport.html for details 
on how to build this. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_WINGWARRIOR\par \pard \li800 
A Wingman Warrior joystick. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_IFSEGA_ISA\par \pard \li800 
JOY_TYPE_IFSEGA_PCI\par 
JOY_TYPE_IFSEGA_PCI_FAST\par 
Drivers for the IF-SEGA joystick interface cards by the IO-DATA 
company (these come in PCI, PCI2, and ISA variants). 
\par}\par}{\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v GFX_*/DOS}GFX_*/DOS\par }
{\li400 The DOS library supports the following card parameters for the 
set_gfx_mode() function: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_TEXT\par \pard \li800 
Return to text mode. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT\par \pard \li800 
Let Allegro pick an appropriate graphics driver. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT_FULLSCREEN\par \pard \li800 
Autodetects a graphics driver, but will only use fullscreen drivers, 
failing if these are not available on current platform. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT_WINDOWED\par \pard \li800 
Same as above, but uses only windowed drivers. This will always fail 
under DOS. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_SAFE\par \pard \li800 
Special driver for when you want to reliably set a graphics mode and 
don't really care what resolution or color depth you get. See the 
set_gfx_mode() documentation for details. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_VGA\par \pard \li800 
The standard 256-color VGA mode 13h, using the GFX_VGA driver. This is 
normally sized 320x200, which will work on any VGA but doesn't support 
large virtual screens and hardware scrolling. Allegro also provides 
some tweaked variants of the mode which are able to scroll, sized 
320x100 (with a 200 pixel high virtual screen), 160x120 (with a 409 
pixel high virtual screen), 256x256 (no scrolling), and 80x80 (with a 
819 pixel high virtual screen). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_MODEX\par \pard \li800 
Mode-X will work on any VGA card, and provides a range of different 
256-color tweaked resolutions. 
\par {\li1200 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200 Stable mode-X resolutions: 
\par {\li1600 \pard \li1600 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600 Square aspect ratio: 320x240 
\par \pard \li1600 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600 Skewed aspect ratio: 256x224, 256x240, 320x200, 320x400, 
320x480, 320x600, 360x200, 360x240, 
360x360, 360x400, 360x480 
\par}\pard \li1200 \pard \li1200 \par These have worked on every card/monitor that I've tested. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1200 Unstable mode-X resolutions: 
\par {\li1600 \pard \li1600 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600 Square aspect ratio: 360x270, 376x282, 400x300 
\par \pard \li1600 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li1600 Skewed aspect ratio: 256x200, 256x256, 320x350, 360x600, 
376x308, 376x564, 400x150, 400x600 
\par}\pard \li1200 \pard \li1200 \par These only work on some monitors. They were fine on my old machine, 
but don't get on very well with my new monitor. If you are worried 
about the possibility of damaging your monitor by using these 
modes, don't be. Of course I'm not providing any warranty with any 
of this, and if your hardware does blow up that is tough, but I 
don't think this sort of tweaking can do any damage. From the 
documentation of Robert Schmidt's TWEAK program: 
\par \par "Some time ago, putting illegal or unsupported values or 
combinations of such into the video card registers might prove 
hazardous to both your monitor and your health. I have *never* 
claimed that bad things can't happen if you use TWEAK, although 
I'm pretty sure it never will. I've never heard of any damage 
arising from trying out TWEAK, or from general VGA tweaking in 
any case." 
\par}\pard \li800 \par Most of the mode-X drawing functions are slower than in mode 13h, due 
to the complexity of the planar bitmap organisation, but solid area 
fills and plane-aligned blits from one part of video memory to another 
can be significantly faster, particularly on older hardware. Mode-X 
can address the full 256k of VGA RAM, so hardware scrolling and page 
flipping are possible, and it is possible to split the screen in order 
to scroll the top part of the display but have a static status 
indicator at the bottom. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_VESA1\par \pard \li800 
Use the VESA 1.x driver. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_VESA2B\par \pard \li800 
Use the VBE 2.0 banked mode driver. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_VESA2L\par \pard \li800 
Use the VBE 2.0 linear framebuffer driver. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_VESA3\par \pard \li800 
Use the VBE 3.0 driver. This is the only VESA driver that supports the 
request_refresh_rate() function. 
\par \par The standard VESA modes are 640x480, 800x600, and 1024x768. These 
ought to work with any SVGA card: if they don't, get a copy of the 
SciTech Display Doctor and see if that fixes it. What color depths are 
available will depend on your hardware. Most cards support both 15 and 
16-bit resolutions, but if at all possible I would advise you to 
support both (it's not hard...) in case one is not available. Some 
cards provide both 24 and 32-bit truecolor, in which case it is a 
choice between 24 (saves memory) or 32 (faster), but many older cards 
have no 32-bit mode and some newer ones don't support 24-bit 
resolutions. Use the vesainfo test program to see what modes your VESA 
driver provides. 
\par \par Many cards also support 640x400, 1280x1024, and 1600x1200, but these 
aren't available on everything, for example the S3 chipset has no 
640x400 mode. Other weird resolution may be possible, eg. some Tseng 
boards can do 640x350, and the Avance Logic has a 512x512 mode. 
\par \par The SciTech Display Doctor provides several scrollable low resolution 
modes in a range of different color depths (320x200, 320x240, 320x400, 
320x480, 360x200, 360x240, 360x400, and 360x480 all work on my ET4000 
with 8, 15, or 16 bits per pixel). These are lovely, allowing 
scrolling and page flipping without the complexity of the mode-X 
planar setup, but unfortunately they aren't standard so you will need 
Display Doctor in order to use them. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_VBEAF\par \pard \li800 
VBE/AF is a superset of the VBE 2.0 standard, which provides an API 
for accessing hardware accelerator features. VBE/AF drivers are 
currently only available from the FreeBE/AF project or as part of the 
SciTech Display Doctor package, but they can give dramatic speed 
improvements when used with suitable hardware. For a detailed 
discussion of hardware acceleration issues, refer to the documentation 
for the gfx_capabilities flag. 
\par \par You can use the afinfo test program to check whether you have a VBE/AF 
driver, and to see what resolutions it supports. 
\par \par The SciTech VBE/AF drivers require nearptr access to be enabled, so 
any stray pointers are likely to crash your machine while their 
drivers are in use. This means it may be a good idea to use VESA while 
debugging your program, and only switch to VBE/AF once the code is 
working correctly. The FreeBE/AF drivers do not have this problem. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_XTENDED\par \pard \li800 
An unchained 640x400 mode, as described by Mark Feldman in the PCGPE. 
This uses VESA to select an SVGA mode (so it will only work on cards 
supporting the VESA 640x400 resolution), and then unchains the VGA 
hardware as for mode-X. This allows the entire screen to be addressed 
without the need for bank switching, but hardware scrolling and page 
flipping are not possible. This driver will never be autodetected (the 
normal VESA 640x400 mode will be chosen instead), so if you want to 
use it you will have to explicitly pass GFX_XTENDED to set_gfx_mode(). 
\par}\par There are a few things you need to be aware of for scrolling: 
most VESA implementations can only handle horizontal scrolling in four 
pixel increments, so smooth horizontal panning is impossible in SVGA modes. 
A significant number of VESA implementations seem to be very buggy when it 
comes to scrolling in truecolor video modes, so you shouldn't depend on 
this routine working correctly in the truecolor resolutions unless you can 
be sure that SciTech Display Doctor is installed. Hardware scrolling may 
also not work at all under Windows. 
\par \par Triple buffering is only possible with certain drivers: it will work in any 
DOS mode-X resolution if the timer retrace simulator is active (but this 
doesn't work correctly under Windows 95), plus it is supported by the 
VBE 3.0 and VBE/AF drivers for a limited number graphics cards. 
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b \par Drivers {\xe\v DIGI_*/DOS}DIGI_*/DOS\par }
{\li400 The DOS sound functions support the following digital sound cards: 
\par {\s1 \f1\fs18 
\par       DIGI_AUTODETECT      - let Allegro pick a digital sound driver
\par       DIGI_NONE            - no digital sound
\par       DIGI_SB              - Sound Blaster (autodetect type)
\par       DIGI_SB10            - SB 1.0 (8-bit mono single shot DMA)
\par       DIGI_SB15            - SB 1.5 (8-bit mono single shot DMA)
\par       DIGI_SB20            - SB 2.0 (8-bit mono auto-initialised
\par                              DMA)
\par       DIGI_SBPRO           - SB Pro (8-bit stereo)
\par       DIGI_SB16            - SB16 (16-bit stereo)
\par       DIGI_AUDIODRIVE      - ESS AudioDrive
\par       DIGI_SOUNDSCAPE      - Ensoniq Soundscape
\par       DIGI_WINSOUNDSYS     - Windows Sound System\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v MIDI_*/DOS}MIDI_*/DOS\par }
{\li400 The DOS sound functions support the following MIDI sound cards: 
\par {\s1 \f1\fs18 
\par       MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
\par       MIDI_NONE            - no MIDI sound
\par       MIDI_ADLIB           - Adlib or SB FM synth (autodetect type)
\par       MIDI_OPL2            - OPL2 synth (mono, used in Adlib and SB)
\par       MIDI_2XOPL2          - dual OPL2 synths (stereo, used in
\par                              SB Pro-I)
\par       MIDI_OPL3            - OPL3 synth (stereo, SB Pro-II
\par                              and above)
\par       MIDI_SB_OUT          - SB MIDI interface
\par       MIDI_MPU             - MPU-401 MIDI interface
\par       MIDI_DIGMID          - sample-based software wavetable player
\par       MIDI_AWE32           - AWE32 (EMU8000 chip)\par}
\par}\brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v DOS integration routines}
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b extern int {\xe\v i_love_bill}i_love_bill;\par }
{\li400 When running in clean DOS mode, the timer handler dynamically reprograms 
the clock chip to generate interrupts at exactly the right times, which 
gives an extremely high accuracy. Unfortunately, this constant speed 
adjustment doesn't work under most multitasking systems (notably 
Windows), so there is an alternative mode that just locks the hardware 
timer interrupt to a speed of 200 ticks per second. This reduces the 
accuracy of the timer (for instance, rest() will round the delay time to 
the nearest 5 milliseconds), and prevents the vertical retrace simulator 
from working, but on the plus side, it makes Allegro programs work under 
Windows. This flag is set by allegro_init() if it detects the presence of 
a multitasking OS, and enables the fixed rate timer mode. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Windows specifics}Windows specifics\par }
In terms of file redistribution, the Windows platform behaves practically the 
same as the DOS platform. Read section chapter "Dos specifics" in the manual 
to learn more about this. 
\par \par A Windows program that uses the Allegro library is only required to include 
one or more header files from the include/allegro tree, or allegro.h; however, 
if it also needs to directly call non portable Win32 API functions, it must 
include the Windows-specific header file winalleg.h after the Allegro headers, 
and before any Win32 API header file. By default winalleg.h includes the main 
Win32 C API header file windows.h. If instead you want to use the C++ 
interface to the Win32 API (a.k.a. the Microsoft Foundation Classes), define 
the preprocessor symbol ALLEGRO_AND_MFC before including any Allegro header 
so that afxwin.h will be included. Note that, in this latter case, the Allegro 
debugging macros ASSERT() and TRACE() are renamed AL_ASSERT() and AL_TRACE() 
respectively. 
\par \par Windows GUI applications start with a WinMain() entry point, rather than the 
standard main() entry point. Allegro is configured to build GUI applications 
by default and to do some magic in order to make a regular main() work with 
them, but you have to help it out a bit by writing END_OF_MAIN() right after 
your main() function. If you don't want to do that, you can just include 
winalleg.h and write a WinMain() function. Note that this magic may bring 
about conflicts with a few programs using direct calls to Win32 API 
functions; for these programs, the regular WinMain() is required and the 
magic must be disabled by defining the preprocessor symbol 
ALLEGRO_NO_MAGIC_MAIN before including Allegro headers. 
\par \par If you want to build a console application using Allegro, you have to define 
the preprocessor symbol ALLEGRO_USE_CONSOLE before including Allegro headers; 
it will instruct the library to use console features and also to disable the 
special processing of the main() function described above. 
\par \par When creating the main window, Allegro searches the executable for an ICON 
resource named "allegro_icon". If it is present, Allegro automatically 
loads it and uses it as its application icon; otherwise, Allegro uses the 
default IDI_APPLICATION icon. See the manual of your compiler for a method 
to create an ICON resource, or use the wfixicon utility from the tools/win 
directory. 
\par \par DirectX requires that system and video bitmaps (including the screen) be 
locked before you can draw onto them. This will be done automatically, but 
you can usually get much better performance by doing it yourself: see the 
acquire_bitmap() function for details. 
\par \par Due to a major oversight in the design of DirectX, there is no way to 
preserve the contents of video memory when the user switches away from your 
program. You need to be prepared for the fact that your screen contents, and 
the contents of any video memory bitmaps, may be destroyed at any point. You 
can use the set_display_switch_callback() function to find out when this 
happens. 
\par \par On the Windows platform, the only return values for the desktop_color_depth() 
function are 8, 16, 24 and 32. This means that 15-bit and 16-bit desktops 
cannot be differentiated and are both reported as 16-bit desktops. See 
below for the consequences for windowed and overlay DirectX drivers. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v JOY_TYPE_*/Windows}JOY_TYPE_*/Windows\par }
{\li400 The Windows library supports the following type parameters for the 
install_joystick() function: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_AUTODETECT\par \pard \li800 
Attempts to autodetect your joystick hardware. It will use information 
from the configuration file if one is available (this can be created 
using the setup utility or by calling the save_joystick_data() 
function), so you can always use JOY_TYPE_AUTODETECT in your code and 
then select the exact hardware type from the setup program. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_NONE\par \pard \li800 
Dummy driver for machines without any joystick. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_DIRECTX\par \pard \li800 
Use DirectInput to access the joystick. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_WIN32\par \pard \li800 
Use the regular Win32 interface rather than DirectInput to access the 
joystick. 
\par}\par}\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v GFX_*/Windows}GFX_*/Windows\par }
{\li400 The Windows library supports the following card parameters for the 
set_gfx_mode() function: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_TEXT\par \pard \li800 
This closes any graphics mode previously opened with set_gfx_mode. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT\par \pard \li800 
Let Allegro pick an appropriate graphics driver. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT_FULLSCREEN\par \pard \li800 
Autodetects a graphics driver, but will only use fullscreen drivers, 
failing if these are not available on current platform. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT_WINDOWED\par \pard \li800 
Same as above, but uses only windowed drivers. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_SAFE\par \pard \li800 
Special driver for when you want to reliably set a graphics mode and 
don't really care what resolution or color depth you get. See the 
set_gfx_mode() documentation for details. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_DIRECTX\par \pard \li800 
Alias for GFX_DIRECTX_ACCEL. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_DIRECTX_ACCEL\par \pard \li800 
The regular fullscreen DirectX driver, running with hardware 
acceleration enabled. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_DIRECTX_SOFT\par \pard \li800 
DirectX fullscreen driver that only uses software drawing, rather than 
any hardware accelerated features. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_DIRECTX_SAFE\par \pard \li800 
Simplified fullscreen DirectX driver that doesn't support any hardware 
acceleration, video or system bitmaps, etc. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_DIRECTX_WIN\par \pard \li800 
The regular windowed DirectX driver, running in color conversion mode 
when the color depth doesn't match that of the Windows desktop. Color 
conversion is much slower than direct drawing and is not supported 
between 15-bit and 16-bit color depths. This limitation is needed to 
work around that of desktop_color_depth() (see above) and allows to 
select the direct drawing mode in a reliable way on desktops reported 
as 16-bit: 
\par {\s1 \f1\fs18 
\par          if (desktop_color_depth() == 16) \{
\par             set_color_depth(16);
\par             if (set_gfx_mode(GFX_DIRECTX_WIN, 640, 480, 0, 0)
\par                 != 0) \{
\par                set_color_depth(15);
\par                if (set_gfx_mode(GFX_DIRECTX_WIN, 640, 480, 0, 0)
\par                    != 0) \{
\par                   /* 640x480 direct drawing mode not supported */
\par                   goto Error;
\par                \}
\par             \}
\par             /* ok, we are in direct drawing mode */
\par          \}
\par }\pard \li800 \par Note that, mainly for performance reasons, this driver requires the 
width of the screen to be a multiple of 4. 
This driver is capable of displaying a hardware cursor, but there are 
size restrictions. Typically, the cursor image cannot be more than 
32x32 pixels. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_DIRECTX_OVL\par \pard \li800 
The DirectX overlay driver. It uses special hardware features to run 
your program in a windowed mode: it doesn't work on all hardware, but 
performance is excellent on cards that are capable of it. It requires 
the color depth to be the same as that of the Windows desktop. In light 
of the limitation of desktop_color_depth() (see above), the reliable 
way of setting the overlay driver on desktops reported as 16-bit is: 
\par {\s1 \f1\fs18 
\par          if (desktop_color_depth() == 16) \{
\par             set_color_depth(16);
\par             if (set_gfx_mode(GFX_DIRECTX_OVL, 640, 480, 0, 0)
\par                 != 0) \{
\par                set_color_depth(15);
\par                if (set_gfx_mode(GFX_DIRECTX_OVL, 640, 480, 0, 0)
\par                    != 0) \{
\par                   /* 640x480 overlay driver not supported */
\par                   goto Error;
\par                \}
\par             \}
\par             /* ok, the 640x480 overlay driver is running */
\par          \}\par}
\pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_GDI\par \pard \li800 
The windowed GDI driver. It is extremely slow, but is guaranteed to 
work on all hardware, so it can be useful for situations where you 
want to run in a window and don't care about performance. Note that 
this driver features a hardware mouse cursor emulation in order to 
speed up basic mouse operations (like GUI operations). 
\par}\par}{\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v DIGI_*/Windows}DIGI_*/Windows\par }
{\li400 The Windows sound functions support the following digital sound cards: 
\par {\s1 \f1\fs18 
\par       DIGI_AUTODETECT      - let Allegro pick a digital sound driver
\par       DIGI_NONE            - no digital sound
\par       DIGI_DIRECTX(n)      - use DirectSound device #n (zero-based)
\par                              with direct mixing
\par       DIGI_DIRECTAMX(n)    - use DirectSound device #n (zero-based)
\par                              with Allegro mixing
\par       DIGI_WAVOUTID(n)     - high (n=0) or low (n=1) quality WaveOut
\par                              device\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v MIDI_*/Windows}MIDI_*/Windows\par }
{\li400 The Windows sound functions support the following MIDI sound cards: 
\par {\s1 \f1\fs18 
\par       MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
\par       MIDI_NONE            - no MIDI sound
\par       MIDI_WIN32MAPPER     - use win32 MIDI mapper
\par       MIDI_WIN32(n)        - use win32 device #n (zero-based)
\par       MIDI_DIGMID          - sample-based software wavetable player\par}
\par}\brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v Windows integration routines}
\par \par The following functions provide a platform specific interface to seamlessly 
integrate Allegro into general purpose Win32 programs. To use these routines, 
you must include winalleg.h after other Allegro headers. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b HWND {\xe\v win_get_window}win_get_window(void);\par }
{\li400 Retrieves a handle to the window used by Allegro. Note that Allegro 
uses an underlying window even though you don't set any graphics mode, 
unless you have installed the neutral system driver (SYSTEM_NONE). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v win_set_window}win_set_window(HWND wnd);\par }
{\li400 Registers an user-created window to be used by Allegro. This function is 
meant to be called before initialising the library with allegro_init() 
or installing the autodetected system driver (SYSTEM_AUTODETECT). It 
lets you attach Allegro to any already existing window and prevents the 
library from creating its own, thus leaving you total control over the 
window; in particular, you are responsible for processing the events as 
usual (Allegro will automatically monitor a few of them, but will not 
filter out any of them). You can then use every component of the library 
(graphics, mouse, keyboard, sound, timers and so on), bearing in mind 
that some Allegro functions are blocking (e.g. readkey() if the key buffer 
is empty) and thus must be carefully manipulated by the window thread. 
\par \par However you can also call it after the library has been initialised, 
provided that no graphics mode is set. In this case the keyboard, mouse, 
joystick, sound and sound recording modules will be restarted. 
\par \par Passing NULL instructs Allegro to switch back to its built-in window if 
an user-created window was registered, or to request a new handle from 
Windows for its built-in window if this was already in use. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v win_set_wnd_create_proc}win_set_wnd_create_proc(HWND (*proc)(WNDPROC));\par }
{\li400 Registers an user-defined procedure to be used by Allegro for creating 
its window. This function must be called *before* initializing the 
library with allegro_init() or installing the autodetected system 
driver (SYSTEM_AUTODETECT). It lets you customize Allegro's window but 
only by its creation: unlike with win_set_window(), you have no control 
over the window once it has been created (in particular, you are not 
responsible for processing the events). The registered function will be 
passed a window procedure (WNDPROC object) that it must make the 
procedure of the new window of and it must return a handle to the new 
window. You can then use the full-featured library in the regular way. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b HDC {\xe\v win_get_dc}win_get_dc(BITMAP *bmp);\par }
{\li400 Retrieves a handle to the device context of a DirectX video or system 
bitmap. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v win_release_dc}win_release_dc(BITMAP *bmp, HDC dc);\par }
{\li400 Releases a handle to the device context of the bitmap that was 
previously retrieved with win_get_dc(). 
\par}\par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v GDI routines}
\par \par The following GDI routines are a very platform specific thing, to allow 
drawing Allegro memory bitmaps onto a Windows device context. When you want 
to use this, you'll have to install the neutral system driver (SYSTEM_NONE) 
or attach Allegro to an external window with win_set_window(). 
\par \par There are two ways to draw your Allegro bitmaps to the Windows GDI. When you 
are using static bitmaps (for example just some pictures loaded from a 
datafile), you can convert them to DDB (device-dependent bitmaps) with 
convert_bitmap_to_hbitmap() and then just use Win32's BitBlt() to draw it. 
\par \par When you are using dynamic bitmaps (for example some things which react to 
user input), it's better to use set_palette_to_hdc() and blit_to_hdc() 
functions, which work with DIB (device-independent bitmaps). 
\par \par There are also functions to blit from a device context into an Allegro 
BITMAP, so you can do things like screen capture. 
\par \par All the drawing and conversion functions use the current palette as a color 
conversion table. You can alter the current palette with the 
set_palette_to_hdc() or select_palette() functions. Warning: when the GDI 
system color palette is explicitly changed, (by another application, for 
example) the current Allegro palette is not updated along with it! 
\par \par To use these routines, you must include winalleg.h after Allegro headers. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_gdi_color_format}set_gdi_color_format(void);\par }
{\li400 Tells Allegro to use the GDI color layout for truecolor images. This is 
optional, but it will make the conversions work faster. If you are going 
to call this, you should do it right after initialising Allegro and 
before creating any graphics. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v set_palette_to_hdc}set_palette_to_hdc(HDC dc, PALETTE pal);\par }
{\li400 Selects and realizes an Allegro palette on the specified device context. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b HPALETTE {\xe\v convert_palette_to_hpalette}convert_palette_to_hpalette(PALETTE pal);\par }
{\li400 Converts an Allegro palette to a Windows palette and returns a handle to 
it. You should call DeleteObject() when you no longer need it. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v convert_hpalette_to_palette}convert_hpalette_to_palette(HPALETTE hpal, PALETTE pal);\par }
{\li400 Converts a Windows palette to an Allegro palette. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b HBITMAP {\xe\v convert_bitmap_to_hbitmap}convert_bitmap_to_hbitmap(BITMAP *bitmap);\par }
{\li400 Converts an Allegro memory bitmap to a Windows DDB and returns a handle 
to it. This bitmap uses its own memory, so you can destroy the original 
bitmap without affecting the converted one. You should call 
DeleteObject() when you no longer need this bitmap. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b BITMAP *{\xe\v convert_hbitmap_to_bitmap}convert_hbitmap_to_bitmap(HBITMAP bitmap);\par }
{\li400 Creates an Allegro memory bitmap from a Windows DDB. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v draw_to_hdc}draw_to_hdc(HDC dc, BITMAP *bitmap, int x, int y);\par }
{\li400 Draws an entire Allegro bitmap to a Windows device context, using the 
same parameters as the draw_sprite() function. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v blit_to_hdc}blit_to_hdc(BITMAP *bitmap, HDC dc, int sx, sy, dx, dy, w, h);\par }
{\li400 Blits an Allegro memory bitmap to a Windows device context, using the 
same parameters as the blit() function. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v stretch_blit_to_hdc}stretch_blit_to_hdc(BITMAP *bitmap, HDC dc, int sx, sy, sw, sh, int dx, dy, dw, dh);\par }
{\li400 Blits an Allegro memory bitmap to a Windows device context, using the 
same parameters as the stretch_blit() function. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v blit_from_hdc}blit_from_hdc(HDC hdc, BITMAP *bitmap, int sx, sy, dx, dy, w, h);\par }
{\li400 Blits from a Windows device context to an Allegro memory bitmap, using 
the same parameters as the blit() function. See stretch_blit_from_hdc() 
for details. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v stretch_blit_from_hdc}stretch_blit_from_hdc(HDC hcd, BITMAP *bitmap, int sx, sy, sw, sh, int dx, dy, dw, dh);\par }
{\li400 Blits from a Windows device context to an Allegro memory bitmap, using 
the same parameters as the stretch_blit() function. It uses the current 
Allegro palette and does conversion to this palette, regardless of the 
current DC palette. So if you are blitting from 8-bit mode, you should 
first set the DC palette with the set_palette_to_hdc() function. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Unix specifics}Unix specifics\par }
Under Unix you usually have two ways of redistributing your binaries. You 
either pack everything in a single directory, even providing Allegro in 
binary or source form for the user to compile. Or your program is being 
packaged separately from Allegro and stored in different paths. For the 
first case of redistribution, read section "Files shared by Allegro" from 
the "Dos specifics" chapter to learn more about this. 
\par \par For the second type, you can ignore redistributing the setup, keyboard 
mappings and language datafiles, because they will be already installed in 
the system. This, however, is problematic if you are using get_config_text() 
to localise your program's text strings. 
\par \par The problem is that on other platforms you usually mix your program's text 
strings with those of Allegro (found in the `resources' directory) to create 
a special language.dat. And it is likely that the Allegro library installed 
on the user's system already contains a datafile.dat. You can go ahead and 
still provide your own language.dat file, but this will mean that if Allegro 
is updated, your language.dat file may not contain all the text strings used 
by the new version. 
\par \par Given the slow paced release cycle of Allegro, this might not be a concern. 
However, if you want to make it easy on system administrators, instead of 
providing your own `language.dat', you should provide the separate 
`xxtext.cfg' files it in a separate directory. Then, before showing the 
strings to the user you can detect the language setting and use 
override_config_file() with the appropriate localisation file and call 
reload_config_texts(). 
\par \par In order to locate things like the config and translation files, Allegro 
needs to know the path to your executable. Since there is no standard way to 
find that, it needs to capture a copy of your argv[] parameter, and it does 
this with some preprocessor macro trickery. Unfortunately it can't quite 
pull this off without a little bit of your help, so you will have to write 
END_OF_MAIN() right after your main() function. Pretty easy, really, and if 
you forget, you'll get a nice linker error about a missing _mangled_main 
function to remind you :-) 
\par \par Under Unix resources are searched for in many different paths (see above). 
When a configuration resource is looked for, it is usually tried with the 
variations `name.cfg' or `.namerc' in multiple paths: the current directory, 
the directory pointed to by the ALLEGRO environment variable, the user's home 
directory, one or more global system directories which usually only the 
root user has access to and any custom paths set up with 
set_allegro_resource_path(). Text files, like the main allegro config file or 
a language text translation files are looked for in the following places: 
\par {\s1 \f1\fs18 
\par    ./allegro.cfg
\par    $ALLEGRO/allegro.cfg
\par    ~/allegro.cfg
\par    ~/.allegrorc
\par    /etc/allegro.cfg
\par    /etc/allegrorc
\par }\par Binary resources like the language translation files packfile (language.dat) 
are looked for in: 
\par {\s1 \f1\fs18 
\par    ./language.dat
\par    $ALLEGRO/language.dat
\par    ~/language.dat
\par    /etc/language.dat
\par    /usr/share/allegro/language.dat
\par    /usr/local/share/allegro/language.dat
\par }\par Note that if you have installed Allegro from the source distribution with 
the typical `make install', global files like `language.dat' and 
`allegro.cfg' will not have been installed. As a system administrator you are 
required to install them manually wherever you prefer to have them. If you 
suspect that an Allegro program is somehow not finding the correct 
configuration file, you could try using the following command: 
\par {\s1 \f1\fs18 
\par    strace program 2>&1|egrep "(open|stat)"
\par }\par The strace program traces system calls and signals. By default it outputs 
the information to stderr, so that's why we redirect it to stdin with `2>&1'. 
Since we are interested only in files being (un)successfully opened, we 
restrict the output of the log to stat or open calls with the extended grep 
command. You could add another grep to filter only lines with text like 
`language' or `allegro'. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v JOY_TYPE_*/Linux}JOY_TYPE_*/Linux\par }
{\li400 The Linux library supports the following type parameters for the 
install_joystick() function: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_AUTODETECT\par \pard \li800 
Attempts to autodetect your joystick hardware. It will use information 
from the configuration file if one is available (this can be created 
using the setup utility or by calling the save_joystick_data() 
function), so you can always use JOY_TYPE_AUTODETECT in your code and 
then select the exact hardware type from the setup program. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_NONE\par \pard \li800 
Dummy driver for machines without any joystick. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 JOY_TYPE_LINUX_ANALOGUE\par \pard \li800 
Regular joystick interface. Joystick support needs to be enabled in your 
kernel. 
\par}\par}\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v GFX_*/Linux}GFX_*/Linux\par }
{\li400 When running in Linux console mode, Allegro supports the following card 
parameters for the set_gfx_mode() function: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_TEXT\par \pard \li800 
Return to text mode. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT\par \pard \li800 
Let Allegro pick an appropriate graphics driver. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT_FULLSCREEN\par \pard \li800 
Autodetects a graphics driver, but will only use fullscreen drivers, 
failing if these are not available on current platform. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT_WINDOWED\par \pard \li800 
Same as above, but uses only windowed drivers. This will always fail 
under Linux console mode. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_SAFE\par \pard \li800 
Special driver for when you want to reliably set a graphics mode and 
don't really care what resolution or color depth you get. See the 
set_gfx_mode() documentation for details. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_FBCON\par \pard \li800 
Use the framebuffer device (eg. /dev/fb0). This requires you to have 
framebuffer support compiled into your kernel, and correctly 
configured for your hardware. It is currently the only console mode 
driver that will work without root permissions, unless you are using 
a development version of SVGAlib. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_VBEAF\par \pard \li800 
Use a VBE/AF driver (vbeaf.drv), assuming that you have installed one 
which works under Linux (currently only two of the FreeBE/AF project 
drivers are capable of this: I don't know about the SciTech ones). 
VBE/AF requires root permissions, but is currently the only Linux 
driver which supports hardware accelerated graphics. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_SVGALIB\par \pard \li800 
Use the SVGAlib library for graphics output. This requires root 
permissions if your version of SVGAlib requires them. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_VGA\par \pard \li800 
GFX_MODEX\par 
Use direct hardware access to set standard VGA or mode-X resolutions, 
supporting the same modes as in the DOS versions of these drivers. 
Requires root permissions. 
\par}\par}{\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v GFX_*/X}GFX_*/X\par }
{\li400 When running in X mode, Allegro supports the following card parameters 
for the set_gfx_mode() function: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_TEXT\par \pard \li800 
This closes any graphics mode previously opened with set_gfx_mode. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT\par \pard \li800 
Let Allegro pick an appropriate graphics driver. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT_FULLSCREEN\par \pard \li800 
Autodetects a graphics driver, but will only use fullscreen drivers, 
failing if these are not available on current platform. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT_WINDOWED\par \pard \li800 
Same as above, but uses only windowed drivers. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_SAFE\par \pard \li800 
Special driver for when you want to reliably set a graphics mode and 
don't really care what resolution or color depth you get. See the 
set_gfx_mode() documentation for details. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_XWINDOWS\par \pard \li800 
The standard X graphics driver. This should work on any Unix system, 
and can operate remotely. It does not require root permissions. 
If the ARGB cursor extension is available, this driver is capable 
of displaying a hardware cursor. This needs to be enabled by calling 
enable_hardware_cursor() because it cannot be used reliably alongside 
get_mouse_mickeys(). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_XWINDOWS_FULLSCREEN\par \pard \li800 
The same as above, but while GFX_XWINDOWS runs windowed, this one uses 
the XF86VidMode extension to make it run in fullscreen mode even 
without root permissions. You're still using the standard X protocol 
though, so expect the same low performances as with the windowed 
driver version. 
If the ARGB cursor extension is available, this driver is capable 
of displaying a hardware cursor. This needs to be enabled by calling 
enable_hardware_cursor() because it cannot be used reliably alongside 
get_mouse_mickeys(). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_XDGA2\par \pard \li800 
Use new DGA 2.0 extension provided by XFree86 4.0.x. This will work 
in fullscreen mode, and it will support hardware acceleration if 
available. This driver requires root permissions. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_XDGA2_SOFT\par \pard \li800 
The same as GFX_XDGA2, but turns off hardware acceleration support. 
This driver requires root permissions. 
\par}\par}{\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v DIGI_*/Unix}DIGI_*/Unix\par }
{\li400 The Unix sound functions support the following digital sound cards: 
\par {\s1 \f1\fs18 
\par       DIGI_AUTODETECT      - let Allegro pick a digital sound driver
\par       DIGI_NONE            - no digital sound
\par       DIGI_OSS             - Open Sound System
\par       DIGI_ESD             - Enlightened Sound Daemon
\par       DIGI_ARTS            - aRts (Analog Real-Time Synthesizer)
\par       DIGI_ALSA            - ALSA sound driver
\par       DIGI_JACK            - JACK sound driver\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v MIDI_*/Unix}MIDI_*/Unix\par }
{\li400 The Unix sound functions support the following MIDI sound cards: 
\par {\s1 \f1\fs18 
\par       MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
\par       MIDI_NONE            - no MIDI sound
\par       MIDI_OSS             - Open Sound System
\par       MIDI_DIGMID          - sample-based software wavetable player
\par       MIDI_ALSA            - ALSA RawMIDI driver\par}
\par}\brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v Unix integration routines}
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v xwin_set_window_name}xwin_set_window_name(const char *name, const char *group);\par }
{\li400 This function is only available under X. It lets you to specify the 
window name and group (or class). They are important because they allow 
the window manager to remember the window attributes (position, layer, 
etc). Note that the name and the title of the window are two different 
things: the title is what appears in the title bar of the window, but 
usually has no other effects on the behaviour of the application. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b extern void *{\xe\v allegro_icon}allegro_icon;\par }
{\li400 This is a pointer to the Allegro X11 icon, which is in the format of 
standard .xpm bitmap data. 
You do not normally have to bother with this at all: you can use the 
xfixicon.sh utility from the tools/x11 directory to convert a true 
colour bitmap to a C file that you only need to link with your own code 
to set the icon. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v BeOS specifics}BeOS specifics\par }
In terms of file redistribution, the BeOS platform behaves practically the 
same as the DOS platform. Read section chapter "Dos specifics" in the manual 
to learn more about this. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v GFX_*/BeOS}GFX_*/BeOS\par }
{\li400 BeOS Allegro supports the following card parameters for the 
set_gfx_mode() function: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_TEXT\par \pard \li800 
This closes any graphics mode previously opened with set_gfx_mode. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT\par \pard \li800 
Let Allegro pick an appropriate graphics driver. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT_FULLSCREEN\par \pard \li800 
Autodetects a graphics driver, but will only use fullscreen drivers, 
failing if these are not available on current platform. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT_WINDOWED\par \pard \li800 
Same as above, but uses only windowed drivers. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_SAFE\par \pard \li800 
Special driver for when you want to reliably set a graphics mode and 
don't really care what resolution. See the set_gfx_mode() 
documentation for details. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_BWINDOWSCREEN_ACCEL\par \pard \li800 
Fullscreen exclusive mode. Supports only resolutions higher or equal 
to 640x480, and uses hardware acceleration if available. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_BWINDOWSCREEN\par \pard \li800 
Works the same as GFX_BWINDOWSCREEN_ACCEL, but disables acceleration. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_BDIRECTWINDOW\par \pard \li800 
Fast windowed mode using the BDirectWindow class. Not all graphics 
cards support this. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_BWINDOW\par \pard \li800 
Normal windowed mode using the BWindow class. Slow but always works. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_BWINDOW_OVERLAY\par \pard \li800 
Fullscreen mode using BWindow with a BBitmap overlay. This mode isn't 
supported by all graphics cards, only supports 15, 16 and 32-bit color 
depths, but allows any fullscreen resolution, even low ones that are 
normally unavailable under BeOS. 
\par}\par}{\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v DIGI_*/BeOS}DIGI_*/BeOS\par }
{\li400 The BeOS sound functions support the following digital sound cards: 
\par {\s1 \f1\fs18 
\par       DIGI_AUTODETECT      - let Allegro pick a digital sound driver
\par       DIGI_NONE            - no digital sound
\par       DIGI_BEOS            - BeOS digital output\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v MIDI_*/BeOS}MIDI_*/BeOS\par }
{\li400 The BeOS sound functions support the following MIDI sound cards: 
\par {\s1 \f1\fs18 
\par       MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
\par       MIDI_NONE            - no MIDI sound
\par       MIDI_BEOS            - BeOS MIDI output
\par       MIDI_DIGMID          - sample-based software wavetable player
\par \par}}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v QNX specifics}QNX specifics\par }
In terms of file redistribution, the QNX platform behaves practically the 
same as the DOS platform. Read section chapter "Dos specifics" in the manual 
to learn more about this. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v GFX_*/QNX}GFX_*/QNX\par }
{\li400 QNX Allegro supports the following card parameters for the 
set_gfx_mode() function: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_TEXT\par \pard \li800 
This closes any graphics mode previously opened with set_gfx_mode. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT\par \pard \li800 
Let Allegro pick an appropriate graphics driver. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT_FULLSCREEN\par \pard \li800 
Autodetects a graphics driver, but will only use fullscreen drivers, 
failing if these are not available on current platform. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT_WINDOWED\par \pard \li800 
Same as above, but uses only windowed drivers. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_SAFE\par \pard \li800 
Special driver for when you want to reliably set a graphics mode and 
don't really care what resolution. See the set_gfx_mode() 
documentation for details. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_PHOTON\par \pard \li800 
Alias for GFX_PHOTON_ACCEL. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_PHOTON_ACCEL\par \pard \li800 
Fullscreen exclusive mode through Photon, running with hardware 
acceleration enabled. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_PHOTON_SOFT\par \pard \li800 
Fullscreen exclusive mode that only uses software drawing, rather than 
any hardware accelerated features. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_PHOTON_SAFE\par \pard \li800 
Simplified fullscreen exclusive driver that doesn't support any 
hardware acceleration, video or system bitmaps, etc. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_PHOTON_WIN\par \pard \li800 
The regular windowed Photon driver, running in color conversion mode 
when the color depth doesn't match that of the Photon desktop. Color 
conversion is much slower than direct drawing. Note that, mainly for 
performance reasons, this driver requires the width of the screen to 
be a multiple of 4. 
\par}\par}{\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v DIGI_*/QNX}DIGI_*/QNX\par }
{\li400 The QNX sound functions support the following digital sound cards: 
\par {\s1 \f1\fs18 
\par       DIGI_AUTODETECT      - let Allegro pick a digital sound driver
\par       DIGI_NONE            - no digital sound
\par       DIGI_ALSA            - ALSA sound driver\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v MIDI_*/QNX}MIDI_*/QNX\par }
{\li400 The QNX sound functions support the following MIDI sound cards: 
\par {\s1 \f1\fs18 
\par       MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
\par       MIDI_NONE            - no MIDI sound
\par       MIDI_ALSA            - ALSA RawMIDI driver
\par       MIDI_DIGMID          - sample-based software wavetable player
\par \par}}\par \par \brdrb\brdrs\brdrw15\brsp20 \par \pard \par \par {\xe\v QNX integration routines}
\par \par The following functions provide a platform specific interface to seamlessly 
integrate Allegro into general purpose QNX programs. To use these routines, 
you must include qnxalleg.h after other Allegro headers. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b PtWidget_t {\xe\v qnx_get_window}qnx_get_window(void);\par }
{\li400 Retrieves a handle to the window used by Allegro. Note that Allegro 
uses an underlying window even though you don't set any graphics mode, 
unless you have installed the neutral system driver (SYSTEM_NONE). 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v MacOS X specifics}MacOS X specifics\par }
In terms of file redistribution, the MacOS X platform behaves practically the 
same as the DOS platform. Read section chapter "Dos specifics" in the manual 
to learn more about this. 
\par \par Allegro programs under MacOS X are Cocoa applications; in order to hide all 
the Cocoa interfacing to the end-user, you need to add the END_OF_MAIN() 
macro right after your main() function. This is a necessary step: if you omit 
it, your program will not compile. 
\par \par The END_OF_MAIN() macro simply does some magic to make sure your program 
executes another function before your main(); this function is defined into 
the liballeg-main.a static library, which is automatically linked if you use 
the allegro-config script when linking. Otherwise be sure you link against it 
unless you want to get undefined symbol errors. 
\par \par To behave nicely with the MacOS X user interface, Allegro apps will provide a 
standard application menu with the "Quit" menu item in it. The default 
behaviour when the user hits Command-Q or selects "Quit" is to do nothing. 
To override this behaviour you must call the set_close_button_callback() function; under MacOS 
X the supplied callback will be used either if the user clicks the window 
close button either on Command-Q or "Quit" selection. In this last case the 
application will not shutdown, but you are supposed to set some quit flag 
in your callback and check for it on a regular basis in your main program 
loop. 
\par \par If you would like to use InterfaceBuilder to design a more 
fully-featured menu, Allegro will automatically load it if you create 
a bundle for your application. The use of InterfaceBuilder is beyond 
the scope of this document. Briefly, you need to create a Nib, called 
MainMenu.nib, containing a main menu and a controller. Then, when you 
create the bundle, install MainMenu.nib into the Contents/Resources 
subdirectory. Note that the actions attached to the menu items will be 
called from a different thread than the one in which your Allegro code 
is running. Therefore you should not do any work there (especially, 
don't call Allegro functions.) Instead, set a variable, and test it in 
your main loop. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v GFX_*/MacOSX}GFX_*/MacOSX\par }
{\li400 MacOS X Allegro supports the following card parameters for the 
set_gfx_mode() function: 
\par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_TEXT\par \pard \li800 
This closes any graphics mode previously opened with set_gfx_mode. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT\par \pard \li800 
Let Allegro pick an appropriate graphics driver. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT_FULLSCREEN\par \pard \li800 
Autodetects a graphics driver, but will only use fullscreen drivers, 
failing if these are not available on current platform. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_AUTODETECT_WINDOWED\par \pard \li800 
Same as above, but uses only windowed drivers. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_SAFE\par \pard \li800 
Special driver for when you want to reliably set a graphics mode and 
don't really care what resolution. See the set_gfx_mode() 
documentation for details. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_QUARTZ_FULLSCREEN\par \pard \li800 
Fullscreen exclusive mode, using the CGDirectDisplay interface. 
Supports only resolutions higher or equal to 640x480, and uses 
hardware acceleration if available. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 GFX_QUARTZ_WINDOW\par \pard \li800 
Windowed mode using QuickDraw in a Cocoa window. 
\par}\par}{\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v DIGI_*/MacOSX}DIGI_*/MacOSX\par }
{\li400 The MacOS X sound functions support the following digital sound cards: 
\par {\s1 \f1\fs18 
\par       DIGI_AUTODETECT      - let Allegro pick a digital sound driver
\par       DIGI_NONE            - no digital sound
\par       DIGI_CORE_AUDIO      - CoreAudio digital output (OS >= X.2 required)
\par       DIGI_SOUND_MANAGER   - Carbon Sound Manager digital output
\par \par}}\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b Drivers {\xe\v MIDI_*/MacOSX}MIDI_*/MacOSX\par }
{\li400 The MacOS X sound functions support the following MIDI sound cards: 
\par {\s1 \f1\fs18 
\par       MIDI_AUTODETECT      - let Allegro pick a MIDI sound driver
\par       MIDI_NONE            - no MIDI sound
\par       MIDI_CORE_AUDIO      - CoreAudio MIDI synthesizer (OS >= X.2 required)
\par       MIDI_QUICKTIME       - QuickTime Music Note Allocator MIDI output
\par       MIDI_DIGMID          - sample-based software wavetable player
\par \par}}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Differences between platforms}Differences between platforms\par }
Here's a quick summary of things that may cause problems when moving your 
code from one platform to another (you can find a more detailed version of 
this in the docs section of the Allegro website). 
\par \par The Windows, Unix and MacOS X versions require you to write END_OF_MAIN() 
after your main() function. This is used to magically turn an ISO C style 
main() into a Windows style WinMain(), or by the Unix code to grab a copy 
of your argv[] parameter, or by the MacOS X code to shell the user main() 
inside a Cocoa application. 
\par \par On many platforms Allegro runs very slowly if you rely on it in order to 
automatically lock bitmaps when drawing onto them. For good performance, 
you need to call acquire_bitmap() and release_bitmap() yourself, and try 
to keep the amount of locking to a minimum. 
\par \par The Windows version may lose the contents of video memory if the user 
switches away from your program, so you need to deal with that. 
\par \par None of the currently supported platforms require input polling, but it is 
possible that some future ones might, so if you want to ensure 100% 
portability of your program, you should call poll_mouse() and 
poll_keyboard() in all the relevant places. 
\par \par On Unix the shared files by Allegro (like `language.dat') may require a 
special use due to the nature of distributing the resources in separate paths 
instead of putting everything in the same directory. Check the beginning of 
your platform's specific chapter to learn more about this. 
\par \par Allegro defines a number of standard macros that can be used to check 
various attributes of the current platform: 
\par \par {\b ALLEGRO_PLATFORM_STR\par}
Text string containing the name of the current platform. 
\par \par {\b ALLEGRO_DOS\par}
{\b ALLEGRO_DJGPP\par}
{\b ALLEGRO_WATCOM\par}
{\b ALLEGRO_WINDOWS\par}
{\b ALLEGRO_MSVC\par}
{\b ALLEGRO_MINGW32\par}
{\b ALLEGRO_BCC32\par}
{\b ALLEGRO_UNIX\par}
{\b ALLEGRO_LINUX\par}
{\b ALLEGRO_BEOS\par}
{\b ALLEGRO_QNX\par}
{\b ALLEGRO_DARWIN\par}
{\b ALLEGRO_MACOSX\par}
{\b ALLEGRO_GCC\par}
Defined if you are building for a relevant system. Often several of these 
will apply, eg. DOS+Watcom, or Windows+GCC+MinGW. 
\par \par Note that ALLEGRO_LINUX is a misnomer. It will only be defined if 
{\i Linux console\par}\par  support is enabled. It is not a reliable way to check 
if the program is being built on a Linux system. 
\par \par {\b ALLEGRO_AMD64\par}
{\b ALLEGRO_I386\par}
{\b ALLEGRO_BIG_ENDIAN\par}
{\b ALLEGRO_LITTLE_ENDIAN\par}
Defined if you are building for a processor of the relevant type. 
\par \par {\b ALLEGRO_MULTITHREADED\par}
Defined if the library is internally multi-threaded on this system. 
\par \par {\b ALLEGRO_USE_CONSTRUCTOR\par}
Defined if the compiler supports constructor/destructor functions. 
\par \par {\b ALLEGRO_VRAM_SINGLE_SURFACE\par}
Defined if the screen is a single large surface that is then partitioned 
into multiple video sub-bitmaps (eg. DOS), rather than each video bitmap 
being a totally unique entity (eg. Windows). 
\par \par {\b ALLEGRO_CONSOLE_OK\par}
Defined if when you are not in a graphics mode, there is a text mode 
console that you can printf() to, and from which the user could 
potentially redirect stdout to capture it even while you are in a 
graphics mode. If this define is absent, you are running in an 
environment like Windows that has no stdout at all. 
\par \par {\b ALLEGRO_MAGIC_MAIN\par}
Defined if Allegro uses a magic main, i.e takes over the main() entry 
point and turns it into a secondary entry point suited to its needs. 
\par \par {\b ALLEGRO_LFN\par}
Non-zero if long filenames are supported, or zero if you are limited to 
8.3 format (in the DJGPP version, this is a variable depending on the 
runtime environment). 
\par \par {\b LONG_LONG\par}
Defined to whatever represents a 64-bit "long long" integer for the 
current compiler, or not defined if that isn't supported. 
\par \par {\b OTHER_PATH_SEPARATOR\par}
Defined to a path separator character other than a forward slash for 
platforms that use one (eg. a backslash under DOS and Windows), or 
defined to a forward slash if there is no other separator character. 
\par \par {\b DEVICE_SEPARATOR\par}
Defined to the filename device separator character (a colon for DOS and 
Windows), or to zero if there are no explicit devices in paths (Unix). 
\par \par Allegro can be customized at compile time to a certain extent with the 
following macros: 
\par \par {\b ALLEGRO_NO_MAGIC_MAIN\par}
If you define this prior to including Allegro headers, Allegro won't 
touch the main() entry point. This effectively removes the requirement 
on a program to be linked against the Allegro library when it includes 
the allegro.h header file. Note that the configuration and file routines 
are not guaranteed to work on Unix systems when this symbol is defined. 
Moreover, on Darwin/MacOS X systems, this symbol simply prevents the 
program from being linked against the Allegro library! This highly non 
portable feature is primarily intended to be used under Windows. 
\par \par {\b ALLEGRO_USE_CONSOLE\par}
If you define this prior to including Allegro headers, Allegro will be 
set up for building a console application rather than the default GUI 
program on some platforms (especially Windows). 
\par \par {\b ALLEGRO_NO_STD_HEADER\par}
If you define this prior to including Allegro headers, Allegro will not 
automatically include some standard headers (eg <stddef.h>) its own 
headers depend upon. 
\par \par {\b ALLEGRO_NO_KEY_DEFINES\par}
If you define this prior to including Allegro headers, Allegro will omit 
the definition of the KEY_* constants, which may clash with other headers. 
\par \par {\b ALLEGRO_NO_FIX_ALIASES\par}
The fixed point functions used to be named with an "f" prefix instead of 
"fix", eg. fixsqrt() used to be fsqrt(), but were renamed due to conflicts 
with some libc implementations. So backwards compatibility aliases are 
provided as static inline functions which map the old names to the new 
names, eg. fsqrt() calls fixsqrt(). If you define this symbol prior to 
including Allegro headers, the aliases will be turned off. 
\par \par {\b ALLEGRO_NO_FIX_CLASS\par}
If you define this symbol prior to including Allegro headers in a C++ 
source file, the 'fix' class will not be made available. This mitigates 
problems with the 'fix' class's overloading getting in the way. 
\par \par {\b ALLEGRO_NO_VHLINE_ALIAS\par}
The `curses' API also defines functions called vline() and hline(). 
To avoid a linker conflict when both libraries are used, we have 
internally renamed our functions and added inline function aliases which 
remap vline() and hline(). This should not be noticeable to most users. 
\par \par If you define ALLEGRO_NO_VHLINE_ALIAS prior to including Allegro headers, 
Allegro will not define the vline() and hline() aliases, e.g. so you can 
include curses.h and allegro.h in the same module. 
\par \par {\b ALLEGRO_NO_CLEAR_BITMAP_ALIAS\par}
If you define this prior to including Allegro headers, Allegro will not 
define the clear() backwards compatibility alias to clear_bitmap(). 
\par \par {\b ALLEGRO_NO_COMPATIBILITY\par}
If you define this prior to including Allegro headers, Allegro will not 
include the backward compatibility layer. It is undefined by default so 
old programs can still be compiled with the minimum amount of issues, 
but you should define this symbol if you intend to maintain your code 
up to date with the latest versions of Allegro. It automatically turns 
off all backwards compatibility aliases. 
\par \par Allegro also defines a number of standard macros that can be used to 
insulate you from some of the differences between systems: 
\par \par {\b INLINE\par}
Use this in place of the regular "inline" function modifier keyword, and 
your code will work correctly on any of the supported compilers. 
\par \par {\b RET_VOLATILE\par}
Use this to declare a function with a volatile return value. 
\par \par {\b ZERO_SIZE_ARRAY(type, name)\par}
Use this to declare zero-sized arrays in terminal position inside 
structures, like in the BITMAP structure. These arrays are effectively 
equivalent to the flexible array members of ISO C99. 
\par \par {\b AL_CONST\par}
Use this in place of the regular "const" object modifier keyword, and 
your code will work correctly on any of the supported compilers. 
\par \par {\b AL_RAND()\par}
On platforms that require it, this macro does a simple shift 
transformation of the libc rand() function, in order to improve the 
perceived randomness of the output series in the lower 16 bits. 
Where not required, it directly translates into a rand() call. 
\par \par \par \par \par {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Reducing your executable size}Reducing your executable size\par }
Some people complain that Allegro produces very large executables. This is 
certainly true: with the DJGPP version, a simple "hello world" program will 
be about 200k, although the per-executable overhead is much less for 
platforms that support dynamic linking. But don't worry, Allegro takes up a 
relatively fixed amount of space, and won't increase as your program gets 
larger. As George Foot so succinctly put it, anyone who is concerned about 
the ratio between library and program code should just get to work and write 
more program code to catch up :-) 
\par \par Having said that, there are several things you can do to make your programs 
smaller: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 For all platforms, you can use an executable compressor called UPX, which 
is available at http://upx.sourceforge.net/. This usually manages a 
compression ratio of about 40%. 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 When using DJGPP: for starters, read the DJGPP FAQ section 8.14, and take 
note of the -s switch. And don't forget to compile your program with 
optimisation enabled! 
\par \pard \li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 If a DOS program is only going to run in a limited number of graphics modes, 
you can specify which graphics drivers you would like to include with the 
code: 
\par {\s1 \f1\fs18 \pard \li400 
\par    BEGIN_GFX_DRIVER_LIST
\par       driver1
\par       driver2
\par       etc...
\par    END_GFX_DRIVER_LIST
\par }\pard \li400 \par where the driver names are any of the defines: 
\par {\s1 \f1\fs18 
\par    GFX_DRIVER_VBEAF
\par    GFX_DRIVER_VGA
\par    GFX_DRIVER_MODEX
\par    GFX_DRIVER_VESA3
\par    GFX_DRIVER_VESA2L
\par    GFX_DRIVER_VESA2B
\par    GFX_DRIVER_XTENDED
\par    GFX_DRIVER_VESA1
\par }\pard \li400 \par This construct must be included in only one of your C source files. The 
ordering of the names is important, because the autodetection routine works 
down from the top of the list until it finds the first driver that is able 
to support the requested mode. I suggest you stick to the default ordering 
given above, and simply delete whatever entries you aren't going to use. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 If your DOS program doesn't need to use all the possible color depths, you 
can specify which pixel formats you want to support with the code: 
\par {\s1 \f1\fs18 \pard \li400 
\par    BEGIN_COLOR_DEPTH_LIST
\par       depth1
\par       depth2
\par       etc...
\par    END_COLOR_DEPTH_LIST
\par }\pard \li400 \par where the color depth names are any of the defines: 
\par {\s1 \f1\fs18 
\par    COLOR_DEPTH_8
\par    COLOR_DEPTH_15
\par    COLOR_DEPTH_16
\par    COLOR_DEPTH_24
\par    COLOR_DEPTH_32
\par }\pard \li400 \par Removing any of the color depths will save quite a bit of space, with the 
exception of the 15 and 16-bit modes: these share a great deal of code, so 
if you are including one of them, there is no reason not to use both. Be 
warned that if you try to use a color depth which isn't in this list, your 
program will crash horribly! 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 In the same way as the above, you can specify which DOS sound drivers you 
want to support with the code: 
\par {\s1 \f1\fs18 \pard \li400 
\par    BEGIN_DIGI_DRIVER_LIST
\par       driver1
\par       driver2
\par       etc...
\par    END_DIGI_DRIVER_LIST
\par }\pard \li400 \par using the digital sound driver defines: 
\par {\s1 \f1\fs18 
\par    DIGI_DRIVER_SOUNDSCAPE
\par    DIGI_DRIVER_AUDIODRIVE
\par    DIGI_DRIVER_WINSOUNDSYS
\par    DIGI_DRIVER_SB
\par }\pard \li400 \par and for the MIDI music: 
\par {\s1 \f1\fs18 
\par    BEGIN_MIDI_DRIVER_LIST
\par       driver1
\par       driver2
\par       etc...
\par    END_MIDI_DRIVER_LIST
\par }\pard \li400 \par using the MIDI driver defines: 
\par {\s1 \f1\fs18 
\par    MIDI_DRIVER_AWE32
\par    MIDI_DRIVER_DIGMID
\par    MIDI_DRIVER_ADLIB
\par    MIDI_DRIVER_MPU
\par    MIDI_DRIVER_SB_OUT
\par }\pard \li400 \par If you are going to use either of these sound driver constructs, you must 
include both. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 Likewise for the DOS joystick drivers, you can declare an inclusion list: 
\par {\s1 \f1\fs18 \pard \li400 
\par    BEGIN_JOYSTICK_DRIVER_LIST
\par       driver1
\par       driver2
\par       etc...
\par    END_JOYSTICK_DRIVER_LIST
\par }\pard \li400 \par using the joystick driver defines: 
\par {\s1 \f1\fs18 
\par    JOYSTICK_DRIVER_WINGWARRIOR
\par    JOYSTICK_DRIVER_SIDEWINDER
\par    JOYSTICK_DRIVER_GAMEPAD_PRO
\par    JOYSTICK_DRIVER_GRIP
\par    JOYSTICK_DRIVER_STANDARD
\par    JOYSTICK_DRIVER_SNESPAD
\par    JOYSTICK_DRIVER_PSXPAD
\par    JOYSTICK_DRIVER_N64PAD
\par    JOYSTICK_DRIVER_DB9
\par    JOYSTICK_DRIVER_TURBOGRAFX
\par    JOYSTICK_DRIVER_IFSEGA_ISA
\par    JOYSTICK_DRIVER_IFSEGA_PCI
\par    JOYSTICK_DRIVER_IFSEGA_PCI_FAST
\par }\pard \li400 \par The standard driver includes support for the dual joysticks, increased 
numbers of buttons, Flightstick Pro, and Wingman Extreme, because these are 
all quite minor variations on the basic code. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 If you are _really_ serious about this size, thing, have a look at the top 
of include/allegro/alconfig.h and you will see the lines: 
\par {\s1 \f1\fs18 \pard \li400 
\par    #define ALLEGRO_COLOR8
\par    #define ALLEGRO_COLOR16
\par    #define ALLEGRO_COLOR24
\par    #define ALLEGRO_COLOR32
\par }\pard \li400 \par If you comment out any of these definitions and then rebuild the library, 
you will get a version without any support for the absent color depths, 
which will be even smaller than using the DECLARE_COLOR_DEPTH_LIST() macro. 
Removing the ALLEGRO_COLOR16 define will get rid of the support for both 15 
and 16-bit hicolor modes, since these share a lot of the same code. 
\par}\par Note: the aforementioned methods for removing unused hardware drivers only 
apply to statically linked versions of the library, eg. DOS. On Windows and 
Unix platforms, you can build Allegro as a DLL or shared library, which 
prevents these methods from working, but saves so much space that you 
probably won't care about that. Removing unused color depths from alconfig.h 
will work on any platform, though. 
\par \par If you are distributing a copy of the setup program along with your game, 
you may be able to get a dramatic size reduction by merging the setup code 
into your main program, so that only one copy of the Allegro routines will 
need to be linked. See setup.txt for details. In the DJGPP version, after 
compressing the executable, this will probably save you about 200k compared 
to having two separate programs for the setup and the game itself. 
\par {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Debugging}Debugging\par }
There are three versions of the Allegro library: the normal optimised code, 
one with extra debugging support, and a profiling version. See the platform 
specific readme files for information about how to install and link with 
these alternative libs. Although you will obviously want to use the 
optimised library for the final version of your program, it can be very 
useful to link with the debug lib while you are working on it, because this 
will make debugging much easier, and includes assert tests that will help to 
locate errors in your code at an earlier stage. Allegro also contains some 
debugging helper functions: 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v ASSERT}ASSERT(condition);\par }
{\li400 Debugging helper macro. Normally compiles away to nothing, but if you 
defined the preprocessor symbol DEBUGMODE before including Allegro headers, 
it will check the supplied condition and call al_assert() if it fails, 
whose default action is to stop the program and report the assert. You can 
use this macro even when Allegro has not been initialised. Example: 
\par {\s1 \f1\fs18 
\par       #define DEBUGMODE
\par       #include 
\par       ...
\par       void my_blitter(BITMAP *source, int flags)
\par       \{
\par          int some_variables;
\par          ASSERT(source != NULL);
\par          ASSERT(flags & GAME_RUNNING);
\par          ...
\par       \}\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v TRACE}TRACE(char *msg, ...);\par }
{\li400 Debugging helper macro. Normally compiles away to nothing, but if you 
defined the preprocessor symbol DEBUGMODE before including Allegro headers, 
it passes the supplied message given in ASCII format to al_trace(). 
Example: 
\par {\s1 \f1\fs18 
\par       #define DEBUGMODE
\par       #include 
\par       ...
\par       void my_blitter(BITMAP *source, int flags)
\par       \{
\par          static int count_call = 0;
\par          TRACE("my_blitter() called %d times.\\n", count_call++);
\par          ...
\par       \}\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v register_assert_handler}register_assert_handler(int (*handler)(const char *msg));\par }
{\li400 Supplies a custom handler function for dealing with assert failures. Your 
callback will be passed a formatted error message in ASCII, and should 
return non-zero if it has processed the error, or zero to continue with 
the default actions. You could use this to ignore assert failures, or to 
display the error messages on a graphics mode screen without aborting the 
program. You can call this function even when Allegro has not been 
initialised. Example: 
\par {\s1 \f1\fs18 
\par    int show_but_continue(const char *text)
\par    \{
\par        alert("Uh oh...", "Fasten your seat belts.", text,
\par              "&Go on!", NULL, 'g', 0);
\par        return 1;
\par    \}
\par    ...
\par       register_assert(show_but_continue);
\par       ASSERT(0); /* This won't crash the program now. */\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v register_trace_handler}register_trace_handler(int (*handler)(const char *msg));\par }
{\li400 Supplies a custom handler function for dealing with trace output. Your 
callback will be passed a formatted error message in ASCII, and should 
return non-zero if it has processed the message, or zero to continue with 
the default actions. You could use this to ignore trace output, or to 
display the messages on a second monochrome monitor, etc. You can call 
this function even when Allegro has not been initialised. Example: 
\par {\s1 \f1\fs18 
\par    int network_broadcaster(const char *text)
\par    \{
\par       int f;
\par 
\par       for (int f = 0; f 
\par          send_msg_to_client(client[f], text);
\par          
\par       return 0; /* Let normal tracing occur. */
\par    \}
\par    ...
\par       register_trace_handler(network_broadcaster);
\par       TRACE("Networked tracing activated\\n");\par}
\par}{\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v al_assert}al_assert(const char *file, int line);\par }
{\li400 Raises an assert for an error at the specified file and line number. The 
file parameter is always given in ASCII format. By default, this will call 
the system driver's assert handler. If there is none, the error will be 
sent to stderr and the program will abort. However, if the environment 
variable ALLEGRO_ASSERT is set, this function writes a message into the 
file specified by the environment variable and program execution will 
continue. If none of this behaviours is wanted, you can override them with 
a custom assert handler. 
\par \par You will usually want to use the ASSERT() macro instead of calling this 
function directly. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b void {\xe\v al_trace}al_trace(const char *msg, ...);\par }
{\li400 Outputs a debugging trace message, using a printf() format string given 
in ASCII. If you have installed a custom trace handler it uses that, or 
if the environment variable ALLEGRO_TRACE is set it writes into the file 
specified by the environment, otherwise it writes the message to 
"allegro.log" in the current directory. You will usually want to use the 
TRACE() macro instead of calling this function directly. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Makefile targets}Makefile targets\par }
There are a number of options that you can use to control exactly how 
Allegro will be compiled. On Unix platforms, you do this by passing arguments 
to the configure script (run "configure --help" for a list), but on other 
platforms you can set the following environment variables: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 DEBUGMODE=1\par \pard \li400 
Selects a debug build, rather than the normal optimised version. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 DEBUGMODE=2\par \pard \li400 
Selects a build intended to debug Allegro itself, rather than the 
normal optimised version. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 PROFILEMODE=1\par \pard \li400 
Selects a profiling build, rather than the normal optimised version. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 WARNMODE=1\par \pard \li400 
Selects strict compiler warnings. If you are planning to work on Allegro 
yourself, rather than just using it in your programs, you should be sure 
to have this mode enabled. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 STATICLINK=1 (MinGW, MSVC, BeOS, MacOS X only)\par \pard \li400 
Link as a static library, rather than the default dynamic library. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 STATICRUNTIME=1 (MSVC only)\par \pard \li400 
Link against static runtime libraries, rather than the default dynamic 
runtime libraries. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 TARGET_ARCH_COMPAT=[cpu] (GCC-based platforms only)\par \pard \li400 
This option will optimize for the given processor while maintaining 
compatibility with older processors. 
Example: set TARGET_ARCH_COMPAT=i586 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 TARGET_ARCH_EXCL=[cpu] (GCC-based platforms only)\par \pard \li400 
This option will optimize for the given processor. Please note that 
using it will cause the code to *NOT* run on older processors. 
Example: set TARGET_ARCH_EXCL=i586 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 TARGET_OPTS=[opts] (GCC-based platforms only)\par \pard \li400 
This option allows you to customize general compiler optimisations. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 TARGET_ARCH_EXCL=[opts] (MSVC only)\par \pard \li400 
This option allows you to optimize exclusively for a given architecture. 
Pass B to optimize for a PentiumPro or 7 to optimize for Pentium 4. Note 
that the options you can pass may be different between MSVC 6 and 7. 
Example: set TARGET_ARCH_EXCL=7 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 CROSSCOMPILE=1 (DJGPP, MinGW only)\par \pard \li400 
Allows you to build the library under Linux by using a cross-compiler. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 ALLEGRO_USE_C=1 (GCC-based platforms only)\par \pard \li400 
Allows you to build the library using C drawing code instead of the usual 
asm routines. This is only really useful for testing, since the asm 
version is faster. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 UNIX_TOOLS=1\par \pard \li400 
Instructs the build process to use Unix-like tools instead of DOS tools. 
Note that you usually don't need to set it because the build process will 
try to autodetect this configuration. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 COMPILER_MSVC7=1 (MSVC only)\par \pard \li400 
Enables special optimizations for MSVC 7 (the default is MSVC 6). You don't 
normally need to set this flag since {\i fix.bat msvc7\par}\par  should do the same 
thing and is the preferred way of doing this. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 COMPILER_ICL=1 (MSVC only)\par \pard \li400 
Instructs the build process to use the Intel command line compiler icl rather 
than Microsoft's command line compiler cl. You don't normally need to pass 
this flag since {\i fix.bat icl\par}\par  should do the same thing and is the 
preferred way of doing this. Do not try COMPILER_MSVC7=1 and COMPILER_ICL=1 
at the same time. 
\par}\par If you only want to recompile a specific test program or utility, you can 
specify it as an argument to make, eg. "make demo" or "make grabber". The 
makefiles also provide some special pseudo-targets: 
\par {\li400 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'info' (Unix only)\par \pard \li400 
Tells you which options this particular build of Allegro will use. 
Especially useful to verify that the required libraries were detected 
and you won't get a 'half-featured' Allegro. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'default'\par \pard \li400 
The normal build process. Compiles the current library version (one of 
optimised, debugging, or profiling, selected by the above environment 
variables), builds the test and example programs, and converts the 
documentation files. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'all' (non-Unix only)\par \pard \li400 
Compiles all three library versions (optimised, debugging, and 
profiling), builds the test and example programs, and converts the 
documentation files. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'lib'\par \pard \li400 
Compiles the current library version (one of optimised, debugging, or 
profiling, selected by the above environment variables). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'modules' (Unix only)\par \pard \li400 
This will compile all the modules currently configured. The 'lib' and 
'modules' targets together are needed to build a working copy of the 
library, without documentation or programs. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'install'\par \pard \li400 
Copies the current library version (one of optimised, debugging, or 
profiling, selected by the above environment variables), into your 
compiler lib directory, recompiling it as required, and installs the 
Allegro headers. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'install-lib' (Unix only)\par \pard \li400 
You can use this to install the library and the modules only, without 
documentation or programs.  Use the 'install' target to install 
everything. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'installall' (non-Unix only)\par \pard \li400 
Copies all three library versions (optimised, debugging, and profiling), 
into your compiler lib directory, recompiling them as required, and 
installs the Allegro headers. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'uninstall'\par \pard \li400 
Removes the Allegro library and headers from your compiler directories. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'docs'\par \pard \li400 
Converts the documentation files from the ._tx sources. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'chm-docs' (Windows only)\par \pard \li400 
Creates a compiled HTML file from the previously generated html output. 
This is not a default target, since you need Microsoft's HTML compiler 
(http://go.microsoft.com/fwlink/?LinkId=14188), 
and it has to be installed somewhere in your PATH. Also, this only works 
if you use '@multiplefiles' (see the top of docs/src/allegro._tx). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'docs-dvi' (Unix only)\par \pard \li400 
Creates the allegro.dvi device independent documentation file. This is 
not a default target, since you need the texi2dvi tool to create it. The 
generated file is especially prepared to be printed on paper. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'docs-ps' or 'docs-gzipped-ps' or 'docs-bzipped-ps' (Unix only)\par \pard \li400 
Creates a PostScript file from the previously generated DVI file. This is 
not a default target, since you need the texi2dvi and dvips tools to 
create it. The second and third targets compress the generated Postscript 
file. The generated file is especially prepared to be printed on paper. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'docs-pdf' (Unix only)\par \pard \li400 
Creates a PDF file. This is not a default target, since you need the 
texi2pdf tool to create it. The generated file is especially prepared to 
be printed on paper, and it also has hyperlinks. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'docs-devhelp' (Unix only)\par \pard \li400 
Creates normal HTML documentation with an additional xml index file which 
can be used by tools like Devhelp (http://www.devhelp.net/) to 
show context sensitive help within any editor using Devhelp, like for 
example http://anjuta.sourceforge.net/. The Allegro 'book' will be 
created in `docs/devhelp/allegro.devhelp', you have to install it 
manually. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'install-man' (Unix and Mac OS X only)\par \pard \li400 
Generates Unix man pages for each Allegro function or variable and 
installs them. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'install-gzipped-man' or 'install-bzipped-man' (Unix only)\par \pard \li400 
Like install-man, but also compresses the manual pages after installing 
them (run only one of these). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'uninstall-man' (Unix)\par \pard \li400 
Uninstalls any man pages previously installed with 'install-man', 
'install-gzipped-man', or 'install-bzipped-man'. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'install-info' or 'install-gzipped-info' or 'install-bzipped-info' 
(Unix only)\par \pard \li400 
Converts the documentation to Info format and installs it. The second 
and third targets compress the info file after installing it (run only 
one of them). 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'uninstall-info' (Unix only)\par \pard \li400 
Uninstalls any man pages previously installed with 'install-info', 
'install-gzipped-info', or 'install-bzipped-info'. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'clean'\par \pard \li400 
Removes generated object and library files, either to recover disk space 
or to force a complete rebuild the next time you run make. This target is 
designed so that if you run a "make install" followed by "make clean", 
you will still have a functional version of Allegro. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'distclean'\par \pard \li400 
Like "make clean", but more so. This removes all the executable files and 
the documentation, leaving you with only the same files that are included 
when you unzip a new Allegro distribution. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'veryclean'\par \pard \li400 
Use with extreme caution! This target deletes absolutely all generated 
files, including some that may be non-trivial to recreate. After you run 
"make veryclean", a simple rebuild will not work: at the very least you 
will have to run "make depend", and perhaps also fixdll.bat if you are 
using the Windows library. These targets make use of non-standard tools 
like SED, so unless you know what you are doing and have all this stuff 
installed, you should not use them. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'compress' (DJGPP, MinGW and MSVC only)\par \pard \li400 
Uses the DJP or UPX executable compressors (whichever you have installed) 
to compress the example executables and utility programs, which can 
recover a significant amount of disk space. 
\par \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li400 'depend'\par \pard \li400 
Regenerates the dependency files (obj/*/makefile.dep). You need to run 
this after "make veryclean", or whenever you add new headers to the 
Allegro sources. 
\par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Available Allegro examples}Available Allegro examples\par }
With Allegro comes quite a bunch of examples, which go from the simple 
introductory `Hello world' to more complicated programs featuring truecolor 
blending effects. This chapter describes these examples which you can find 
in the allegro/examples folder. You don't have to go through them in the same 
order as this documentation, but doing so you will learn the basic functions 
and avoid missing any important bit of information. 
\par \par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exhello}exhello\par }
{\li400 This is a very simple program showing how to get into graphics 
mode and draw text onto the screen. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exmem}exmem\par }
{\li400 This program demonstrates the use of memory bitmaps. It creates 
a small temporary bitmap in memory, draws some circles onto it, 
and then blits lots of copies of it onto the screen. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v expal}expal\par }
{\li400 This program demonstrates how to manipulate the palette. It draws 
a set of concentric circles onto the screen and animates them by 
cycling the palette. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v expat}expat\par }
{\li400 This program demonstrates the use of patterned drawing and sub-bitmaps. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exflame}exflame\par }
{\li400 This program demonstrates how to write directly to video memory. 
It implements a simple fire effect, first by calling getpixel() and 
putpixel(), then by accessing video memory directly a byte at a 
time, and finally using block memory copy operations. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exdbuf}exdbuf\par }
{\li400 This program demonstrates the use of double buffering. 
It moves a circle across the screen, first just erasing and 
redrawing directly to the screen, then with a double buffer. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exflip}exflip\par }
{\li400 This program moves a circle across the screen, first with a 
double buffer and then using page flips. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exfixed}exfixed\par }
{\li400 This program demonstrates how to use fixed point numbers, which 
are signed 32-bit integers storing the integer part in the 
upper 16 bits and the decimal part in the 16 lower bits. This 
example also uses the unusual approach of communicating with 
the user exclusively via the allegro_message() function. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exfont}exfont\par }
{\li400 This is a very simple program showing how to load and manipulate fonts. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exmouse}exmouse\par }
{\li400 This program demonstrates how to get mouse input. The 
first part of the test retrieves the raw mouse input data 
and displays it on the screen without using any mouse 
cursor. When you press a key the standard arrow-like mouse 
cursor appears.  You are not restricted to this shape, 
and a second key press modifies the cursor to be several 
concentric colored circles. They are not joined together, 
so you can still see bits of what's behind when you move the 
cursor over the printed text message. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v extimer}extimer\par }
{\li400 This program demonstrates how to use the timer routines. 
These can be a bit of a pain, because you have to be sure 
you lock all the memory that is used inside your interrupt 
handlers.  The first part of the example shows a basic use of 
timing using the blocking function rest(). The second part 
shows how to use three timers with different frequencies in 
a non blocking way. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exkeys}exkeys\par }
{\li400 This program demonstrates how to access the keyboard. The 
first part shows the basic use of readkey(). The second part 
shows how to extract the ASCII value. Next come the scan codes. 
The fourth test detects modifier keys like alt or shift. The 
fifth test requires some focus to be passed. The final step 
shows how to use the global key array to read simultaneous 
key presses. 
The last method to detect key presses are keyboard callbacks. 
This is demonstrated by by installing a keyboard callback, 
which marks all pressed keys by drawing to a grid. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exjoy}exjoy\par }
{\li400 This program uses the Allegro library to detect and read the value 
of a joystick. The output of the program is a small target sight 
on the screen which you can move. At the same time the program will 
tell you what you are doing with the joystick (moving or firing). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exsample}exsample\par }
{\li400 This program demonstrates how to play samples. You have to 
use this example from the command line to specify as first 
parameter a WAV or VOC sound file to play. If the file is 
loaded successfully, the sound will be played in an infinite 
loop. While it is being played, you can use the left and right 
arrow keys to modify the panning of the sound. You can also 
use the up and down arrow keys to modify the pitch. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exmidi}exmidi\par }
{\li400 This program demonstrates how to play MIDI files. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exgui}exgui\par }
{\li400 This program demonstrates how to use the GUI routines. From 
the simple dialog controls that display a text or a bitmap to 
more complex multiple choice selection lists, Allegro provides 
a framework which can be customised to suit your needs. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v excustom}excustom\par }
{\li400 A follow up of the exgui.c example showing how to customise the 
default Allegro framework. In this case a dialog procedure 
animates a graphical clock without disrupting other GUI 
dialogs.  A more simple option shows how to dynamically change 
the font used by all GUI elements. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exunicod}exunicod\par }
{\li400 This program demonstrates the use of the 16-bit Unicode text 
encoding format with Allegro. The example displays a message 
translated to different languages scrolling on the screen 
using an external font containing the required characters to 
display those messages. 
\par \par Note how the Allegro unicode string functions resemble the 
functions you can find in the standard C library, only these 
handle Unicode on all platforms. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exbitmap}exbitmap\par }
{\li400 This program demonstrates how to load and display a bitmap 
file.  You have to use this example from the command line to 
specify as first parameter a graphic file in one of Allegro's 
supported formats.  If the file is loaded successfully, 
it will be displayed until you press a key. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exscale}exscale\par }
{\li400 This example demonstrates how to use PCX files, palettes and stretch 
blits. It loads a PCX file, sets its palette and does some random 
stretch_blits. Don't worry - it's VERY slowed down using vsync(). 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exconfig}exconfig\par }
{\li400 This is a very simple program showing how to use the Allegro 
configuration (ini file) routines. A first look at the example 
shows nothing more than a static graphic and the wait for 
a key press. However, the way this graphic is displayed is 
configured through a custom exconfig.ini file which is loaded 
manually. From this file the example obtains parameters like 
fullscreen/windowed mode, a specific graphic resolution to set 
up, which graphic to show, how to blit it on the screen, etc. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exdata}exdata\par }
{\li400 This program demonstrates how to access the contents of an 
Allegro datafile (created by the grabber utility). The example 
loads the file `example.dat', then blits a bitmap and shows 
a font, both from this datafile. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exsprite}exsprite\par }
{\li400 This example demonstrates how to use datafiles, various sprite 
drawing routines and flicker-free animation. 
\par \par Why is the animate() routine coded in that way?  As you 
probably know, VIDEO RAM is much slower than "normal" 
RAM, so it's advisable to reduce VRAM blits to a minimum. 
Drawing sprite on the screen (meaning in VRAM) and then 
clearing a background for it is not very fast. This example 
uses a different method which is much faster, but require a 
bit more memory. 
\par \par First the buffer is cleared (it's a normal BITMAP), then the 
sprite is drawn on it, and when the drawing is finished this 
buffer is copied directly to the screen. So the end result is 
that there is a single VRAM blit instead of blitting/clearing 
the background and drawing a sprite on it.  It's a good method 
even when you have to restore the background. And of course, 
it completely removes any flickering effect. 
\par \par When one uses a big (ie. 800x600 background) and draws 
something on it, it's wise to use a copy of background 
somewhere in memory and restore background using this 
"virtual background". When blitting from VRAM in SVGA modes, 
it's probably, that drawing routines have to switch banks on 
video card. I think, I don't have to remind how slow is it. 
\par \par Note that on modern systems, the above isn't true anymore, and 
you usually get the best performance by caching all your 
animations in video ram and doing only VRAM->VRAM blits, so 
there is no more RAM->VRAM transfer at all anymore. And usually, 
such transfers can run in parallel on the graphics card's 
processor as well, costing virtually no main cpu time at all. 
See the exaccel example for an example of this. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exexedat}exexedat\par }
{\li400 This program demonstrates how to access the contents of an Allegro 
datafile (created by the grabber utility) linked to the executable by the 
exedat tool. It is basically the exdata example with minor 
modifications. 
\par \par You may ask: how do you compile, append and exec your program? 
\par \par Answer: like this... 
\par \par 1) Compile your program like normal. Use the magic filenames with '#' 
to load your data where needed. 
\par \par 2) Once you compressed your program, run "exedat foo.exe data.dat" 
\par \par 3) Finally run your program. 
\par \par Note that appending data to the end of binaries may not be portable 
across all platforms supported by Allegro. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v extrans}extrans\par }
{\li400 This program demonstrates how to use the lighting and 
translucency functions. The first part of the example will 
show a dark screen illuminated by a spotlight you can move 
with your mouse. After a key press the example shows the full 
bitmap and the spotlight changes to be a reduced version of 
the background with 50% of translucency. 
\par \par The translucency effect is easy to do in all color depths. 
However, the lighting effect has to be performed in a different 
way depending on whether the screen is in 8bit mode or another 
color depth. This is because additive drawing mode uses a 
different set of routines for truecolor modes. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v extruec}extruec\par }
{\li400 This program shows how to specify colors in the various different 
truecolor pixel formats. The example shows the same screen (a few 
text lines and three coloured gradients) in all the color depth 
modes supported by your video card. The more color depth you have, 
the less banding you will see in the gradients. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v excolmap}excolmap\par }
{\li400 This program demonstrates how to create custom graphic effects 
with the create_color_table function. Allegro drawing routines 
are affected by any color table you might have set up. In 
the first part of this example, a greyscale color table is 
set. The result is that a simple rectfill call, instead of 
drawing a rectangle with color zero, uses the already drawn 
pixels to determine the pixel to be drawn (read the comment 
of return_grey_color() for a precise description of the 
algorithm). In the second part of the test, the color table 
is changed to be an inverse table, meaning that any pixel 
drawn will be shown as its color values had been inverted. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exrgbhsv}exrgbhsv\par }
{\li400 This program shows how to convert colors between the different 
color-space representations. The central area of the screen 
will display the current color. On the top left corner of the 
screen, three sliders allow you to modify the red, green and 
blue value of the color. On the bottom right corner of the 
screen, three sliders allow you to modify the hue, saturation 
and value of the color. The color bars beneath the sliders 
show what the resulting color will look like when the slider 
is dragged to that position. 
\par \par Additionally this example also shows how to "inherit" the 
behaviour of a GUI object and extend it, here used to create 
the sliders. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exshade}exshade\par }
{\li400 This program demonstrates how to draw Gouraud shaded (lit) 
sprites.  In an apparently black screen, a planet like sprite 
is drawn close to the middle of the screen. In a similar 
way to how the first test of extrans works, you move the 
cursor on the screen with the mouse. Attached to this mouse 
you can imagine a virtual spotlight illuminating the scene 
around. Depending on where the mouse is, the Gouraud shaded 
sprite will show the direction of the light. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exblend}exblend\par }
{\li400 This program demonstrates how to use the translucency functions 
in truecolor video modes. Two image files are loaded from 
disk and displayed moving slowly around the screen. One of 
the images will be tinted to different colors. The other 
image will be faded out with a varying alpha strength, and 
drawn on top of the other image. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exxfade}exxfade\par }
{\li400 This program demonstrates how to load and display bitmap files 
in truecolor video modes, and how to crossfade between them. 
You have to use this example from the command line to specify 
as parameters a number of graphic files. Use at least two 
files to see the graphical effect. The example will crossfade 
from one image to another with each key press until you press 
the ESC key. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exalpha}exalpha\par }
{\li400 This program demonstrates how to use the 32 bit RGBA 
translucency functions to store an alpha channel along with 
a bitmap graphic.  Two images are loaded from disk. One will 
be used for the background and the other as a sprite. The 
example generates an alpha channel for the sprite image, 
composing the 32 bit RGBA bitmap during runtime, and draws 
it at the position of the mouse cursor. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exlights}exlights\par }
{\li400 This program shows one way to implement colored lighting effects 
in a hicolor video mode. Warning: it is not for the faint of heart! 
This is by no means the simplest or easiest to understand method, 
I just thought it was a cool concept that would be worth 
demonstrating. 
\par \par The basic approach is to select a 15 or 16 bit screen mode, but 
then draw onto 24 bit memory bitmaps. Since we only need the bottom 
5 bits of each 8 bit color in order to store 15 bit data within a 
24 bit location, we can fit a light level into the top 3 bits. 
The tricky bit is that these aren't actually 24 bit images at all: 
they are implemented as 8 bit memory bitmaps, and we just store the 
red level in one pixel, green in the next, and blue in the next, 
making the total image be three times wider than we really wanted. 
This allows us to use all the normal 256 color graphics routines 
for drawing onto our memory surfaces, most importantly the lookup 
table translucency, which can be used to combine the low 5 bits 
of color and the top 3 bits of light in a single drawing operation. 
Some trickery is needed to load 24 bit data into this fake 8 bit 
format, and of course it needs a custom routine to convert the 
resulting image while copying it across to the hardware screen. 
\par \par This program chugs slightly on my p133, but not significantly 
worse than any double buffering in what amounts to a 1920x640, 
256 color resolution. The light blending doesn't seem to slow 
it down too badly, so I think this technique would be quite usable 
on faster machines and in lower resolution hicolor modes. The 
biggest problem is that although you keep the full 15 bit color 
resolution, you only get 3 bits of light, ie. 8 light levels. 
You can do some nice colored light patches, but smooth gradients 
aren't going to work too well :-) 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v ex3d}ex3d\par }
{\li400 This program demonstrates how to use the 3d matrix functions. 
It isn't a very elegant or efficient piece of code, but it 
does show the stuff in action. It is left to the reader as 
an exercise to design a proper model structure and rendering 
pipeline: after all, the best way to do that sort of stuff 
varies hugely from one game to another. 
\par \par The example first shows a screen resolution selection dialog. 
Then, a number of bouncing 3d cubes are animated. Pressing 
a key modifies the rendering of the cubes, which can be 
wireframe, the more complex transparent perspective correct 
texture mapped version, and many other. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v excamera}excamera\par }
{\li400 This program demonstrates how to use the get_camera_matrix() 
function to view a 3d world from any position and angle. The 
example draws a checkered floor through a viewport region 
on the screen. You can use the keyboard to move around the 
camera or modify the size of the viewport. The keys that can 
be used with this example are displayed between brackets at 
the top of the screen. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exquat}exquat\par }
{\li400 Euler angles are convenient for storing and creating 3D orientations. 
However, this program demonstrates that they are not good when 
interpolating between two different orientations. The problem is 
solved by using Allegro's quaternion operations. 
\par \par In this program, two cubes are rotated between random orientations. 
Notice that although they have the same beginning and ending 
orientations, they do not follow the same path between orientations. 
\par \par One cube is being rotated by directly incrementing or decrementing 
the Euler angles from the starting point to the ending point. 
This is an intuitive notion, but it is incorrect because it does not 
cause the object to turn around a single unchanging axis of rotation. 
The axis of rotation wobbles resulting in the object spinning in 
strange ways. The object will eventually end up in the orientation 
that the user intended, but it gets there in a way that is unattractive. 
Imagine if this method was used to update the position of a camera in a 
game! Sometimes it would swing wildly and disorient the player. 
\par \par The other cube is animated using quaternions. This results in a much 
more pleasing animation because the cube turns around a single axis 
of rotation. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exstars}exstars\par }
{\li400 This program draws a 3D star field (depth-cued) and a polygon 
starship (controllable with the keyboard cursor keys), using 
the Allegro math functions. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exscn3d}exscn3d\par }
{\li400 This program demonstrates how to use scanline sorting algorithm 
in Allegro (create_scene, clear_scene, ... functions). It 
also provides an example of how to use the 3D clipping 
function. The example consists of a flyby through a lot of 
rotating 3d cubes. 
\par}\par \par \par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exzbuf}exzbuf\par }
{\li400 This program demonstrates how to use Z-buffered polygons and 
floating point 3D math routines. It also provides a simple 
way to compute fps (frames per second) using a timer. After 
selecting a screen resolution through the standard GUI dialog, 
the example shows two 3D cubes rotating and intersecting each 
other. Rather than having full polygons incorrectly overlap 
other polygons due to per-polygon sorting, each pixel is drawn 
at the correct depth. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exscroll}exscroll\par }
{\li400 This program demonstrates how to use hardware scrolling. 
The scrolling should work on anything that supports virtual 
screens larger than the physical screen. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v ex3buf}ex3buf\par }
{\li400 This program demonstrates the use of triple buffering. Several 
triangles are displayed rotating and bouncing on the screen 
until you press a key. Note that on some platforms you 
can't get real hardware triple buffering.  The Allegro code 
remains the same, but most likely the graphic driver will 
emulate it. Unfortunately, in these cases you can't expect 
the animation to be completely smooth and flicker free. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v ex12bit}ex12bit\par }
{\li400 This program sets up a 12-bit mode on any 8-bit card, by 
setting up a 256-colour palette that will fool the eye into 
grouping two 8-bit pixels into one 12-bit pixel. In order 
to do this, you make your 256-colour palette with all the 
combinations of blue and green, assuming green ranges from 0-15 
and blue from 0-14. This takes up 16x15=240 colours. This 
leaves 16 colours to use as red (red ranges from 0-15). 
Then you put your green/blue in one pixel, and your red in 
the pixel next to it. The eye gets fooled into thinking it's 
all one pixel. 
\par \par The example starts setting a normal 256 color mode, and 
construct a special palette for it. But then comes the trick: 
you need to write to a set of two adjacent pixels to form a 
single 12 bit dot. Two eight bit pixels is the same as one 16 
bit pixel, so after setting the video mode you need to hack 
the screen bitmap about, halving the width and changing it 
to use the 16 bit drawing code. Then, once you have packed a 
color into the correct format (using the makecol12() function 
below), any of the normal Allegro drawing functions can be 
used with this 12 bit display! 
\par \par Things to note: 
\par \par \par {\li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 The horizontal width is halved, so you get resolutions 
like 320x480, 400x600, and 512x768. 
\par \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 Because each dot is spread over two actual pixels, the 
display will be darker than in a normal video mode. 
\par \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 Any bitmap data will obviously need converting to the 
correct 12 bit format: regular 15 or 16 bit images won't 
display correctly... 
\par \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 Although this works like a truecolor mode, it is 
actually using a 256 color palette, so palette fades are 
still possible! 
\par \pard \li800 \par {\pntext\f2\fs16 \'b7\tab}
{\*\pn \pnlvlblt\pnf2\pnfs16\pnindent250{\pntxtb \'b7}}
\fi-250\li800 This code only works in linear screen modes (don't try 
Mode-X).\par}
\par}\pard \li0 {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exaccel}exaccel\par }
{\li400 This program demonstrates how to use an offscreen part of 
the video memory to store source graphics for a hardware 
accelerated graphics driver. The example loads the `mysha.pcx' 
file and then blits it several times on the screen. Depending 
on whether you have enough video memory and Allegro supports 
the hardware acceleration features of your card, your success 
running this example may be none at all, sluggish performance 
due to software emulation, or flicker free smooth hardware 
accelerated animation. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exspline}exspline\par }
{\li400 This program demonstrates the use of spline curves to create smooth 
paths connecting a number of node points. This can be useful for 
constructing realistic motion and animations. 
\par \par The technique is to connect the series of guide points p1..p(n) with 
spline curves from p1-p2, p2-p3, etc. Each spline must pass though 
both of its guide points, so they must be used as the first and fourth 
of the spline control points. The fun bit is coming up with sensible 
values for the second and third spline control points, such that the 
spline segments will have equal gradients where they meet. I came 
up with the following solution: 
\par \par For each guide point p(n), calculate the desired tangent to the curve 
at that point. I took this to be the vector p(n-1) -> p(n+1), which 
can easily be calculated with the inverse tangent function, and gives 
decent looking results. One implication of this is that two dummy 
guide points are needed at each end of the curve, which are used in 
the tangent calculations but not connected to the set of splines. 
\par \par Having got these tangents, it becomes fairly easy to calculate the 
spline control points. For a spline between guide points p(a) and 
p(b), the second control point should lie along the positive tangent 
from p(a), and the third control point should lie along the negative 
tangent from p(b). How far they are placed along these tangents 
controls the shape of the curve: I found that applying a 'curviness' 
scaling factor to the distance between p(a) and p(b) works well. 
\par \par One thing to note about splines is that the generated points are 
not all equidistant. Instead they tend to bunch up nearer to the 
ends of the spline, which means you will need to apply some fudges 
to get an object to move at a constant speed. On the other hand, 
in situations where the curve has a noticeable change of direction 
at each guide point, the effect can be quite nice because it makes 
the object slow down for the curve. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exsyscur}exsyscur\par }
{\li400 This program demonstrates the use of hardware accelerated mouse cursors. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exupdate}exupdate\par }
{\li400 This program demonstrates how to support double buffering, 
page flipping, and triple buffering as options within a single 
program, and how to make things run at a constant rate no 
matter what the speed of your computer. You have to use this 
example from the command line to specify as first parameter a 
number which represents the type of video update you want: 1 
for double buffering with memory bitmaps, 2 for page flipping, 
3 for triple buffering and 4 for double buffering with system 
bitmaps. After this, a dialog allows you to select a screen 
resolution and finally you will see a kaleidoscopic animation, 
along with a frames per second counter on the top left of 
the screen. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exswitch}exswitch\par }
{\li400 This program shows how to control the console switching mode, and 
let your program run in the background. These functions don't apply 
to every platform and driver, for example you can't control the 
switching mode from a DOS program. 
\par \par Yes, I know the fractal drawing is very slow: that's the point! 
This is so you can easily check whether it goes on working in the 
background after you switch away from the app. 
\par \par Depending on the type of selected switching mode, you will see 
whether the contents of the screen are preserved or not. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v exstream}exstream\par }
{\li400 This program shows how to use the audio stream functions to 
transfer large blocks of sample data to the sound card. In 
this case, the sample data is generated during runtime, 
and the resulting sound reminds of a car engine when you 
are accelerating. 
\par}\par {\s3 \f0\fs24\sb200\keepn\sa200\b Example {\xe\v expackf}expackf\par }
{\li400 This program demonstrates the use of the packfile functions, with some 
simple tests. 
\par \par The first test uses the standard packfile functions to transfer a 
bitmap file into a block of memory, then reads the bitmap out of the 
block of memory, using a custom packfile vtable. 
\par \par The second test reads in a bitmap with another custom packfile 
vtable, which uses libc's file stream functions. 
\par \par The third test demonstrates seeking with a custom vtable. 
\par \par The fourth test reads two bitmaps, and dumps them back into a 
single file, using a custom vtable again. 
\par \par \par \par \par}{\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Additional programs included with Allegro}Additional programs included with Allegro\par }
Allegro comes with several useful utility programs. They are currently 
documented separately. Refer to the HTML documentation (including CHM 
and devhelp) of Allegro which includes all the documents, or the single 
plain text versions of these documents (makedoc.txt, grabber.txt, dat.txt, 
dat2s.txt, dat2c.txt). 
\par \par \par \par \par {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Community}Community\par }
Allegro was originally created by Shawn Hargreaves. Published sometime between 
1994 and 1995, it was just a simple lib for himself. At that time, many people 
were switching from Borland C to DJGPP and looking for a decent graphics 
library. Allegro was the first reasonably complete one to show up, so it 
attracted enough interest to keep growing, and a little contribution here, and 
some more encouragement there made it all light up like fire. 
\par \par Some time after the latest 3.x stable release, though, Shawn was flooded with 
Allegro tasks and Real Life (TM) work, and chose the latter to focus his 
energies on. While this somehow stalled Allegro's development, it also 
attracted a lot of people who wanted Allegro to live longer. Also, by that 
time other people had started to work on Windows and Unix ports of Allegro, 
which suggested that Allegro had the potential to survive its only decaying 
main platform (DOS). 
\par \par The current situation is that Shawn still keeps watching Allegro's progress 
from time to time, but is not involved with development any more. The 
community that grew over the years when Shawn was in charge of everything has 
stepped forward to continue improving Allegro. Transformed into a meritocratic 
community, users keep sending bug reports to the mailing lists, developers 
around the world keep sending patches to fix them, and a few carefully chosen 
have write access to the SVN repository, from which releases are built every 
now and then. 
\par \par But, who decides when a build is stable enough? Who decides when somebody is 
granted write access to the SVN? Who chooses the lesser of two evils patching 
some obscure bug? And more importantly, who decides what's Allegro's mascot? 
For all these reasons, the community decided to replace Shawn's position with 
the Allegro Dictator. 
\par \par In republican Rome, political power was with the Senate and the Consuls. 
However, if it was necessary that decisions were made very quickly then the 
senate could appoint a Dictator. The Dictator was appointed for a specified 
duration or charged with a specific task, after which he was expected to 
surrender his authority back to the Senate. Nowadays, the Allegro Dictator is 
a benevolent figure and rarely has to use his overwhelming fist of iron to put 
order into chaos. 
\par \par The truth is that the Allegro Dictator is usually the person in charge of 
doing releases and all that unsexy work inside the community, like pestering 
users to test some obscure bugfix or rejecting incomplete patches. 
\par \par Past Allegro dictators have been: Shawn Hargreaves, George Foot, Peter Wang 
and Eric Botcazou. At the moment of writing this, Evert Glebbeek is the 
active Allegro Dictator. Should you want to change Allegro in some illogical 
way, he's the guy you have to send your bribes too :-) 
\par {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Conclusion}Conclusion\par }
All good things must come to an end. Writing documentation is not a good 
thing, though, and that means it goes on for ever. There is always something 
we've forgotten to explain, or some essential detail we've left out, but for 
now you will have to make do with this. Feel free to ask if you can't figure 
something out. 
\par \par Enjoy. We hope you find some of this stuff useful. 
\par \par \par \par By Shawn Hargreaves and the Allegro development team. 
\par \par http://alleg.sourceforge.net/
\par \par \par \par \par {\s2 \f0\fs48\sa600\pagebb\keepn\ul {\xe\v Index}Index\par }
\par 
{\field{\*\fldinst INDEX \\e "\tab " \c "1" }{\fldrslt {\b\i\ul\fs24\cf2 Update this field to generate the document index.}}}
\par \par \par \par \par \par }
